[{"title":"在Github上使用Hexo搭建个人博客","date":"2019-12-28T12:14:25.000Z","path":"2019/12/28/在Github上使用Hexo搭建个人博客.html","text":"成品示例展示：https://itgoyo.github.io/ 1、Hexo搭建环境一、环境安装 node.js（在node.js官网中下载安装）node.js官网 git（OS系统中直接安装x-code就可以了） hexo 1）打开OS系统终端 2）输入安装hexo的代码(此处安装时有可能会提示输入系统管理员密码) $ sudo npm install -g hexo 如果以上命令安装失败的话，换 1sudo npm install --unsafe-perm --verbose -g hexo 二、hexo创建静态博客 新建blog文件夹 在终端进入该文件夹，初始化博客 $ hexo init 上述完成后，生成原始文件；blog文件夹就是博客的根目录 本地查看：启用本地服务命令(退出按ctrl+c) $ hexo s 将出现的地址输入浏览器，即可可查看到本地效果 三、github配置 注册github账号并登陆 获取本机的SSH口令 1）输入获取代码，回车直到出现图片所示图形为止 $ ssh-keygen 2）输入编译代码 $ vim ~/.ssh/id_rsa.pub3）出现SSH口令后，将红框部分复制，并在下方输入:q，随后按下回车可以退出该窗口 4）进入到github页面设置SSH口令 点击用户下拉菜单中的settings（step1) 点击左侧的SHH and GPG keys（step2) 在Title中输入口令名称（随意）（step3) 在key中贴上SSH口令（step4) 创建新的仓库 1）创建新的仓库（repOSitory） 点击用户左侧的+号菜单中的New repOSitory（step1) 在repOSitory name中输入二级域名，格式请严格遵照username.github.io（step2) ps：username填写github的登录用户名，否则上线的时候会报错 是否公开选项可以选取Public（step3) 勾选step4处，会自动生成一份可编辑的README.md文件（建议勾选）（step4) 点击create repOSitory生成仓库完毕（step5) 2）查看新建的仓库（repOSitory） 可以回到github个人首页点击右侧的仓库区 进入后在step1处选择并复制http地址，注意此时step2处应该是空的 四、发布博客 设置blog配置文件 1）打开blog文件夹下的_config.yml文件 2）找到最下方的type，输入git（注意冒号后面是带空格的） 3）repo行可能没有，需要自己输入，后面跟上github上仓库中复制的http地址（注意此时1、2两处应该是一样的username），不然上传时会报错 4）其他博客设置 title：博客名称 subtitle：博客副标题 description：博客描述 author：作者 language：语言（简体中文是zh-CN） 在终端上传博客 1）进入终端，输入git上传插件安装代码（安装时会提示输入github用户名及密码） $ npm install hexo-deployer-git –save2）安装完毕后，输入获取代码 $ hexo g3）最后输入上传代码 $ hexo d4）重新在github仓库查看上传文件，此时在step2中会有之前bolg中生成的文件 5）step3处就是你的博客地址 五、新建与更新博客 新建博客 1）终端bolg文件下，输入新建博客代码 $ hexo new &apos;filename&apos; 2）此时在bolg/source/_posts/下面会看到新建的博客 3）博客文件的后缀是.md文件，OS下推荐使用MOU编辑器mou下载地址 更新博客 1）完成编辑后，在终端上依次重复以下代码（此时必须先将编辑器关闭，否则会出现获取错误） $ hexo g $ hexo d 2）完成后便能刷新博客网页看到新更新的内容了 2、Hexo加入评论功能Yilia主题（别的主题也是一样的操作）首先，我们要有一个多说的账号多说(2017-6-1废弃) 然后进入到后台把我们的网站填写进去 在theme/yilia/layout/_partial/post/目录下创建文件名叫：duoshuo.ejs把以下代码复制进去 123456789101112131415161718&lt;div class=\"duoshuo\"&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=\"ds-thread\" data-thread-key=\"&lt;%=key%&gt;\" data-title=\"&lt;%=title%&gt;\" data-url=\"&lt;%=url%&gt;\"&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=\"text/javascript\"&gt; var duoshuoQuery = &#123;short_name:'&lt;%= config.duoshuo_shortname %&gt;'&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt;&lt;/div&gt; 在hexo/_comfig.yml里边添加一下代码（名字换成自己的） 1duoshuo_shortname: xxxx(冒号后有空格) 最后在theme/yilia/_config.yml 里边添加以下代码（名字换成自己的） 12duoshuo: trueshort_name: xxxx #名字换你自己在多说后台的名字(冒号后有空格) 一共配置两处地方不然即便是看到评论功能，但是不会保留别人对你的评论 然后重新提交代码刷新即可看到评论功能 Yilia添加Disqus评论只需要在Yilia主题里边的_config.yml添加一句 disqus_shortname: 你的Disqus账户名称 2、Hexo加入网易云音乐Yilia主题（我使用的是这个主题就用这个来讲）进入网易云音乐: 官网 推荐：自己注册账号，这样子可以创建自己喜欢的歌单，在里边收藏自己喜欢的歌曲 然后进入到自己的歌单 点击生成外链，获取到云音乐播放器代码 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=300 height=270 src=&quot;https://music.163.com/outchain/player?type=0&amp;id=120897804&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; 选择生成自己喜欢的样式，然后复制代码 最后打开（themes/yilia/layout/_partial/left-col.ejs）把复制好的网易云音乐放到第二行里边(当然这个是我的样式，我选择放在左边，你喜欢放在那里自己选择) 最后的效果图如下 3、Hexo加入百度统计yilia主题为🌰 编辑文件 themes/yilia/_config.yml ,添加一行配置，可以删除原来的google analytics 1baidu_tongji: true 新建 themes/yilia/layout/_partial/baidu_tongji.ejs 内容如下 12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script type=\"text/javascript\"&gt;#申请的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt; 编辑themes/yilia/layout/_partial/head.ejs 在 前添加 1&lt;%- partial(\"baidu_tongji\") %&gt; 重新生产部署站点即可。 Light主题 编辑文件 themes/yilia/_config.yml ,添加一行配置，可以删除原来的google analytics 1baidu_tongji: true` 新建 themes/light/layout/_partial/baidu_tongji.ejs 内容如下 12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script type=\"text/javascript\"&gt;#申请的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt; 编辑themes/Yilia/layout/_partial/head.ejs 在 前添加 1&lt;%- partial(\"baidu_tongji\") %&gt;` 重新生产部署站点即可。最后多说一句，因为文章是采用Markdown格式编辑的，所以不免会使用到图片的时候，这个时候如果是在跟目录下创建图片文件，这样子搬迁或者复制什么的会很不便，在此我想向大家推荐一个免费的图床极简图床只要复制图片粘贴到极简图床，它会自动生成Markdown格式的图片地址 最好申请一个七牛云，这样子就可以创建自己的私密空间。 Ubuntu下首先安装nodejs12345678sudo apt-get nodejssudo npm cache clean -fsudo npm install -g nsudo n stable出现了相应的版本号了之后sudo n xxx 提交到Girhub还要安装一个git插件12345npm install hexo-deployer-git --save之前一直报错，然后手贱敲错npm install hexo-deployer-git --save、多了一个、居然成功了？！ 邮箱 ：itgoyo@gmail.com Good Luck! 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Program","slug":"Program","permalink":"https://github.com/itgoyo/tags/Program/"}]},{"title":"Ubuntu安装完之后所需要做的配置","date":"2017-12-28T12:18:16.000Z","path":"2017/12/28/Ubuntu安装完之后所需要做的配置.html","text":"#字体推荐思源lantern可以设置全局代理 安装好了ubuntu之后，安装gnome主题安装Gnome之前，升级系统：12$ sudo apt update$ sudo apt upgrade 12sudo apt-get updatesudo apt-get install gnome-session-flashback 安装完之后使用classic主题登录（此时终端不可用ctrl+alt+t） Ubuntu 16.04/16.10安装KDE Plasma12345$ sudo add-apt-repository ppa:kubuntu-ppa/backports # Ubuntu 16.04# 如果使用16.10，不用添加第三方源$ sudo apt update$ sudo apt upgrade$ sudo apt install kubuntu-desktop lightdm：Unity桌面默认的Display Manager ssdm：KDE桌面更倾向于使用ssdm（选这个）最后安装登录系统没反应，只有一个下划线，然后在登录时ctrl+alt+F3进入终端模式1sudo apt-get remove kubuntu-xxxx 然后登录的时候就可以使用gnome登录，此时终端可使用快捷键唤出 Ubuntu安装QQcrossover安装与破解 在官网下载crossover安装包： https://www.codeweavers.com/products/crossover-linux 等待安装完毕，安装完成后先不要打开crossover，下载破解文件： https://pan.baidu.com/s/1slTLv8T 在命令行输入sudo nautilus打开一个root权限的文件管理器 把破解文件 (crossover16crack-&gt;winewrapper.exe.so) 替换路径: /opt/cxoffice/lib/wine下的winewrapper.exe.so文件。提示已有文件，点“替换”破解完成。 安装Deepin QQ 7.9 轻聊版 下载安装包： https://pan.baidu.com/s/1gfl00ZT 下载之后用归档管理器打开 点开 data.tar.xz 找到 ./opt/cxoffice/support把 apps.com.qq.im.light 这个文件夹提取出来 在命令行输入sudo nautilus打开一个root权限的文件管理器 然后将这个文件夹复制到系统的 /opt/cxoffice/support 下 QQ最小化叫唤不出来解决123sudo apt-add-repository ppa:fixnix/indicator-systemtray-unitysudo apt-get updatesudo apt-get install indicator-systemtray-unity 或者是使用gnome主题 win+alt 鼠标右键状态栏 add to panel 增加消息通知事件即可 Ubuntu安装Chrome2.在终端中，输入以下命令：1234567sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -sudo apt-get updatesudo apt-get install google-chrome-stable sudo:/etc/sudoers 可被任何人写 解决方案解决方式 123sudoers的权限被改了，改回来就好了。pkexec chmod 0440 /etc/sudoers git push时提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支123git remote add origin https://github.com/username/test.git $git fetch origin $git merge origin/master .md模板12345678910111213title: &quot;[译]Kotlin 1.1 候选版本来啦&quot;date: 2017-02-17 13:37:00author: Mikhail Glukhikhtags:keywords:categories: 官方动态reward: falsereward_title: Have a nice Kotlin!reward_wechat:reward_alipay:source_url: https://blog.jetbrains.com/kotlin/2017/02/kotlin-1-1-release-candidate-is-here/translator: ahong222translator_url: https://github.com/ahong222 tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz .tar.bz解压：tar jxvf FileName.tar.bz .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .tgz解压：tar zxvf FileName.tgz .tar.tgz解压：tar zxvf FileName.tar.tgz压缩：tar zcvf FileName.tar.tgz FileName .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar a FileName.rar压缩：rar e FileName.rar .lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName AndroidStudio配置123456789101112131415161718Edit /etc/apt/sources.list file and add one of following line :deb http://download.virtualbox.org/virtualbox/debian trusty contribSave and exitupdate using :sudo apt-get updateAccording to virtualbox_wiki you need to Install dkmssudo apt-get install dkmsSetup oracle public key:wget http://download.virtualbox.org/virtualbox/debian/oracle_vbox.ascsudo apt-key add oracle_vbox.ascInstall Oracle VirtualBoxsudo apt-get updatesudo apt-get install virtualbox-5.0 安装OBS推流软件1234sudo apt-get install ffmpegsudo add-apt-repository ppa:obsproject/obs-studiosudo apt-get update &amp;&amp; sudo apt-get install obs-studio ftp上传文件使用Filezillia 注意！！！ 上传文件的时候默认是不支持中文的，要自己在站点设置里边强制使用UTF-8字符集 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/itgoyo/tags/Linux/"}]},{"title":"猎场中出现过的书籍及其含义","date":"2017-12-24T16:05:51.000Z","path":"2017/12/25/猎场中出现过的书籍及其含义.html","text":"《查令十字街84号》 &#160; &#160; &#160; &#160;原著作者：海莲·汉芙 剧中场景：罗伊人大学刚毕业时，这本书带在身边 &#160; &#160; &#160; &#160;《查令十字街84号》用书信体讲述美国作家海莲·汉芙与英国书店老板弗兰克的传奇书缘。它作为罗伊人手中的第一本书出现，为罗伊人的“文青”角色定调。罗伊人大学毕业后将这本书带在身边，闲来翻看，第一次出现在罗伊人与第二任男友白力勤一起收看郑秋冬的演讲直播时，第二次是罗伊人在医院照顾摔伤了的老白时。而书中人物的感情线，预示了罗伊人与郑秋冬一次次错过彼此。其实，与《查令十字街84号》产生关联的还有一部非常有名的国产电影，那就是由吴秀波和汤唯主演的《北京遇上西雅图之不二情书》。 《挪威的森林》 原著作者：村上春树 剧中场景：罗伊人上大一时送给郑秋冬 &#160; &#160; &#160; &#160;《猎场》里最重要的一本书，就是胡歌在剧集开始最常阅读的《挪威的森林》。书中讲述主人公在救赎别人时完成对自我的拯救。《挪威的森林》男主人公“渡边彻”有两任女朋友，第一任“直子”是初恋、同学，恰好对应罗伊人。而“渡边彻”第二任女朋友“小林绿子”热情迷人，与男主人公偶遇相识，对应了郑秋冬的第二位女朋友熊青春。这本书是罗伊人上大一时送给郑秋冬的，寄托了郑秋冬对她的相思，也是郑秋冬因传销入狱后自我救赎的最好注脚。 《男人错，女人错》 原著作者：陶新华 剧中场景：熊青春假称怀孕考验郑秋冬，用了书中的观点看其反应 &#160; &#160; &#160; &#160;熊青春为了敲诈郑秋冬而故意接近他，随后两人陷入感情纠葛，并且一起创业开办了公司。作为郑秋冬的第二任女朋友。熊青春虽然精明又热情，却始终对爱情没有安全感。有次她捧着一本书和郑秋冬闲聊，忽然就说自己怀孕了，郑秋冬马上反应“结婚吧”。熊青春大笑，因为她没怀孕，只是对自己刚刚看到的书中观点现学现卖，考验郑秋冬并得到了满分的回答。她看的这本书就是《男人错，女人错》。这本“婚姻启示录”分析了8类情感问题，对42个情感故事做了深度解读，探索婚恋情感背后的人性奥秘。 《风中绿李》 原著作者：荷塔·慕勒 剧中场景：白力勤住院，这本书陪伴罗伊人度过内心煎熬的时刻 &#160; &#160; &#160; &#160;罗伊人在第二任男友白力勤住院期间读的书是《风中绿李》。这本书的德文原著书名直译为《心兽》，书中点题处在主人公的祖母吩咐孩子的一句话：“现在就让你内心的野兽安静下来。”本书通过第一人称的视角，讲述了几位死者的故事。它几乎可以被视作老白绝症去世的一种暗示。同时，书中的故事让读者对正义与欺瞒产生思考，这也对应着郑秋冬当时深陷传销集团，正义感和想赚快钱的两种心态之间的博弈。 《边走边啃腌萝卜》 原著作者：妹尾河童 剧中场景：郑秋冬入狱后，罗伊人边吃泡面边看此书 &#160; &#160; &#160; &#160;《边走边啃腌萝卜》是一本游记，主人公通过在各处寻访民间自制的腌萝卜，进而体验着不同人的生活。从寺院到监狱，从远洋渔船到山野猎人，主人公被腌萝卜牵引着开启了一段又一段新的人生体验。在郑秋冬入狱后，罗伊人失去依靠，边吃泡面边看此书，书名点出了罗伊人的处境，而这本书带着她的心灵周游了外面的世界，这恰恰预示着，罗伊人接下来遇到夏吉国，开启了自己的新世界之门。 《青春咖啡馆》 原著作者：帕特里克·莫迪亚诺 剧中场景：罗伊人在陪第四任男友于成飞拍戏期间阅读此书 &#160; &#160; &#160; &#160;看《青春咖啡馆》这本书时，罗伊人恰好刚刚听说郑秋冬与熊青春分手，因此书名暗示“熊青春”。《青春咖啡馆》这本书讲述的是一个失踪女人“露姬”的四个故事。书中有两个关键词与《猎场》剧情对应，一个是“可以停靠的港湾”，象征着罗伊人在与夏吉国分手后，出车祸被于成飞搭救，选择于成飞为新男友时的心态。书中另一个关键词是“过客”，预示着罗伊人与于成飞必然分手的结局。 《伊斯坦布尔假期》 原著作者：马克·李维 剧中场景：罗伊人与于成飞分手后，到杭州见郑秋冬时阅读此书 &#160; &#160; &#160; &#160;《伊斯坦布尔假期》是目前出现在罗伊人书单上的最新的书名，说的是女主人公阿丽斯经过漫长的旅程，终于找到真命天子的故事。罗伊人与于成飞分手以后，到杭州做短期旅行，除了见老友葵大姐之外，也见了前男友郑秋冬。在闲暇时间，她看的就是这本书。“生命中总有一些征兆，指引我们相遇”，《伊斯坦布尔假期》中的这句话，也恰恰是罗伊人和郑秋冬之间情路的路标，杭州就是罗伊人的伊斯坦布尔。虽然郑秋冬身边此刻还有一个贾衣玫，不过随着他们的分手，也给了罗伊人与郑秋冬再续前缘的机会。 《匡蒂科规则》 原著作者：吉恩·里尔 剧中场景：猎银行行长赵见蜓期间，郑秋冬阅读此书 &#160; &#160; &#160; &#160;《匡蒂科规则》是一本悬念迭起、构思缜密的关于政府高层腐败阴谋的故事。小说充满了紧张的氛围和错综复杂的阴谋陷阱，以及栩栩如生的联邦调查局特工生活。郑秋冬从初出茅庐时手持《挪威的森林》到成熟老练随身携带《匡蒂科规则》，暗示他的成长。和袁坤职场大战之后，秋冬的手段越来越熟练了，包括在赵见蜓学历造假东窗事发后，公司中负责做背景调查的贾衣玫都不知道的信息，郑秋冬却调查得一清二楚，郑秋冬和赵见蜓的韩国校友网络聊天时，暗暗用手机录音，这都彰显了郑秋冬手段意识极强。而赵见蜓学历造假事件是袁坤为报复郑秋冬设的局，复杂的职场权谋，比《匡蒂科规则》中描写的有过之而无不及。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://github.com/itgoyo/tags/生活随笔/"}]},{"title":"Foobar2000","date":"2017-12-24T14:25:12.000Z","path":"2017/12/24/Foobar2000.html","text":"Foobar2000Foobar+BBE插件 链接：https://pan.baidu.com/s/1boQosiF 密码：bg1x 软件整体效果如下： 小状态栏效果如下： 功能设置界面如下： 功能 自带专辑封面显示 桌面歌词显示(据说还可以联网下载歌词，本人没有验证过) 支持音乐列表查询 支持自定义音效插件 插件BBEBBE技术不是简单的增强高频波，而是把延迟了的高频波时间提前，将其重新置于基波之前，它也是用一些增强技术来恢复一些被削弱了的高频波。 安装步骤 安装BBE.Sound.All.Plugins.Bundle.VST.RTAS.v1.0.9.20r3.x86.x64-ASSiGN 复制foo_vst_0903/foo_vst.dll到foobar目录中的components里面 打开设置界面选择组件模块会新增VST plug-ins,然后选择add去添加你刚刚安装文件夹里面的组件默认路径C:\\Program Files (x86)\\Steinberg\\Vstplugins\\BBE Sound 设置-播放-DSP管理器-选择D82 Sonic Maximizer-配置所选 最后会出现如下图所示的插件 in表示Maximizer on LO CONTOUR: 调节低频激励的量，调整低频部分的相位补偿量 PROCESS: 调节高频激励的量，调整高频部分的相位补偿量 OUTPUT LEVEL: 调节处理后信号的电平。可以有效的避免当音频经过处理后，因为电平过载所产生的爆音。 右侧的两排LED灯用来显示BBE D82 Sonic Maximizer输出信号的大小（处理以后的信号大小）。每个LED指示灯代表一定单位数量的输出电平的大小，单位是分贝。例如：”0”代表0dBFs信号音量，”-6”代表-6dBFs，以此类推。在固定输入信号大小的情况下，增加BBE Process和LO Contour的数量将提升输出信号音量，LED显示也会更加明亮。顶部Clip的LED灯可以用来监视输出信号大小，当输出信号超过0dBFs时Clip的LED灯将亮起来，这也就意味着输出信号失真了。 具体效果怎么样可以自己用耳朵反复去试听，然后选出自己合适的效果 youtube软件测试对比效果 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://github.com/itgoyo/tags/生活随笔/"}]},{"title":"很认真的聊一聊程序员的自我修养","date":"2017-12-09T14:18:35.000Z","path":"2017/12/09/很认真的聊一聊程序员的自我修养.html","text":"原文地址:https://www.cnblogs.com/printhelloworld/p/5698984.html#commentform 何为程序员的自我修养？正面论述很难说清楚，反向描述可能更通俗易懂一些，自我修养的对立面是“没有修养”，先说一说在这么多年的工作、学习、生活中，遇到的一些我认为“没有修养”的程序员形态： 1、程序员小张遇到了一个开发问题，很着急，想到了有几个群，于是到群里发了他的问题，坐等回答，发现没有人回答，就直接对话群主的QQ，群主也不回答，于是小张就搜索，突然搜到博客园有个帖子讲解了相关话题，他看完就给博主留言，我的邮箱是：XXXXX@qq.com，麻烦博主把源码发给我一下，谢谢。 2、程序员小张进公司3个月了，老板布置了很多任务，他觉得老板很没人性，工资给的不高，加班也不给钱，于是在写代码的时候能省就省，客户反馈有问题也不主动解决，敷衍为主，又过了一个月，跳槽了。 3、程序员小张正在写一个功能模块，需要进行某种加密，到百度搜到了一个编码模块，看不明白具体写了什么，但是放到程序里刚好适用，于是就这么原封不动放进去了。 4、程序员小张要对某个功能进行研发，项目经理对他说，这个功能应该能搜索到，你去搜搜看，小张就在百度搜啊搜，一天过去了啥都没找到，项目经理来到小张身边坐下，换了个关键词，1分钟就搜到了解决方案。 5、程序员小张学.NET已经工作3年了，工资还是10000，和公司提涨工资也没答应，想跳槽又犹豫，这时某个前辈对他说，你去看书吧，多看一些书，例如 《Visual C# 从入门到精通》，《CLR via C#》《Javascript权威指南》等等，于是小张买回来了， 随手翻了翻发现有些东西是他已经会的，有些看不懂的好像又用不到，而且书这么厚，要不要浪费时间去看呢？小张就这样反复纠结了半年，依然每天上班工作，下班LOL，偶尔还抱怨一下工资低。 6、程序员小张到了一家新公司，在做一个项目实现某个功能时，想起来以前做过这样的功能，可是竟想不起怎么实现了，于是就到自己电脑上找文档，找了好久也没找到，只好放弃，最后又折腾了2天，终于还是把这个功能给实现了。 7、程序员小张某天非常不高兴，因为他的项目经理和项目组的产品人员又变更需求了，新的需求又要对整个结构进行大的调整，小张很郁闷，到一个QQ里发泄情绪，说了这个事，于是立马，QQ群里面炸开锅了，程序员小李说，对，产品就是狗日的！程序员小王说，对，他妈的项目经理整天高枕无忧，就知道压榨开发人员！程序员小孙说，是的是的，我上一家公司也是这样，压榨程序员，幸好我走了。就这样，在一片骂声中，几个程序员心情舒畅了，小张开心的去玩王者荣耀去了。 我想，有些人可能已经明白我要说什么，有些人可能还不明白，具体的话我也说不出来，只能用一句话来概括就是： 在编写代码的过程中，善于学习、掌握方法、勤加思考、勤奋努力、持之以恒，长此以往，在编程中，你会发现不一样的自己。 提升自我修养的具体方法有哪些？程序员具体如何达成“较高的修养”，每个人各有自己的办法，我无法说到很细，就和如何提高做人修养一样，一句两句话是说不清楚的，但是有些说法也通俗易懂，比如一个小孩，有教育良好的父母，父母彬彬有礼，小孩从小开始接受正规教育，小学、初中、高中、大学，然后文化课程和社会实践良好，那么这个小孩最终的做人修养，一定比没有经历过这个过程的小孩更好一些。 同样的，写程序也是如是，下面我就讲一些最基本的、最浅显易懂的学习方法和道理，我把它叫做： 程序员基础的基础 一个好的开发人员，应该能够全面、高效、严谨的去处理任何软件程序和业务问题，成为一个好的开发，是一个很有意思的话题，不过无论这个话题如何开展，基础两个字必不可少，虽然代码量是衡量开发能力的重要指标，但仅能够熟练的进行代码编写是不够的，更要能深刻的理解技术原理和业务逻辑，扎实的个人基础和技术基础往往会促进代码的编写，更游刃有余的解决问题。 下面说的一些基础，可能绝大部分开发人员都不会在意甚至忽略，但恰恰这些才是开发大厦的基石。 1、科学基础成为开发人员的过程不尽相同，有的是科班出身，有的是兴趣爱好，还有的是专业机构的培训，在这个过程中，可能全面或者零散甚至没有学习过计算机基础学科，但无论是哪一种，想要成为更高层次的开发人员，写出更高质量的代码，计算机基础学科的学习，是非常非常非常（重要的事情说三遍）重要的。具体的来说，基础学科在实践应用中，有如下几门是一定需要的，按照学习顺序排列如下 1）数据结构 数据结构课程通俗的说就是告诉你如何用最基本的语言类型、变量，关键词语句等，去处理各式各样的逻辑问题，我们称之为算法，而日常编程中的各种问题，例如排序、文件夹遍历操作、数据库查询等，都可以在数据结构课程中，找到对应的数学原型。数据结构课程的理解能力，也是一个人数学能力的体现，数据结构学习的好坏，是程序员水平差异的一个重要分水岭，对于这一块内容的学习，有如下建议：使用VB、C、C++、Pascal等语言，买一本相关语言数据结构与算法的书，或者在网上下载相关的PDF电子书，完整的学习一边，并将书本中的所有案例亲自编写运行调试一遍，当能够领悟到某些日常编程中常见手法源于某些数据结构和算法时，就基本达到了学习效果。 2）操作系统 所有编程语言的开发以及应用的运行，都基于操作系统，桌面编程中的大部分场景包括内存、进程、文件系统、网络通讯、用户界面等，都源于操作系统的定义和概念，完整的了解操作系统的起源和组成以及运行逻辑，对多线程、复杂界面、文件管理以及一些难以正常理解编程思路等开发中遇到的场景，有非常大的帮助，不仅帮助理解，也能掌握更多有效的程序写法。具体可以买一本操作系统的书或者下载相关PDF电子书，完整的浏览一遍，做到能够结合实际编程场景来看待操作系统原理，就基本达到了学习效果。 3）数据库 传统的关系型数据库，入门简单，深入却难，往往开发人员能够较快的掌握增删改查、视图、索引、存储过程等基本数据库操作，却在编写复杂查询、设计主外键、优化字段、去除冗余等时，出现只会依葫芦画瓢却不能自主思考扩展的状况。究其原因还是没能了解关系数据库的根本原理，而数据库这一门课程，系统的阐述了关系型数据库的来龙去脉，了解其中的数学原理或逻辑基础所在，对提升数据库编程水平有质的影响。建议也是买一本数据库的相关书籍或者下载PDF电子书，能够把熟练的把第一范式、第二范式等数据库课程的基本知识点与数据库编程场景建立起关联，也基本达到了学习效果。 4）编译原理 编译原理是编程语言以及各类语言编译器的科学基础，可以说编译原理创造了世界上的几乎所有的IT应用，学习编译原理的基础是数据结构和算法，因此编译原理的学习要花费更多的时间和精力，由于现代高级编程语言的编译器，在代码优化、资源优化方面已经做的足够智能，因此，编译原理的学习对实战的影响越来越小，但是正所谓本盛末荣，如果认为自己对数据结构和算法的学习达到了一个较高的水平和状态，可以在编译原理学习上进一步深入，最终把自己和普通程序员拉开更大的差距。 2、英语能力英语的天然特性和字母长度还有学科发展的历史因素，决定了编程语言一定是基于英语的，在编程过程中，从语言的关键词到文档的内容又或是搜索引擎的搜索结果，都不可避免的会遇到英文。大部分编程人员，都具备英语四级左右的英文基础，却由于非专业以及工作环境原因，逐渐疏远甚至完全淡忘了英语。而实际操作中，大部分编程语言资料都是英文，在线编程问答内容也是英文，因此，很有必要把英语能力重新恢复到一个不用太高但行之有效的水平，达到如下效果： 1）对自己所使用语言，每一个关键词都知道具体的英文翻译、逻辑含义以及读音。 2）对于自己使用语言所涉及到的相关方法、类库、框架、工具等，能知道其中每一个方法、过程以及参数关键词等的英文翻译、逻辑含义以及读音。 3）对常见的编程逻辑和核心关键词，能够用英文组织问题的描述，最简答的也行，只要能被搜索引擎读懂就可以。比如如何在C#中把整形转换为字符串类型这个问题，最简易的英文描述就是 C# Integer Covert To String。 4）在自己技术知识范围内的任何的英文的技术手册、文档、文章或是问题描述，能够读懂8成的内容含义，能够读懂完整的技术含义。 3、搜索方法任何一个开发人员，都应当具备搜索能力，甚至是一定要具备搜索能力，搜索引擎的宝藏，是无穷无尽的，同样具备搜索意识的不同程序员，却因为搜索技巧的差异最终在程序开发质量、项目实施效率、甚至是工程产品质量上出现数倍的差异，因此，掌握高效、先进、灵活的搜索方法和技巧，是非常非常非常（重要的事情说三遍）有用的。其中主要的方法介绍如下： 1）搜索源选择 虽然英文的编程资料更为准确高效，但中文的编程资料数量上却占优，因此遇到问题第一搜索选择还是百度谷歌对于专业中文词汇的处理能力有时候甚至比百度还要强，而且谷歌能搜出大量的英文资源，因此谷歌也是首选之一，但是由于谷歌被封锁，因此需要进行VPN、SSH等FQ操作，或者在百度搜索“谷歌镜像”关键词，通过谷歌的镜像网站进行访问。除了搜索引擎，专业的技术网站、论坛、社区也是非常直接有效的搜索源，比如国外的StackOverFlow网站，国内的Cnblogs博客园、OSChina开源中国等，都具备搜索功能，将问题关键词输入其中，也许也会很快的得到相关答案。对于QQ群，建议不要使用，除非QQ群主或者成员是非常闲或者非常非常热心的人，否则在QQ群询问技术问题，是非常低效率的搜索方式。2）关键词构造 搜索关键词的构造，直接影响搜索效率和正确结果的过滤，没有什么特别的技巧，关键在于搜索积累，但是总体遵循的原则是，准确和简洁，比如当出现一个描述，如何用C#对XML进行序列化和反序列化，非常愚蠢的关键词构造就是“如何用C#对XML进行序列化和反序列化”，而正确高效的关键词则是“C# XML 序列化 反序列化”,或者在谷歌里面搜索则是“C# XML Serialization”。在平时的编程中，一定要注意相关方法和经验的积累 3）联想搜索 联想搜索，不属于搜索引擎的范畴，却是在搜索中很有用的高级技巧，举一个通俗的例子，比如想使用C#，利用某个.NET类处理一种HTTP通讯，但是一直搜索不到完美的结果，不过换个思路，考虑到VB.NET也是.NET体系，和C#完全相通，那么也可以试着用VB.NET关键词进行搜索，搜索到完美代码后再临摹成C#代码。这样的联想搜索，不仅能够帮助搜索正确结果，也是对大脑思维的训练，值得多多尝试。 4）资源搜索 开源的框架、产品、工具、控件等开发辅助类东西越来越多，稳健性和迭代性越来越强，去寻找一款成熟的工具或者插件，也成为了大量开发者的必备方法和技能，而如何高效的搜索出想要的资源，也成为了一门学问，其核心方法就在于知晓资源网站的地址，常见的例如有开源中国、Github、CSDN下载、pudn等。资源类网站需要平时多积累，到用到的时候会非常关键。 4、思维模式开发人员，一定要养成业务思维的模式，所谓的业务思维，就是在做任何一个项目的时候，写任何代码前，需要对项目本身的业务概念和业务逻辑甚至业务流程都要有一个全面的学习和理解，这虽然不是一个项目的强制要求，却是一个很好的开发习惯，无论自己的觉得是开发者还是测试员又或是技术总监，掌握了业务原理，才能够更好的设计或阅读项目的数据结构和流程结构。程序员的思维往往和用户或者客户是不一致的，摆脱技术思维模式，习惯于用业务思维解决问题的程序员，不一定最优秀，但一定是一个很容易沟通的程序员 5、工作与编程习惯有的人说爱干净浪费时间，所以不修边幅，但归根结底这还是习惯问题，当养成清洁卫生的习惯并使之成为生活惯性时，往往就不会耗费更多的时间，反而显得干净干练。写程序同样如是，有一些编程习惯，看似不足为道，看似浪费时间，可是如果坚持下去，最终都能收到意想不到的奇效。下面列举一些特别重要的习惯。 1）快捷键的使用 无论是使用Windows、Linux操作系统，还是在IDE中，快捷键都是系统本身的标配，事实上，Ctrl+C、V这样的操作，大部分人都能尝到在节省时间上的甜头，把这个概念进一步扩散，如果在IDE中编写代码，除了代码本身，将其余所有的鼠标操作、键盘定位操作，都用快捷键来代替的话，在时间上将会有数量级的节省，然而看上去这么好的事情，真正坚持去执行并形成习惯的人屈指可数，因此，在初期的改变习惯，记住快捷键，会是一个长期的过程，需要不断的坚持。 2）代码注释 一个开发人员随着年龄和经验的增长，所参与的项目，再也不是靠一个人或者几个人就能完成的。系统的重构、代码的重构、工作的交接、对新进人员的培训等等类似的事情，会越来越多的遇到，这些事情无一例外都会把已经写过的代码重新或者重复阅读，如果在初始编写代码时，就做到完整、清晰明了的代码注释，对后续工作会有巨大的帮助。不仅提高工作效率，还能增强合作好感。事实上，就算只是自己看自己的代码，如果有注释，也能加深印象，缩短代码查找时间。因此，任何开发人员，都应该养成良好的代码注释习惯。 优秀的代码注释应该能做到： 每一个函数、每一个属性甚至是变量的划分，都可以找到对应的解释。多使用越来越被IDE支持的XML注释方式，不仅有注释文字，更有详细的参数描述。对程序结构、模块、组成部分划分等也加以注释3）命名规则 具备一定规模的软件公司，在代码编写上都有一套自己的命名规则，涵盖项目、模块、函数、变量等等，标准化命名的好处不言而喻，然而被动、被迫去遵守命名规则和主动习惯于使用命名规则是完全不一样的。一个优秀的开发人员，应当发自内心的希望各种代码命名都是有规则的，易读的，而不是纠结于命名规则会增加码字长度。 4）不将就的编程逻辑 所谓不将就的编程逻辑，其对立面就是不讲究的编程逻辑，不讲究的编程，不仅是一种很坏的编程习惯，也体现了低下的生活品质，很多开发人员，因为个人习惯、赶工期、客户要求不高等多种原因，在编程时特别随意，体现在比如为了实现某个功能，百度出一段代码，直接套用，10行的代码只理解8行，有两行看不懂也放到程序里去使用，很多这样的小细节，就好比在项目中埋下了无数的定时炸弹，不仅有很大概率形成返工，更是为项目埋下了风险。编程人员，应当有担当有态度，养成不将就的编程逻辑，不勉强自己，也不轻视程序。 5）数据备份 误删、误操作、电脑断电、文件遗失等等状况是每一个开发按人员都可能遇到的问题，如果不希望辛勤的劳作被浪费，不希望偶然的意外影响工作，那做好备份是必不可少的，在较大规模的公司，会有完整的源代码管理以及信息安全防护，而无论是在大公司工作，还是身处较小公司或者在实现个人代码价值时，都要做好代码和文档的数据备份，备份方式的选择灵活多样，有使用在线的CVS、SVN、TFS、Git源代码管理，也可以手工拷贝文件至云空间或者本地硬盘，甚至可以在个人电脑上组成RAID磁盘阵列等等，养成周期性、规律性的备份习惯。 6）邮件工作方式 沟通是进步的源泉，如果说开发小组的热烈讨论是性格和激情的体现，那邮件的工作方式也是另一种稳重和高效。无论是公司层面的工作沟通，还是开发小组的问题交流，邮件的作用包括问题正规化描述、工作留档留痕、工作流程流转、责任分工明确等等，习惯于将重大问题、重要事项通过邮件的方式与同事、主管等进行沟通，将会非常有助于团队协作。 以上这些方法，是我这么多年来的感受和体会，也给了我很大的帮助，希望也能够帮助到大家，不能说一定可以“提升修养“，但也是”提升修养”的有效方式。 最后还想再说一说坚持的力量 分享一个真实的小故事，公司有两个开发人员，1个做.NET好多年了，但是很油滑，做事能省就省，抓到可以偷懒的机会就偷懒，让他学点新知识新方法总是自以为是觉得自己都会；还有1个毫无.NET基础，一直做低级语言开发，从15年才开始学习.NET和Web前端，但是做事很积极，几乎每天都自己抽空学习，遇到不懂的都琢磨清楚，遇到不会的场景就上网或者找人寻求帮助，项目结束后还反复思考有什么地方可以改进。从15年到现在，短短1年，这两个人的发展已经是天壤之别，工资差距也越来越大，后者已经能够独自操盘中小型软件外包项目，而前者还在混着日子，以后他们各自的发展也完全可以预见。 我想说的是，本篇里面分享的一些道理和方法，都是通俗易懂的，就和常听到的例如101%和99%的365次方的故事、1万小时的道理等等一样，但真正去认真思考并实践的屈指可数，也许，坚持才是程序员最大的修养，和各位共勉 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://github.com/itgoyo/tags/生活随笔/"}]},{"title":"异步和多线程的区别","date":"2017-12-09T13:13:38.000Z","path":"2017/12/09/异步和多线程的区别.html","text":"原文地址:https://www.cnblogs.com/dream844/archive/2012/06/12/2546083.html 多线程和异步操作的异同多线程和异步操作两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性。甚至有些时候我们就认为多线程和异步操作是等同的概念。但是，多线程和异步操作还是有一些区别的。而这些区别造成了使用多线程和异步操作的时机的区别。 异步操作的本质所有的程序最终都会由计算机硬件来执行，所以为了更好的理解异步操作的本质，我们有必要了解一下它的硬件基础。 熟悉电脑硬件的朋友肯定对DMA这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。DMA就是直 接内存访问的意思，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，硬件就开 始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS 这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。 线程的本质线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。 异步操作的优缺点因为异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与普通人的思维方式有些 初入，而且难以调试。 多线程的优缺点多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。 适用范围在了解了线程与异步操作各自的优缺点之后，我们可以来探讨一下线程和异步的合理用途。我认为：当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。 而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。但是往 往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处 理大量的并发操作时就不合适了。 异步调用与多线程异步调用并不是要减少线程的开销, 它的主要目的是让调用方法的主线程不需要同步等待在这个函数调用上, 从而可以让主线程继续执行它下面的代码.与此同时, 系统会通过从ThreadPool中取一个线程来执行,帮助我们将我们要写/读的数据发送到网卡.由于不需要我们等待, 我们等于同时做了两件事情. 这个效果跟自己另外启动一个线程来执行等待方式的写操作是一样的.但是, 异步线程可以利用操作系统/.Net的线程池, 系统可以根据吞吐量动态的管理线程池的大小. 异步与多线程,从辩证关系上来看,异步和多线程并不时一个同等关系,异步是目的,多线程只是我们实现异步的一个手段.什么是异步:异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回.实现异步可以采用多线程技术或则交给另外的进程来处理 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"60天引爆你的学习力","date":"2017-12-05T16:21:26.000Z","path":"2017/12/06/60天引爆你的学习力.html","text":"60天引爆你的学习力 视频地址 链接: https://pan.baidu.com/s/1slNsZmt 密码: xcwm 1.看得懂,不会做 2.总比别人学得慢 3.总比别人学得差 什么是学习力? 学习知识的能力 管理知识的能力 长久坚持的能力 提升学习力的重要性? 重要性 性价比高 效果出众 三种典型错误 顺序式学习 缺乏整体概念 容易中途放弃 案例式学习 优点 目的性强 见效很快 成就感强 优点 不成体系 容易遗忘 范围狭小 冲刺式学习 缺点 容易遗忘 很难学透 效率较低 学习框架 生理 锻炼 作息 规律 心理 道德许可 正向激励 方法论 刻意练习 三步快速学习法 知识体系的构建和管理 学习资料的搜索\\判断\\和筛选 学习的8个步骤 方向 资料 筛选 认知 消化 固化 模式 拓展 非工作记忆 容易遗忘 浅层应用 效率较低 工作记忆 不易遗忘 灵活应用 效率很高 三步式快速学习法 第一步:快速建立领域整体认知 第二步:解决问题为导向,感性了解知识点,初步构建网络 第三步:刻意练习,补充隐知识整体的重要性 盲人摸象,告诉我们,了解整体对我们知识网络很有帮助,了解整体对我们了解细节也是很有帮助的 具体要怎么做呢? 建立整体认知 找到规范的教材 ( 基础\\应用类) 阅读目录,绘图 (制作思维导图) 速读 再次阅读目录及图 默认绘图 (根据回忆再画一次思维导图) 修改优化 这些做法有什么作用 了解全貌 了解结构 感性认识 目录是精华 目录有结构 速读做关联 再读做对比 再画避遗忘 还解决了 枯燥难懂 不解迷茫 正向激励 解决问题为向导 搜集整理案例 尝试解决问题 (完全没思路,看教程的方法/自己有思路,然后找方法,知道最终解决问题,最终写下解决问题的知识点) 复习模糊知识点 最终解决问题 写下解决问题的所有知识点 有哪些收获 抽象变感性 构建小型网络 得到正向激励 掌握程度加深 帮助实际工作 刻意练习+补充隐知识 回归原本 刻意练习 补充学习 实际案例 新手学习 PPT 刻意练习 是什么 打乒乓球\\打网球\\下象棋 重复的学习方式很低效 学习时间长不代表你很牛逼 &lt;刻意练习-从新手到大师&gt; 原理 稳态原理:人类超强的适应能力 手上的茧子 壮大的肱二头肌 变瘦的长跑运动员 人体总倾向于待在稳态外部变化,自己跟着变 大脑的适应能力 伦敦的出租车司机 厉害的音乐大师 心理表征 心理表征的质量和数量是牛人和普通人的最大区别 外行看热闹,内行看门道 怎么做 刻意练习的两大要求 不断打破稳态 构建和改进心理表征 刻意练习六步法 找套科学有效的训练方法 突破舒适区,不断适度挑战自己 不断拆分任务,化难为易 良好的目标感 包括反馈 产生和改进心理表征(大量练习) 如何设计自己的刻意训练体系 以写作为例 拆分大任务 词汇 句子 逻辑 技巧整合 类型文写作 设计训练方法 背诵词典法 高频词总结法 词语造句 句子写作 扩写训练法 长句拆解法 画面塑造法 逻辑训练 文章结构分析 思维导图训练 突破舒适区,循序渐进 大量的重复性基础训练 包含反馈 自我评价 网友评价 作业点评 创建和改进心理表征 实施要点 客服错误的认识 基因决定论 时间积累论 努力至上论 务必走出舒适区 适当超出能力 步子不要迈太大 尽量找到好的导师 好的指导老师 好的指导教材 好的指导课程 次数和质量并重 时间短 次数多 有质量 能改进 一定要有反馈机制 找不足 查原因 想办法 必改正 学习资料的搜索,筛选,管理 物理载体 音频 视频 图文 书籍 获取方式 搜索 推介 广告 形式分类 基础类教材 应用类教材 查阅类教材 普通人的需求 大量文章书籍音视频 如何判断教材质量 如何管理好大量的学习资料 必要的搜索技巧 搜索指令 按网站搜索 悬疑电影推荐 site:douban.com 按格式搜索 征服 filetype:PDF 排除式搜索 国产悬疑电影推荐 -国产 精准式搜索 “悬疑电影推荐” intitle: “悬疑电影推荐” 关键词提炼 自己想要的资料 资料可能有的关键词 资源点到资源的搜索思维 先找 PPT 模板网站 再在里面找 PPT 模板 我们需要什么 基础类教材 1.2本 应用类覆盖面越全面越好 百科全书类 1本就差不多了如何找到好的资料 老鸟推荐 KOL 推荐 高质量书单 问答网站 (知乎) 定向搜索如何判断教材质量 公开评价 看出版社 看作者口碑 看是编还是著 看再版次数和印刷数量 问老鸟大咖阅读的两种形式 随机性阅读 目的性阅读 (为知笔记,有道云,印象)学习资料管理三件事 实体资料电子化 电子资料分类标签化 打造自己的知识管理体系电子化的好处 方便携带 方便搜索知识的领域和结构三个案例幼儿的语言学习 听音学语言 听看学语言(学习的很好)PPT 训练营 操作技巧很熟练 整体水平很差劲记忆数字 20177639387 24936527309 学习的关联过程 概念和物体,行为的关联 概念和概念之间的关联 可以理解的输入才是有效的输入 领域和结构做好 PPT 的三个领域知识 PPT 操作技巧 插入元素 模板 快捷键 动画 足够的审美知识 空间结构 颜色搭配 元素设计 足够的逻辑能力 结构大纲 先后顺序 语言提炼 知识的领域 领域内部知识强链接 领域之间知识弱链接 领域,结构和心理表征 领域的数量 知识点的数量 网络密集程度 掌握质量 四个方法主题学习强领域的集中学习+刻意学习 扩展学习弱领域的关联阅读学习 最大的误区认为要学习的知识是单一领域的 解决的办法 结构知识领域,逐个击破 进行足够的扩展式学习 PPT 学习 内容结构 掌握软件操作技巧 排版布局和颜色搭配训练 扩展性学习 摄影作品 平面设计作品 相关书籍 i+1学习方法错误的学习方法硬着头皮往下看(以为现在看不懂,看着看着后面一定会懂,其实最后也啥都不懂) 正确的学习方法一切都是恰到好处 案例:通过阅读学英语上来就读英文著作 英语 i+1学习 测试词汇和阅读能力 寻找分级阅读材料 逐级网上阅读 费曼学习法 选择一个概念 把它教给完全不懂的另外一个人 如果卡壳，回到原始材料 回顾后简化语言表达（可选择） 阿何补充环节 讲解-理解测试环节 讲解-提问测试环节 理解-做题测试环节 一题多解学习法 案例:算24点 4,5,4,5 案例:插入形状+插入文本框 学习的矛盾之处 精力有限 脑容量有限 知识无限 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[]},{"title":"离职计划","date":"2017-11-27T15:31:05.000Z","path":"2017/11/27/离职计划.html","text":"离职计划 公司原因: 公司14薪变12薪 自己原因: 在这里技术没什么提高,一直在迭代新功能,公司也不注重技术这一块. 环境原因: 和直播组的小伙伴分开了,上班的时候一个交流的都没有他们都给承包到别的挂名公司上面去了,和网站这边的人也没什么交流,自己中间转过去也不是他们网站的,所以自己一个人也挺尴尬的. 今天被公司里年纪比较大的程序员拉去谈话, 见面的时候他就说关于项目开发你有什么计划,最近App 这边问题比较多,我就说没什么计划,就准备搞新版本的东西.然后解释到 bug 多,这个我和测试人员是不可能把所有的 bug 都捕捉到的,要通过用户不断的反馈搜集更多的 bug,因为引起 bug 的步骤或者原因都不尽相同.然后就说我技术不行,还有态度不行. 首先经我接手项目之后,我就负责一块我的荣誉模块的开发,上线之后这部分所出现的唯一 bug 就是文案写错了,然后 svn 上我所有的提交记录是除了新版本功能的代码之后就是提交 fixed bug 的记录,很多都是修改前任留下来的坑,让我一步步去测发现所有的 bug 是不可能的,而且我也不可能把整个项目的代码再审查一遍, 且不说 这样子要花大量没有意义的时间在上面, 关键是得到的成效也是甚微的. 关于态度这一点上我没否认,因为由于公司离职2/3的员工的原因,我自己也在准备了自己的计划,公司造成这样大流量的员工流失,肯定公司有很大的责任,我自己也肯定会为自己的职业规划做出不同的调整.因为平时没有时间的时候我很多都是花时间在写 Blog 或者是在学习新框架或者总结一些资料的事情上.因为我觉得这样子对我来说才是最有用的.当初第二版本的时候要求3个半月完成大改版,所以当初三个人讨论了一下项目的进度有可能不够,所以就没有从心搭建框架而是在原来的基础上改,还有不停的迭代新功能.现在新版本要是再重新开始搭建框架的话,有点不现实,因为项目太庞大了,集成的东西也很多,比如说支付,推送,分享之类的功能. 我其实主要不积极的原因是因为这个 app 才完成大改版没多久,也可以说不到一个月,原因是上一个产品经理离职了然后新来的产品把之前的东西又重新搞了一个遍,很多东西就是页面上的些许改变,也可能是为了体现他自己的工作量,猛的修改东西,把整个 app 都基本翻新了一个遍,这一点是我很不开心的地方,而且开会的时候他说他这样子觉得好,然后反驳他也坚持,公司领导一直觉得他这种又是对的,一直不发边自己特别的见解,很多地方都是他想怎么来就怎么搞,UI 和我们开发这边提了一些建议,他也不听,一直都在说他怎么怎么好,这样子比较好看什么的,我都无语了,如果是这样子的会,开来还有什么意义,你们产品还有领导直接自己开就好了呀,还让我们进去听做什么,我们说的观点也没人听,反倒是浪费了很多时间在开会上面. 在公司里我只认同能力强的,其他的官职领导什么的我是不怎么感冒,我也不和别人抢些什么东西,我就只想在自己职位上完成自己应该完成的事,其他的活动什么积极参与就好了,也不会给谁背后捅刀子,也不会去黑谁.反倒是某些所谓的领导由于顶撞几句,一直怀恨在心,各种让你穿小鞋. 之前我负责直播平台的开发,一直都很积极,因为项目是我一个人从无到有做出来的,像我自己的孩子一样,所以之前比较花时间在上面,还有为了跟进时代的变化换了网络框架,还有把 listview 换成 recyleview,还有集成 bugly 还有其他七七八八能增强app 性能的东西.到是到网站这边开发之后,这边接口文档还有写的接口各种不规范,然后丢一份阿里巴巴的 java 开发规范文档过来,我觉得真是好笑,一开始就没给代码规范,后面看见别人的文档好就直接丢过来了,而且他们网站那边的接口也不规范,参数什么的经常时不时少东西,还有经常请求不到正确的数据,然后两个人一起対调的时候发现那边的代码有错,还有就是请求返回的 json 内容,正确的,失败的返回也不给,每次都要自己去抓.网站那边共有3个人写接口,三个人写出来的东西有时候都不一样,一点都不规范,浪费我们这边很多时间,本来接口文档就是根据 app 客户端的需要做的,现在变成,他那边怎么写接口让我们这边去适应它或者说是完善它,比如很多时候什么都不返回,把那个字段都不返回了,有时候又莫名其妙的多几个字段,害得我们开发时候经常空指针,后面找原因都是返回的数据经常不一致造成的,最可怕的就是需要某个字段的时候,本该是在第三层的东西,他直接新增到你的最外层去了,有时候相同字段的东西,最外层的也有,第二,第三层的也有,说真的这种接口是我见过最烂的. 今天晚上开始计划这离职的事情,实现的话有可能要到年后才能实现,因为感觉自己没有准备好,现在也快12月份了,因为公司要扣你一个月,所以那会也快过年了,那会估计招人的公司会很少,因为很多公司的计划或者指标那会也基本完成了.所以趁这几个月的时间好好规划一下自己的离职计划,还有强化自己的编码能力,完善自己的知识面还有巩固一下自己的基础知识. 和老程序员对话的时候,他很多话,让我很受启发,他说他之前在中兴研发部的时候自己一个新人就拿了优秀员工奖,其他老员工都没有拿奖,因为他那会敢做别人不敢做的事,敢承担自己的责任.其他人没有要改项目的意愿,他自己就自己改了,说出了什么问题自己来承担,他说他之前还是一个研究生,比较喜欢研究新技术什么什么的.交谈一番下来我其实挺佩服他的,因为他很多时候都不是为了自己,而是为了公司,这一点让我深受启发,想想自己,确实自私了一点,都是为自己着想,其实项目即便不是你搭建的,你也有责任和义务去完善它,虽然出现问题的代码不是你写的,但是你也有责任让它完美不出现一些不该出现的 bug. 永远不要为了自己的错误去找任何理由,如果做不出来就想办法去沟通而不是说做不出来就不做了,因为做不出来是你自己的问题而不是产品提出来的东西不能做,为什么别人可以做你不可以做,这难道不是你的原因吗? 由于公司不注重开发的原因,还有缺少人文关怀,感觉在这里也没有大的增长空间,对于自己技能的提高也没什么帮助,差不多两年了,都是独立开发,遇到一些不懂的东西都是 google,stackoverflow,能交流的东西基本没有,公司能教会我的技术层面上的东西也没有.我要寻找一个更适合我的,或者是我想要的环境去实现自己的人生小目标. 后面会整理出一份关于自己在离职计划实践过程中看了什么书还有什么好的文章,源码之类的都会整理出来,关于面试相关的试题也会整理出来,不说了.准备先撸一遍&lt;第一行代码 第二版本&gt;的代码先. 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://github.com/itgoyo/tags/生活随笔/"}]},{"title":"给初学者的RxJava2教程","date":"2017-11-24T13:50:31.000Z","path":"2017/11/24/给初学者的RxJava2教程.html","text":"原文链接:http://www.jianshu.com/u/c50b715ccaeb Rxjava2(一)前言上个月RxJava2正式版发布了，但目前国内的资料还比较少，以前使用过RxJava1只需要看看更新文档就知道怎么使用了，但还有一些以前没用过RxJava的朋友可能就不知道怎么办了，不知道该看RxJava1还是直接跳到RxJava2。所以写下这个教程， 帮助那些没有用过RxJava的朋友入门。 注：如果你觉得写得不好，请直接批评指出。 我先回答这个问题：学习RxJava2需要先学习RxJava1吗？ 这个问题就像论坛经常问学Java前需要先学习C语言吗，这里就不引战了！（PHP是世界上最好的语言！！） 答案明显不是，如果你以前学过RxJava1，那么对于RxJava2只需要看看更新了哪些东西就行了，其最核心的思想并没有变化，如果你没学过RxJava1，没有关系，直接学习RxJava2。所以作为一个RxJava2的教程，本文中所有的名词都属于RxJava2中，并不涉及RxJava1。 要在Android中使用RxJava2, 先添加Gradle配置: 12compile &apos;io.reactivex.rxjava2:rxjava:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos; 正题在开始学习之前，先来介绍点原理性的东西。 网上也有很多介绍RxJava原理的文章，通常这些文章都从观察者模式开始，先讲观察者，被观察者，订阅关系巴拉巴拉一大堆，说实话，当我第一次看到这些文章的时候已经被这些名词给绕晕了，用了很长的时间才理清楚它们之间的关系。可能是我太蠢了，境界不够，领会不到那么多高大上的名词. 今天我用两根水管代替观察者和被观察者, 试图用通俗易懂的话把它们的关系解释清楚, 在这里我将从事件流这个角度来说明RxJava的基本工作原理。 先假设有两根水管： 上面一根水管为事件产生的水管，叫它上游吧，下面一根水管为事件接收的水管叫它下游吧。 两根水管通过一定的方式连接起来，使得上游每产生一个事件，下游就能收到该事件。注意这里和官网的事件图是反过来的, 这里的事件发送的顺序是先1,后2,后3这样的顺序, 事件接收的顺序也是先1,后2,后3的顺序, 我觉得这样更符合我们普通人的思维, 简单明了. 这里的上游和下游就分别对应着RxJava中的Observable和Observer，它们之间的连接就对应着subscribe()，因此这个关系用RxJava来表示就是： 12345678910111213141516171819202122232425262728293031323334//创建一个上游 Observable： Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;); //创建一个下游 Observer Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;subscribe&quot;); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, &quot;&quot; + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;error&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;complete&quot;); &#125; &#125;; //建立连接 observable.subscribe(observer); 这个运行的结果就是: 1234512-02 03:37:17.818 4166-4166/zlc.season.rxjava2demo D/TAG: subscribe12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 112-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 212-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 312-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: complete 注意: 只有当上游和下游建立连接之后, 上游才会开始发送事件. 也就是调用了subscribe() 方法之后才开始发送事件. 把这段代码连起来写就成了RxJava引以为傲的链式操作： 1234567891011121314151617181920212223242526272829Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;subscribe&quot;); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, &quot;&quot; + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;error&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;complete&quot;); &#125; &#125;); 接下来解释一下其中两个陌生的玩意：ObservableEmitter和Disposable. ObservableEmitter： Emitter是发射器的意思，那就很好猜了，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。 但是，请注意，并不意味着你可以随意乱七八糟发射事件，需要满足一定的规则： 上游可以发送无限个onNext, 下游也可以接收无限个onNext. 当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件. 当上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件. 上游可以不发送onComplete或onError. 最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然 注: 关于onComplete和onError唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, 并不一定会导致程序崩溃. 比如发送多个onComplete是可以正常运行的, 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError, 则收到第二个onError事件会导致程序会崩溃. 以上几个规则用示意图表示如下: 事件 示意图 只发送onNext事件 发送onComplete事件 发送onError事件 介绍了ObservableEmitter, 接下来介绍Disposable, 这个单词的字面意思是一次性用品,用完即可丢弃的. 那么在RxJava中怎么去理解它呢, 对应于上面的水管的例子, 我们可以把它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件. 注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件. 来看个例子, 我们让上游依次发送1,2,3,complete,4,在下游收到第二个事件之后, 切断水管, 看看运行结果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); Log.d(TAG, &quot;emit 4&quot;); emitter.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable mDisposable; private int i; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;subscribe&quot;); mDisposable = d; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, &quot;onNext: &quot; + value); i++; if (i == 2) &#123; Log.d(TAG, &quot;dispose&quot;); mDisposable.dispose(); Log.d(TAG, &quot;isDisposed : &quot; + mDisposable.isDisposed()); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;error&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;complete&quot;); &#125; &#125;); 运行结果为: 1234567891012-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: subscribe12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 112-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: onNext: 112-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 212-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: onNext: 212-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: dispose12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: isDisposed : true12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 312-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit complete12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 4 从运行结果我们看到, 在收到onNext 2这个事件后, 切断了水管, 但是上游仍然发送了3, complete, 4这几个事件, 而且上游并没有因为发送了onComplete而停止. 同时可以看到下游的onSubscribe()方法是最先调用的. Disposable的用处不止这些, 后面讲解到了线程的调度之后, 我们会发现它的重要性. 随着后续深入的讲解, 我们会在更多的地方发现它的身影. 另外, subscribe()有多个重载的方法: 123456public final Disposable subscribe() &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125; 最后一个带有Observer参数的我们已经使用过了,这里对其他几个方法进行说明. 不带任何参数的subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 老子可不管你发什么. 带有一个Consumer参数的方法表示下游只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写: 1234567891011121314151617181920Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); Log.d(TAG, &quot;emit 4&quot;); emitter.onNext(4); &#125;&#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;onNext: &quot; + integer); &#125;&#125;); 其他几个方法同理, 这里就不一一解释了. Rxjava2(二)正题还是以之前的例子, 两根水管: 正常情况下, 上游和下游是工作在同一个线程中的, 也就是说上游在哪个线程发事件, 下游就在哪个线程接收事件. 怎么去理解呢, 以Android为例, 一个Activity的所有动作默认都是在主线程中运行的, 比如我们在onCreate中打出当前线程的名字:123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(TAG, Thread.currentThread().getName());&#125; 结果便是:1D/TAG: main 回到RxJava中, 当我们在主线程中去创建一个上游Observable来发送事件, 则这个上游默认就在主线程发送事件. 当我们在主线程去创建一个下游Observer来接收事件, 则这个下游默认就在主线程中接收事件, 来看段代码: 123456789101112131415161718192021222324@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); &#125; &#125;); Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;onNext: &quot; + integer); &#125; &#125;; observable.subscribe(consumer); &#125; 在主线程中分别创建上游和下游, 然后将他们连接在一起, 同时分别打印出它们所在的线程, 运行结果为:1234D/TAG: Observable thread is : mainD/TAG: emit 1 D/TAG: Observer thread is :main D/TAG: onNext: 1 这就验证了刚才所说, 上下游默认是在同一个线程工作. 这样肯定是满足不了我们的需求的, 我们更多想要的是这么一种情况, 在子线程中做耗时的操作, 然后回到主线程中来操作UI, 用图片来描述就是下面这个图片: 在这个图中, 我们用黄色水管表示子线程, 深蓝色水管表示主线程. 要达到这个目的, 我们需要先改变上游发送事件的线程, 让它去子线程中发送事件, 然后再改变下游的线程, 让它去主线程接收事件. 通过RxJava内置的线程调度器可以很轻松的做到这一点. 接下来看一段代码:1234567891011121314151617181920212223242526@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); &#125; &#125;); Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;onNext: &quot; + integer); &#125; &#125;; observable.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(consumer); &#125; 还是刚才的例子, 只不过我们太添加了一点东西, 先来看看运行结果:1234D/TAG: Observable thread is : RxNewThreadScheduler-2 D/TAG: emit 1 D/TAG: Observer thread is :main D/TAG: onNext: 1 可以看到, 上游发送事件的线程的确改变了, 是在一个叫 RxNewThreadScheduler-2的线程中发送的事件, 而下游仍然在主线程中接收事件, 这说明我们的目的达成了, 接下来看看是如何做到的. 和上一段代码相比,这段代码只不过是增加了两行代码:12.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) 作为一个初学者的入门教程, 并不会贴出一大堆源码来分析, 因此只需要让大家记住几个要点, 已达到如何正确的去使用这个目的才是我们的目标. 简单的来说, subscribeOn() 指定的是上游发送事件的线程, observeOn() 指定的是下游接收事件的线程. 多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有第一次的有效, 其余的会被忽略. 多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次. 举个例子:12345observable.subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .observeOn(Schedulers.io()) .subscribe(consumer); 这段代码中指定了两次上游发送事件的线程, 分别是newThread和IO线程, 下游也指定了两次线程,分别是main和IO线程. 运行结果为:1234D/TAG: Observable thread is : RxNewThreadScheduler-3D/TAG: emit 1 D/TAG: Observer thread is :RxCachedThreadScheduler-1D/TAG: onNext: 1 可以看到, 上游虽然指定了两次线程, 但只有第一次指定的有效, 依然是在RxNewThreadScheduler 线程中, 而下游则跑到了RxCachedThreadScheduler 中, 这个CacheThread其实就是IO线程池中的一个. 为了更清晰的看到下游的线程切换过程, 我们加点log:1234567891011121314151617observable.subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;After observeOn(mainThread), current thread is: &quot; + Thread.currentThread().getName()); &#125; &#125;) .observeOn(Schedulers.io()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, &quot;After observeOn(io), current thread is : &quot; + Thread.currentThread().getName()); &#125; &#125;) .subscribe(consumer); 我们在下游线程切换之后, 把当前的线程打印出来, 运行结果:123456D/TAG: Observable thread is : RxNewThreadScheduler-1 D/TAG:emit1 D/TAG: After observeOn(mainThread), current thread is: main D/TAG: After observeOn(io), current thread is : RxCachedThreadScheduler-2 D/TAG: Observer thread is :RxCachedThreadScheduler-2 D/TAG: onNext: 1 可以看到, 每调用一次observeOn() 线程便会切换一次, 因此如果我们有类似的需求时, 便可知道如何处理了. 在RxJava中, 已经内置了很多线程选项供我们选择, 例如有 Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作 Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作 Schedulers.newThread() 代表一个常规的新线程 AndroidSchedulers.mainThread() 代表Android的主线程 这些内置的Scheduler已经足够满足我们开发的需求, 因此我们应该使用内置的这些选项, 在RxJava内部使用的是线程池来维护这些线程, 所有效率也比较高. 实践对于我们Android开发人员来说, 经常会将一些耗时的操作放在后台, 比如网络请求或者读写文件,操作数据库等等,等到操作完成之后回到主线程去更新UI, 有了上面的这些基础, 那么现在我们就可以轻松的去做到这样一些操作. 下面来举几个常用的场景. 网络请求Android中有名的网络请求库就那么几个, Retrofit能够从中脱颖而出很大原因就是因为它支持RxJava的方式来调用, 下面简单讲解一下它的基本用法. 要使用Retrofit,先添加Gradle配置:123456789//retrofitcompile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;//Gson convertercompile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;//RxJava2 Adaptercompile &apos;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&apos;//okhttpcompile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;compile &apos;com.squareup.okhttp3:logging-interceptor:3.4.1&apos; 随后定义Api接口:1234567public interface Api &#123; @GET Observable&lt;LoginResponse&gt; login(@Body LoginRequest request); @GET Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);&#125; 接着创建一个Retrofit客户端:1234567891011121314151617private static Retrofit create() &#123; OkHttpClient.Builder builder = new OkHttpClient().newBuilder(); builder.readTimeout(10, TimeUnit.SECONDS); builder.connectTimeout(9, TimeUnit.SECONDS); if (BuildConfig.DEBUG) &#123; HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(); interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); builder.addInterceptor(interceptor); &#125; return new Retrofit.Builder().baseUrl(ENDPOINT) .client(builder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build();&#125; 发起请求就很简单了:123456789101112131415161718192021Api api = retrofit.create(Api.class);api.login(request) .subscribeOn(Schedulers.io()) //在IO线程进行网络请求 .observeOn(AndroidSchedulers.mainThread()) //回到主线程去处理请求结果 .subscribe(new Observer&lt;LoginResponse&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123;&#125; @Override public void onNext(LoginResponse value) &#123;&#125; @Override public void onError(Throwable e) &#123; Toast.makeText(mContext, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onComplete() &#123; Toast.makeText(mContext, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); 看似很完美, 但我们忽略了一点, 如果在请求的过程中Activity已经退出了, 这个时候如果回到主线程去更新UI, 那么APP肯定就崩溃了, 怎么办呢, 上一节我们说到了Disposable , 说它是个开关, 调用它的dispose()方法时就会切断水管, 使得下游收不到事件, 既然收不到事件, 那么也就不会再去更新UI了. 因此我们可以在Activity中将这个Disposable 保存起来, 当Activity退出时, 切断它即可. 那如果有多个Disposable 该怎么办呢, RxJava中已经内置了一个容器CompositeDisposable, 每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可切断所有的水管. 读写数据库上面说了网络请求的例子, 接下来再看看读写数据库, 读写数据库也算一个耗时的操作, 因此我们也最好放在IO线程里去进行, 这个例子就比较简单, 直接上代码:123456789101112131415161718192021public Observable&lt;List&lt;Record&gt;&gt; readAllRecords() &#123; return Observable.create(new ObservableOnSubscribe&lt;List&lt;Record&gt;&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;List&lt;Record&gt;&gt; emitter) throws Exception &#123; Cursor cursor = null; try &#123; cursor = getReadableDatabase().rawQuery(&quot;select * from &quot; + TABLE_NAME, new String[]&#123;&#125;); List&lt;Record&gt; result = new ArrayList&lt;&gt;(); while (cursor.moveToNext()) &#123; result.add(Db.Record.read(cursor)); &#125; emitter.onNext(result); emitter.onComplete(); &#125; finally &#123; if (cursor != null) &#123; cursor.close(); &#125; &#125; &#125; &#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()); &#125; 好了本次的教程就到这里吧, 后面的教程将会教大家如何使用RxJava中强大的操作符. 通过使用这些操作符可以很轻松的做到各种吊炸天的效果. 敬请期待. 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Vim常用快捷键大全","date":"2017-11-09T08:32:13.000Z","path":"2017/11/09/Vim常用快捷键大全.html","text":"1.1 Vim的几种模式正常模式：可以使用快捷键命令，或按:输入命令行。 插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。 可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式，之后使用 j/k/h/l键可以选中一块 替换模式：正常模式下，按R进入。 2. 启动Vimvim -c cmd file: 在打开文件前，先执行指定的命令； vim -r file: 恢复上次异常退出的文件； vim -R file: 以只读的方式打开文件，但可以强制保存； vim -M file: 以只读的方式打开文件，不可以强制保存； vim -y num file: 将编辑窗口的大小设为num行； vim + file: 从文件的末尾开始； vim +num file: 从第num行开始； vim +/string file: 打开file，并将光标停留在第一个找到的string上。 vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。 ###3. 文档操作 :e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。 :e! file –放弃对当前文件的修改，编辑新的文件。 :e+file – 开始新的文件，并从文件尾开始编辑。 :e+n file – 开始新的文件，并从第n行开始编辑。 :enew –编译一个未命名的新文档。(CTRL-W n) :e – 重新加载当前文档。 :e! – 重新加载当前文档，并丢弃已做的改动。 :e#或ctrl+^ – 回到刚才编辑的文件，很实用。 :f或ctrl+g – 显示文档名，是否修改，和光标位置。 :f filename – 改变编辑的文件名，这时再保存相当于另存为。 gf – 打开以光标所在字符串为文件名的文件。 :w – 保存修改。 :n1,n2w filename – 选择性保存从某n1行到另n2行的内容。 :wq – 保存并退出。 ZZ – 保存并退出。 :x – 保存并退出。 :q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q) :saveas newfilename – 另存为 :browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置： :set browsedir=last – 用上次访问过的目录（默认）； :set browsedir=buffer – 用当前文件所在目录； :set browsedir=current – 用当前工作目录； :Sex – 水平分割一个窗口，浏览文件系统； :Vex – 垂直分割一个窗口，浏览文件系统； ###4. 光标的移动 ####4.1 基本移动 以下移动都是在normal模式下。 h或退格: 左移一个字符； l或空格: 右移一个字符； j: 下移一行； k: 上移一行； gj: 移动到一段内的下一行； gk: 移动到一段内的上一行； +或Enter: 把光标移至下一行第一个非空白字符。 -: 把光标移至上一行第一个非空白字符。 w: 前移一个单词，光标停在下一个单词开头； W: 移动下一个单词开头，但忽略一些标点； e: 前移一个单词，光标停在下一个单词末尾； E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点； b: 后移一个单词，光标停在上一个单词开头； B: 移动到上一个单词开头，忽略一些标点； ge: 后移一个单词，光标停在上一个单词末尾； gE: 同 ge ，不过‘单词’包含单词相邻的标点。 (: 前移1句。 ): 后移1句。 {: 前移1段。 }: 后移1段。 fc: 把光标移到同一行的下一个c字符处 Fc: 把光标移到同一行的上一个c字符处 tc: 把光标移到同一行的下一个c字符前 Tc: 把光标移到同一行的上一个c字符后 ;: 配合f &amp; t使用，重复一次，比如fa后，再; 表示继续fa ,: 配合f &amp; t使用，反向重复一次 上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。 0: 移动到行首。 g0: 移到光标所在屏幕行行首。 ^: 移动到本行第一个非空白字符。 g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。 $: 移动到行尾。 g$: 移动光标所在屏幕行行尾。 n|: 把光标移到递n列上。 nG: 到文件第n行。 :n 移动到第n行。 :$ 移动到最后一行。 H: 把光标移到屏幕最顶端一行。 M: 把光标移到屏幕中间一行。 L: 把光标移到屏幕最底端一行。 gg: 到文件头部。 G: 到文件尾部。 4.2 翻屏ctrl+f: 下翻一屏。 ctrl+b: 上翻一屏。 ctrl+d: 下翻半屏。 ctrl+u: 上翻半屏。 ctrl+e: 向下滚动一行。 ctrl+y: 向上滚动一行。 n%: 到文件n%的位置。 zz: 将当前行移动到屏幕中央。 zt: 将当前行移动到屏幕顶端。 zb: 将当前行移动到屏幕底端。 4.3 标记使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。 m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。 m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。 `{a-z}: 移动到标记位置。 ‘{a-z}: 移动到标记行的行首。 `{0-9}：回到上[2-10]次关闭vim时最后离开的位置。 : 移动到上次编辑的位置。&#39;&#39;也可以，不过精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。 `”: 移动到上次离开的地方。 `.: 移动到最后改动的地方。 :marks 显示所有标记。 :delmarks a b – 删除标记a和b。 :delmarks a-c – 删除标记a、b和c。 :delmarks a c-f – 删除标记a、c、d、e、f。 :delmarks! – 删除当前缓冲区的所有标记。 :help mark-motions 查看更多关于mark的知识。 5. 插入文本5.1 基本插入i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+就插入了36个+组成的分割线。 I: 在当前行第一个非空字符前插入； gI: 在当前行第一列插入； a: 在光标后插入； A: 在当前行最后插入； o: 在下面新建一行插入； O: 在上面新建一行插入； :r filename在当前位置插入另一个文件的内容。 :[n]r filename在第n行插入另一个文件的内容。 :r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。 5.2 改写插入c[n]w: 改写光标后1(n)个词。 c[n]l: 改写光标后n个字母。 c[n]h: 改写光标前n个字母。 [n]cc: 修改当前[n]行。 [n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。 [n]S: 删除指定数目的行，并以所输入文本代替之。 注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。 6. 剪切复制和寄存器6.1 剪切和复制、粘贴[n]x: 剪切光标右边n个字符，相当于d[n]l。 [n]X: 剪切光标左边n个字符，相当于d[n]h。 y: 复制在可视模式下选中的文本。 yy or Y: 复制整行文本。 y[n]w: 复制一(n)个词。 y[n]l: 复制光标右边1(n)个字符。 y[n]h: 复制光标左边1(n)个字符。 y$: 从光标当前位置复制到行尾。 y0: 从光标当前位置复制到行首。 :m,ny 复制m行到n行的内容。 y1G或ygg: 复制光标以上的所有行。 yG: 复制光标以下的所有行。 yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。 d: 删除（剪切）在可视模式下选中的文本。 d$ or D: 删除（剪切）当前位置到行尾的内容。 d[n]w: 删除（剪切）1(n)个单词 d[n]l: 删除（剪切）光标右边1(n)个字符。 d[n]h: 删除（剪切）光标左边1(n)个字符。 d0: 删除（剪切）当前位置到行首的内容 [n] dd: 删除（剪切）1(n)行。 :m,nd 剪切m行到n行的内容。 d1G或dgg: 剪切光标以上的所有行。 dG: 剪切光标以下的所有行。 daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。 dt字符 –删除本行内容，直到遇到第一个指定字符 [不包括该字符] df字符 –删除本行内容，直到遇到第一个指定字符 [包括该字符] p: 在光标之后粘贴。 P: 在光标之前粘贴。 6.2 文本对象 aw：一个词 as：一句。 ap：一段。 ab：一块（包含在圆括号中的）。 y, d, c, v都可以跟文本对象。 6.2 剪切板Vim 有12个粘贴板依次编号为:0,1,2,3,…,9,a,”,+,其中+为系统粘贴板,”为临时粘贴板.系统粘贴板中的内容可在其他程序中使用.上面的复制指令都可以配合剪切板进行操作. “nyw 复制当前单词到 n 号剪切板(双引号开始)“np 粘贴 n 好剪切板的内容到当前位置后“Y 复制当前行到系统剪切板“ny 复制当前行加下面 n 行到系统剪切板“p 粘贴系统剪切板内容到当前位置后 6.3 寄存器a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。 A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。 :reg 显示所有寄存器的内容。 “”：不加寄存器索引时，默认使用的寄存器。 “：当前选择缓冲区，”yy把当前行的内容放入当前选择缓冲区。 “+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。 7. 查找与替换7.1 查找/something: 在后面的文本中查找something。 ?something: 在前面的文本中查找something。 /pattern/+number: 将光标停在包含pattern的行后面第number行上。 /pattern/-number: 将光标停在包含pattern的行前面第number行上。 n: 向后查找下一个。 N: 向前查找下一个。 可以用grep或vimgrep查找一个模式都在哪些地方出现过， 其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。 用法为： :vim[grep]/pattern/[g] [j] files g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。 j的含义是grep结束后，结果停在第j项，默认是停在第一项。 vimgrep前面可以加数字限定搜索结果的上限，如 :1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。 其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。 比如电子书中每一节的标题形式为：n. xxxx。你就可以这样： :vim/^d{1,}./ % 然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧， 就更像个目录了。 7.2 替换:s/old/new - 用new替换当前行第一个old。 :s/old/new/g - 用new替换当前行所有的old。 :n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。 :%s/old/new/g - 用new替换文件中所有的old。 :%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。 :%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。 所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。 还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令， 语法为 :[range]g/pattern/command 例如 :%g/^ xyz/normal dd。 表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。 关于range的规定为： 如果不指定range，则表示当前行。 m,n: 从m行到n行。 0: 最开始一行（可能是这样）。 $: 最后一行 .: 当前行 %: 所有行 7.3 正则表达式高级的查找替换就要用到正则表达式。 \\d: 表示十进制数（我猜的） \\s: 表示空格 \\S: 非空字符 \\a: 英文字母 |: 表示 或 .: 表示. {m,n}: 表示m到n个字符。这要和 \\s与\\a等连用，如 \\a{m,n} 表示m 到n个英文字母。 {m,}: 表示m到无限多个字符。 **: 当前目录下的所有子目录。 :help pattern得到更多帮助。 8. 排版8.1 基本排版&lt;&lt; 向左缩进一个shiftwidth 向右缩进一个shiftwidth :ce(nter) 本行文字居中 :le(ft) 本行文字靠左 :ri(ght) 本行文字靠右 gq 对选中的文字重排，即对过长的文字进行断行 gqq 重排当前行 gqnq 重排n行 gqap 重排当前段 gqnap 重排n段 gqnj 重排当前行和下面n行 gqQ 重排当前段对文章末尾 J 拼接当前行和下一行 gJ 同 J ，不过合并后不留空格。 8.2 拼写检查:set spell－开启拼写检查功能 :set nospell－关闭拼写检查功能 ]s－移到下一个拼写错误的单词 [s－作用与上一命令类似，但它是从相反方向进行搜索 z=－显示一个有关拼写错误单词的列表，可从中选择 zg－告诉拼写检查器该单词是拼写正确的 zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的 8.3 统计字数g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。 9. 编辑多个文件9.1 一次编辑多个文件我们可以一次打开多个文件，如 vi a.txt b.txt c.txt 使用:next(:n)编辑下一个文件。 :2n 编辑下2个文件。 使用:previous或:N编辑上一个文件。 使用:wnext，保存当前文件，并编辑下一个文件。 使用:wprevious，保存当前文件，并编辑上一个文件。 使用:args 显示文件列表。 :n filenames或:args filenames 指定新的文件列表。 vi -o filenames 在水平分割的多个窗口中编辑多个文件。 vi -O filenames 在垂直分割的多个窗口中编辑多个文件。 9.2 多标签编辑vim -p files: 打开多个文件，每个文件占用一个标签页。 :tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。 ^w gf – 在新的标签页里打开光标下路径指定的文件。 :tabn – 切换到下一个标签。Control + PageDown，也可以。 :tabp – 切换到上一个标签。Control + PageUp，也可以。 [n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。 gT–切换到上一个。 :tab split – 将当前缓冲区的内容在新页签中打开。 :tabc[lose] – 关闭当前的标签页。 :tabo[nly] – 关闭其它的标签页。 :tabs – 列出所有的标签页和它们包含的窗口。 :tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。 9.3 缓冲区:buffers或:ls或:files 显示缓冲区列表。 ctrl+^：在最近两个缓冲区间切换。 :bn – 下一个缓冲区。 :bp – 上一个缓冲区。 :bl – 最后一个缓冲区。 :b[n]或:[n]b – 切换到第n个缓冲区。 :nbw(ipeout) – 彻底删除第n个缓冲区。 :nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。 :ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。 10. 分屏编辑vim -o file1 file2:水平分割窗口，同时打开file1和file2 vim -O file1 file2:垂直分割窗口，同时打开file1和file2 10.1 水平分割:split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。 让水平分割窗口同时滚动，在两个窗口中输入 ：set scb :split filename – 水平分割窗口，并在新窗口中显示另一个文件。 :nsplit(:nsp) – 水平分割出一个n行高的窗口。 :[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N) ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。 C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。 10.2 垂直分割:vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V) :[N]vne[w] – 垂直分割出一个新窗口。 :vertical 水平分割的命令： 相应的垂直分割。 10.3 关闭子窗口:qall – 关闭所有窗口，退出vim。 :wall – 保存所有修改过的窗口。 :only – 只保留当前窗口，关闭其它窗口。(CTRL-W o) :close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 ) 10.4 调整窗口大小ctrl+w + –当前窗口增高一行。也可以用n增高n行。 ctrl+w - –当前窗口减小一行。也可以用n减小n行。 ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。 :resize n – 当前窗口n行高。 ctrl+w = – 所有窗口同样高度。 n ctrl+w _ – 当前窗口的高度设定为n行。 ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。 ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。 ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。 10.5 切换和移动窗口如果支持鼠标，切换和调整子窗口的大小就简单了。 ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。 ctrl+w p: 切换到前一个窗口。 ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。 ctrl+w t(b):切换到最上（下）面的窗口。 ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。 ctrl+w r：旋转窗口的位置。 ctrl+w T: 将当前的窗口移动到新的标签页上。 11. 快速编辑11.1 改变大小写~: 反转光标所在字符的大小写。 可视模式下的U或u：把选中的文本变为大写或小写。 gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。 11.2 替换（normal模式）r: 替换光标处的字符，同样支持汉字。 R: 进入替换模式，按esc回到正常模式。 11.3 撤消与重做（normal模式）[n] u: 取消一(n)个改动。 :undo 5 – 撤销5个改变。 :undolist – 你的撤销历史。 ctrl + r: 重做最后的改动。 U: 取消当前行中所有的改动。 :earlier 4m – 回到4分钟前 :later 55s – 11.4 宏. –重复上一个编辑动作 qa：开始录制宏a（键盘操作记录） q：停止录制 @a：播放宏a 12. 编辑特殊文件12.1 文件加解密vim -x file: 开始编辑一个加密的文件。 :X – 为当前文件设置密码。 :set key= – 去除文件的密码。 这里是 滇狐总结的比较高级的vi技巧。 12.2 文件的编码:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。 :w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。 :set fenc或:set fileencoding，查看当前文件的编码。 在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。 让vim 正确处理文件格式和文件编码，有赖于 ~/.vimrc的正确配置 12.3 文件格式大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。 :e ++ff=dos filename, 让vim用dos格式打开这个文件。 :w ++ff=mac filename, 以mac格式存储这个文件。 :set ff，显示当前文件的格式。 在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。 13. 编程辅助13.1 一些按键gd: 跳转到局部变量的定义处； gD: 跳转到全局变量的定义处，从当前文件开头开始搜索； g;: 上一个修改过的地方； g,: 下一个修改过的地方； [[: 跳转到上一个函数块开始，需要有单独一行的{。 ]]: 跳转到下一个函数块开始，需要有单独一行的{。 []: 跳转到上一个函数块结束，需要有单独一行的}。 ][: 跳转到下一个函数块结束，需要有单独一行的}。 [{: 跳转到当前块开始处； ]}: 跳转到当前块结束处； [/: 跳转到当前注释块开始处； ]/: 跳转到当前注释块结束处； %: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。 下面的括号匹配对编程很实用的。 ci’, di’, yi’：修改、剪切或复制’之间的内容。 ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。 ci”, di”, yi”：修改、剪切或复制”之间的内容。 ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。 ci(, di(, yi(：修改、剪切或复制()之间的内容。 ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。 ci[, di[, yi[：修改、剪切或复制[]之间的内容。 ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。 ci{, di{, yi{：修改、剪切或复制{}之间的内容。 ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。 ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。 ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。 13.2 ctagsctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags :set tags=path/tags – 告诉ctags使用哪个tag文件 :tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t :stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口 :ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。 :pclose – 关闭预览窗口。热键是C-w z。 :pedit abc.h – 在预览窗口中编辑abc.h :psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。 有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。 :[n]tnext – 下一[n]个匹配。 :[n]tprev – 上一[n]个匹配。 :tfirst – 第一个匹配 :tlast – 最后一个匹配 :tselect tagname – 打开选择列表 tab键补齐 :tag xyz – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。 :tag /xyz – 会用名字中含有xyz的tag名补全。 13.3 cscopecscope -Rbq: 生成cscope.out文件 :cs add /path/to/cscope.out /your/work/dir :cs find c func – 查找func在哪些地方被调用 :cw – 打开quickfix窗口查看结果 13.4 gtagsGtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。 :Gtags funcname 定位到 funcname 的定义处。 :Gtags -r funcname 查询 funcname被引用的地方。 :Gtags -s symbol 定位 symbol 出现的地方。 :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。 :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。 :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。 13.5 编译vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。 如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.Java文件，你可以这样设置： set makeprg=javac\\ abc.java然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如： :setl efm=%A%f:%l:\\ %m,%-Z%p^,%-C%.%#%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。 13.6 快速修改窗口其实是quickfix插件提供的功能， 对编译调试程序非常有用 :) :copen – 打开快速修改窗口。 :cclose – 关闭快速修改窗口。快速修改窗口在make程序时非常有用，当make之后： :cl – 在快速修改窗口中列出错误。 :cn – 定位到下一个错误。 :cp – 定位到上一个错误。 :cr – 定位到第一个错误。 13.7 自动补全C-x C-s – 拼写建议。 C-x C-v – 补全vim选项和命令。 C-x C-l – 整行补全。 C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。 C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。 C-x C-o – 编程时可以补全关键字和函数名啊。 C-x C-i – 根据头文件内关键字补全。 C-x C-d – 补全宏定义。 C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。当弹出补全菜单后： C-p 向前切换成员； C-n 向后切换成员； C-e 退出下拉菜单，并退回到原来录入的文字； C-y 退出下拉菜单，并接受当前选项。 13.8 多行缩进缩出正常模式下，按两下&gt;;光标所在行会缩进。 如果先按了n，再按两下&gt;;，光标以下的n行会缩进。 对应的，按两下&lt;;，光标所在行会缩出。 如果在编辑代码文件，可以用=进行调整。 在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。 或者n =，调整n行代码的缩排。 13.9 折叠zf – 创建折叠的命令，可以在一个可视区域上使用该命令； zd – 删除当前行的折叠； zD – 删除当前行的折叠； zfap – 折叠光标所在的段； zo – 打开折叠的文本； zc – 收起折叠； za – 打开/关闭当前折叠； zr – 打开嵌套的折行； zm – 收起嵌套的折行； zR (zO) – 打开所有折行； zM (zC) – 收起所有折行； zj – 跳到下一个折叠处； zk – 跳到上一个折叠处； zi – enable/disable fold; 14. 命令行normal模式下按:进入命令行模式 14.1 命令行模式下的快捷键：上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。 左右方向键：左/右移一个字符。 C-w： 向前删除一个单词。 C-h： 向前删除一个字符，等同于Backspace。 C-u： 从当前位置移动到命令行开头。 C-b： 移动到命令行开头。 C-e： 移动到命令行末尾。 Shift-Left： 左移一个单词。 Shift-Right： 右移一个单词。 @： 重复上一次的冒号命令。 q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。 q/和q? 可以打开查找历史记录。 14.2 执行外部命令:! cmd 执行外部命令。 :!! 执行上一次的外部命令。 :sh 调用shell，用exit返回vim。 :r !cmd 将命令的返回结果插入文件当前位置。 :m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。 15. 其它15.1 工作目录:pwd 显示vim的工作目录。 :cd path 改变vim的工作目录。 :set autochdir 可以让vim 15.2 一些快捷键（收集中）K: 打开光标所在词的manpage。 *: 向下查找光标所在词。 #：向上查找 g*: 同上，但部分符合即可。 #: 向上搜索光标所在词。 g#: 同上，但部分符合即可。 g C-g: 统计全文或统计部分的字数。 15.3 在线帮助:h(elp)或F1 打开总的帮助。 :help user-manual 打开用户手册。 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。 :helptags somepath 为somepath中的文档生成索引。 :helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。 Ctrl+] 跳转到tag主题，Ctrl+t 跳回。 :ver 显示版本信息。 15.4 一些小功能简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Vim","slug":"Vim","permalink":"https://github.com/itgoyo/tags/Vim/"}]},{"title":"Mac系统好用的软件推荐","date":"2017-11-08T10:02:07.000Z","path":"2017/11/08/Mac系统好用的软件推荐.html","text":"MacApp文章应用参考xclient官网，做出整理。 1.1 热门应用 评分 名称 功能简述 官网 破解版 ★★★★★ Sketch 轻量易用的矢量设计工具 官网 地址 ★★★★★ Microsoft Office 最好用的办公软件 官网 地址 ★★★★★ Navicat Premium 强大的数据库管理工具 官网 地址 ★★★★★ Adobe Photoshop 最强大的设计软件 官网 地址 ★★★★★ Charles 强大的抓包工具 官网 地址 ★★★★★ Alfred 效率神器 官网 地址 ★★★★★ Dash 开发者必备API文档聚合 官网 地址 ★★★★★ Parallels Desktop 最佳Mac虚拟机解决方案 官网 地址 ★★★★★ PDF Expert 极致的PDF阅读标注工作体验 官网 地址 ★★★★★ MindNode Pro 思维导图工具 官网 地址 ★★★★★ Sublime Text 3 强大的文本编辑器 官网 地址 ★★★★★ VMware Fusion 强大的虚拟机应用 官网 地址 ★★★★★ Downie 视频下载工具 官网 地址 ★★★★★ WebStorm Web前端开发神器 官网 地址 ★★★★★ OmniGraffle Pro 强大的图形工具 官网 地址 ★★★★★ SecureCRT 一款终端仿真程序 官网 地址 ★★★★★ iStat Menus 优秀的系统监控工具 官网 地址 ★★★★★ Principle Mac平台交互动效设计神器 官网 地址 ★★★★★ BetterZip 快速的压缩工具 官网 地址 ★★★★★ Axure RP 专业的快速原型设计工具 官网 地址 ★★★★★ Cornerstone 应该说是mac上最好用的SVN客户端 官网 地址 ★★★★★ Final Cut Pro 专业级视频剪辑软件 官网 地址 ★★★★★ Adobe Illustrator CC 一款非常好的矢量图形处理工具 官网 地址 ★★★★★ iMazing 在Mac上管理iPhone如此简单 官网 地址 ★★★★★ Bartender 一款实用的菜单栏管理工具 官网 地址 ★★★★★ Flinto 交互式设计神器 官网 地址 ★★★★★ Ulysses 强大的文本编辑器 官网 地址 ★★★★★ IntelliJ IDEA 业界公认的最好的java开发工具之一 官网 地址 ★★★★★ Shimo 最先进的VPN客户端 官网 地址 ★★★★★ Airmail 最强mac邮件客户端 官网 地址 ★★★★★ PyCharm 强大的Python IDE工具 官网 地址 ★★★★★ 1Password 密码管理工具 App名人堂产品 官网 地址 ★★★★★ MWeb 专业的Markdown写作、静态博客生成软件 官网 地址 ★★★★★ Transmit 一款功能齐全的FTP客户端 官网 地址 ★★★★★ BetterTouchTool 把触控板的潜力发挥到淋漓尽致 官网 地址 ★★★★★ Folx Pro Mac上公认最好的下载工具 官网 地址 ★★★★★ Fantastical 优雅的日历软件 官网 地址 ★★★★★ OmniFocus 强大的任务管理软件 官网 地址 ★★★★★ Movist 一款CPU占用率低的高清多格式媒体播放器 官网 地址 ★★★★★ CrossOver 在你的mac上运行window应用 官网 地址 ★★★★★ OmniPlan 最NB的项目管理流程软件 官网 地址 ★★★★★ Paw 3.1.5 实用的HTTP/REST服务测试工具 官网 地址 ★★★★★ Archiver 一款功能齐全的压缩解压工具 官网 地址 ★★★★★ Tower mac平台最强大的Git 客户端 官网 地址 ★★★★★ Adobe Acrobat Pro 强大的PDF编辑软件 官网 地址 ★★★★★ Adobe After Effects 一款强大的图形视频处理软件 官网 地址 ★★★★★ Day One 生活记录伴侣 官网 地址 ★★★★★ Framer 移动交互原型设计工具 官网 地址 ★★★★★ MAMP Pro 集成web服务器环境 官网 地址 ★★★★★ Civilization VI（文明6） 一款回合制策略游戏 官网 地址 评分说明： 评分 推荐度 ★★★★★ 必装神器 ★★★★☆ 十分出色 ★★★★ 值得购入 ★★★☆ 亮点突出 ★★★ 同类出众 请我吃颗糖 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Mac","slug":"Mac","permalink":"https://github.com/itgoyo/tags/Mac/"}]},{"title":"凭什么我要给你钱","date":"2017-11-07T00:14:49.000Z","path":"2017/11/07/凭什么我要给你钱.html","text":"昨晚在下班回家，走到小区前面的一家超市面前的时候，突然有一位中年妇女，走过来问了声，”你好，你可以帮我买瓶水，或者买点吃的吗？”那会我没怎么听清楚，反问到”什么？”，她又说到”可以帮我买点吃的，或者到超市给我买瓶水么？”，我心中一疑，仔细观察了这位中年妇女的穿着，干干净净的，然后微笑对她说了句，”对不起，不能”，然后转身就走，在我转身离开的那一刻，我听到，她很大声的骂了一句”我靠”，还有一些呢喃听得不怎么清楚。我觉得很奇怪，凭什么我要给你买东西，为什么我不给你买，你就骂人。首先，我没有必须给你钱的义务，其次，你什么都不说清楚，就径直地过来问我替你买东西，我怎么知道你是不是在骗我，最后，庆幸自己没有爱心泛滥，因为没有帮她买之后，她的表现真的让人无语。当年我快上大学的时候，我和我爸爸走到南宁火车站附近的时候，就看到有一个年轻的妈妈背着她的娃跪在路边，摆了一张纸，上面写到什么因为没钱回家什么的，所以求助好心人，我爸爸当初觉得挺可怜的，就给了20块钱，然而那个女的就一直保持跪着，连一声谢谢都没有，总觉得自己本该被捐助一样。我们转身走开之后那女的还一直跪在那里，在我爸爸买水的时候就问了一下那个店员，那个女的跪在这里多久了，那店员就说，不用理她，就是一个骗子而已，每天都会在哪里跪着骗钱，那会我爸爸才知道被骗了。其实我觉得那20块钱不亏，买到了一些经验，就是不要爱心泛滥。我就觉得很奇怪，总是有人起哄逼捐，类似马云被逼捐这种。凭什么有钱就要捐？如果说到捐，为什么你们不捐，反而要别人捐，很多时候这种人就是见不得别人过得比他好，认为我没有的，别人就要分享给他，这无疑也是一种国民的劣根性，或者说是人的劣根性。这个世界是公平的，你想拿到什么样的东西，就要付出同等价值的东西去交换，而不是在哪里期待着别人会给你无私的捐赠。—发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://github.com/itgoyo/tags/生活随笔/"}]},{"title":"Putty+Xming在Windows端显示Linux图形化界面GUI","date":"2017-11-06T01:19:04.000Z","path":"2017/11/06/Putty-Xming在Windows端显示Linux图形化界面GUI.html","text":"一、Linux配置#apt-get install openssh-server 二、Windows下载并安装Xming客户端http://sourceforge.net/projects/xming 完了之后出现sshd的字样表明服务器开启成功。 安装并启动， 无需配置下载并安装puttyhttp://the.earth.li/~sgtatham/putty/latest/x86/putty.exe 三、配置Putty首先获取Linux服务器的ip地址在终端输入: ifconfig 即可查看。 填写配置信息 Putty中开启X11支持 Linux里边的ssh文件配置也要打开 要允许Linux主机上的SSH X转发，查看 /etc/ssh/sshd_config 文件，加入以下一行， X11Forwrding yes 到此配置就结束了，想要测试是否成功的话，可以在终端输入:xclock 如果出现一个悬浮的时钟则表明配置成功了，或者你可以打开Linux上面的一张图片如果显示也代表成功了，命令如下 eog xxx.jpg 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/itgoyo/tags/Linux/"}]},{"title":"Oh-My-Zsh","date":"2017-11-03T09:02:15.000Z","path":"2017/11/03/Oh-My-Zsh.html","text":"oh my zsh curl or wget should be installed git should be installed Basic InstallationOh My Zsh is installed by running one of the following commands in your terminal. You can install this via the command-line with either curl or wget. via curl sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; via wget sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;1 PluginsOnce you spot a plugin (or several) that you’d like to use with Oh My Zsh, you’ll need to enable them in the .zshrc file. You’ll find the zshrc file in your $HOME directory. Open it with your favorite text editor and you’ll see a spot to list all the plugins you want to load. For example, this line might begin to look like this: plugins=(git bundler osx rake ruby) ThemesRobby’s theme is the default one. It’s not the fanciest one. It’s not the simplest one. It’s just the right one (for him). Once you find a theme that you want to use, you will need to edit the ~/.zshrc file. You’ll see an environment variable (all caps) in there that looks like: ZSH_THEME=&quot;robbyrussell&quot; To use a different theme, simply change the value to match the name of your desired theme. For example: 123ZSH_THEME=&quot;agnoster&quot; # (this is one of the fancy ones)# you might need to install a special Powerline font on your console&apos;s host for this to work# see https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#agnoster 出现乱码解决方式1234567执行以下命令来安装缺失的字体：wget https://raw.githubusercontent.com/powerline/powerline/develop/font/10-powerline-symbols.confwget https://raw.githubusercontent.com/powerline/powerline/develop/font/PowerlineSymbols.otfsudo mkdir /usr/share/fonts/OTFsudo cp 10-powerline-symbols.conf /usr/share/fonts/OTF/sudo mv 10-powerline-symbols.conf /etc/fonts/conf.d/sudo mv PowerlineSymbols.otf /usr/share/fonts/OTF/ Open up a new terminal window and your prompt should look something like this: In case you did not find a suitable theme for your needs, please have a look at the wiki for more of them. If you’re feeling feisty, you can let the computer select one randomly for you each time you open a new terminal window. ZSH_THEME=&quot;random&quot; # (...please let it be pie... please be some pie..) 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Program","slug":"Program","permalink":"https://github.com/itgoyo/tags/Program/"}]},{"title":"Vim的安装与使用","date":"2017-11-03T08:55:29.000Z","path":"2017/11/03/Vim的安装与使用.html","text":"VimVim的配置以spf-13为例子项目地址: https://github.com/spf13/spf13-vim Vim的安装 Linux, *nix, Mac OSX Installation The easiest way to install spf13-vim is to use our automatic installer by simply copying and pasting the following line into a terminal. This will install spf13-vim and backup your existing vim configuration. If you are upgrading from a prior version (before 3.0) this is also the recommended installation. Requires Git 1.7+ and Vim 7.3+ 1curl https://j.mp/spf13-vim3 -L &gt; spf13-vim.sh &amp;&amp; sh spf13-vim.sh If you have a bash-compatible shell you can run the script directly:1sh &lt;(curl https://j.mp/spf13-vim3 -L) 此过程会比较长，包括插件的下载还有安装，这个过程将近1个多小时 Installing on Windows On Windows and *nix Git and Curl are required. Also, if you haven’t done so already, you’ll need to install Vim. The quickest option to install all three dependencies (Git, Curl, Vim and spf13-vim) is via Chocolatey NuGet. After installing Chocolatey, execute the following commands on the command prompt: Install with cmd.exe(run as admin mode)1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; 1C:\\&gt; choco install spf13-vim 一直Y，整个过程大概2h左右 Vim插件的介绍 Vundle(The best plugin manager) Vundle is an excellent system built on the same principles as Pathogen, but with an integrated plugin management system that is Git and Github aware. spf13-vim uses the Vundle plugin management system to have a well organized vim directory (Similar to mac’s app folders). Vundle also ensures that the latest versions of your plugins are installed and makes it easy to keep them up to date. NERDTree(file navigation) NERDTree is a file explorer plugin that provides “project drawer” functionality to your vim editing. You can learn more about it with :help NERDTree or checkout my post on NERDTree. Use Ctrl+e to toggle NERDTree ctrlp(fast file finder) Ctrlp replaces the Command-T plugin with a 100% viml plugin. It provides an intuitive and fast mechanism to load files from the file system (with regex and fuzzy find), from open buffers, and from recently used files. Use Ctrl+p to toggle Ctrlp neocomplcache(autocomplete++) NeoComplCache is an amazing autocomplete plugin with additional support for snippets. It can complete simulatiously from the dictionary, buffer, omnicomplete and snippets. This is the one true plugin that brings Vim autocomplete on par with the best editors. Use Ctrl+n to toggle neocomplcache Tagbar(tag generation and navigation) spf13-vim includes the Tagbar plugin. This plugin requires exuberant-ctags and will automatically generate tags for your open files. It also provides a panel to navigate easily via tags Use ,tt to toggle neocomplcache 关于在Mac端ctags无效的解决方法https://brew.sh/ https://github.com/universal-ctags/ctags https://github.com/universal-ctags/homebrew-universal-ctags 在Windows端，如果想切换到别的盘符进行操作的话,使用 :NERDTree D:\\\\ 进行目录的跳转 Preview: To preview markdown format you need to install bluecloth gem在使用previewMarkdown的时候出现了Preview: To preview markdown format you need to install bluecloth gem 解决方法： sudo gem install redcarpet sudo gem install bluecloth Linux出现的问题can’t find header files for ruby at /usr/lib/ruby/include/ruby.h 解决方法:sudo apt-get install ruby-dev 提示找不到tag文件123456789101112131415用法: 1.生成标签文件(cmd到项目的目录中执行) 在当前目录下(运行$提示符后面的命令): $ctags -R . -R表示recursive，递归,为当前目录及其子目录中的c文件生成标签文件。最后一个.表示在当前目录。 运行完当前目录会多一个文件tags,就是c标签的索引文件。 2.跳转 1)用vim打开一个已经建过标签的c文件 2)ctrl+] 找到光标所在位置的标签定义的地方 3)ctrl+t 回到跳转之前的标签处 3.窗口显示方法 命令Tagbar toggle打开相应的方法窗口显示 注意：此时运行vim，必须在&quot;tags&quot;文件所在的目录下运行。否则，运行它会找不到&quot;tags&quot;文件，而需要在vim中用&quot;:set tags=&quot;命令设定&quot;tags&quot;文件的路径。对于一个稍微大点的项目，你可能在任何一个目录下打开vim，然而在每个目录下都生成一个tags文件并不 是个好主意，那么如何解决呢？方法是在.vimrc中增加一行： set tags=tags;/ 这是告诉vim在当前目录找不到tags文件时请到上层目录查找。 窗口切换快捷键Ctrl+w+w 关闭分屏1234关闭当前窗口。Ctrl+W c关闭当前窗口，如果只剩最后一个了，则退出Vim。Ctrl+W q 打开多个窗口了之后，怎么快速切换:buffers 列表 :bn下一个 :bp 上一个 :b17 取消查找遗留的边框1set: nohlseach 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Vim","slug":"Vim","permalink":"https://github.com/itgoyo/tags/Vim/"}]},{"title":"Java多态的理解","date":"2017-10-27T06:56:56.000Z","path":"2017/10/27/Java多态的理解.html","text":"文章是参照博客园的一篇文章博文链接来做的笔记。 什么是多态？多态是同一个行为具有多个不同表现形式或形态的能力。菜鸟教程 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示： 多态性是对象多种表现形式的体现。 现实中，比如我们按下 F1 键这个动作： 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档； 如果当前在 Word 下弹出的就是 Word 帮助； 在 Windows 下弹出的就是 Windows 帮助和支持。 同一个事件发生在不同的对象上会产生不同的结果。 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字super。 简单的Demo123456789101112131415161718class A ...&#123; public String show(D obj)...&#123; return (&quot;A and D&quot;); &#125; public String show(A obj)...&#123; return (&quot;A and A&quot;); &#125; &#125; class B extends A...&#123; public String show(B obj)...&#123; return (&quot;B and B&quot;); &#125; public String show(A obj)...&#123; return (&quot;B and A&quot;); &#125; &#125; class C extends B...&#123;&#125; class D extends B...&#123;&#125; 问题：以下输出结果是什么？1234567891011121314A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(a1.show(b)); ① System.out.println(a1.show(c)); ② System.out.println(a1.show(d)); ③ System.out.println(a2.show(b)); ④ System.out.println(a2.show(c)); ⑤ System.out.println(a2.show(d)); ⑥ System.out.println(b.show(b)); ⑦ System.out.println(b.show(c)); ⑧ System.out.println(b.show(d)); ⑨ 答案123456789① A and A② A and A③ A and D④ B and A⑤ B and A⑥ A and D⑦ B and B⑧ B and B⑨ A and D 答案解析123456781.实例对象为A，参数为对象B，B为A的子类。执行A.class中show(A obj)2.同上3.实例对象为A，参数为对象D，执行A.class中show(D obj)4.实例对象依然为A，参数为B，本应执行A.class中show(A obj)，但是，B.class重写了show(A obj),所以执行B.class show(A obj)5.同上6.执行A.class show(D obj) B中并没有重写。7，8.实例对象为B，参数为B或者B的子类，执行show(B obj)9.实例对象为B，参数为D，因为B继承自A，也可以执行A中的show(D obj) 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Program","slug":"Program","permalink":"https://github.com/itgoyo/tags/Program/"},{"name":"Java","slug":"Java","permalink":"https://github.com/itgoyo/tags/Java/"}]},{"title":"解决Alfred每次都访问通讯录的问题","date":"2017-10-22T05:30:02.000Z","path":"2017/10/22/解决Alfred每次都访问通讯录的问题.html","text":"解决方法打开终端或者iterm2，输入1sudo codesign -f -d -s - /Applications/Alfred\\ 3.app/Contents/Frameworks/Alfred\\ Framework.framework/Versions/A/Alfred\\ Framework 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Mac","slug":"Mac","permalink":"https://github.com/itgoyo/tags/Mac/"}]},{"title":"常用的Markdown编辑器推荐","date":"2017-10-15T03:43:47.000Z","path":"2017/10/15/常用的Markdown编辑器推荐.html","text":"欢迎关注本人Gtihub:itgoyo MarkdownPad官网 Windows Cmd Markdown官网 Windows Linux Web Dillinger官网 Web MaHua官网 Web 马克飞象官网 Web 小书匠编辑器官网 Mac Windows Linux Web SublimeText官网 Mac Windows Linux Atom官网 Mac Windows Linux Smark官网 Windows Linux MdCharm官网 Windows Linux Miu官网 Windows GitBook Editor官网 Mac Windows Linux Mou官网 Mac Typora官网 Mac Byword官网 Mac Ulysses官网 Mac Typed官网 Mac Editor.md官网 Mac Windows Web 发现更多有趣的好玩的，欢迎关注我的公众号：toolpool 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"},{"name":"Markdown","slug":"Markdown","permalink":"https://github.com/itgoyo/tags/Markdown/"}]},{"title":"SublimeText3怎么修改侧边栏的颜色和内容一致","date":"2017-09-03T02:04:58.000Z","path":"2017/09/03/Text3怎么修改侧边栏的颜色和内容一致.html","text":"sublime text3刚安装完成之后打开文件夹显示的样式如下 这样子看起来眼睛会很难受,那么我们怎样才能使得引导菜单的颜色和编辑器底色一样呢? 解决方法如下: Ctrl+Shift+P -&gt; install -&gt; 搜索安装包SyncedSidebarBg，自动同步侧边栏底色为编辑窗口底色。PS：有时改完后侧边栏颜色没变化，不知什么原因，打开包控制，然后列一下已安装包就刷新了。 安装完成之后,效果是这样子的: 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Program","slug":"Program","permalink":"https://github.com/itgoyo/tags/Program/"}]},{"title":"Ubuntu扁平化主题Flatabulous安装教程","date":"2017-09-03T01:25:48.000Z","path":"2017/09/03/Ubuntu扁平化主题Flatabulous安装教程.html","text":"不知道大家对Ubuntu自带的主题效果怎么看，反正我自己觉得自带的主题看起来挺难受的，所以网上找了许多法子，终于把主题美化成自己喜欢的样子。 Flatabulous: 一个超好看的扁平化 Ubuntu 桌面主题 安装此主题步骤： 一、TweeakTool123sudo add-apt-repository ppa:tualatrix/ppa sudo apt-get updatesudo apt-get install ubuntu-tweak 该工具是用来设置各种Ubuntu偏好使用的 二、安装Flatabulous下载地址或者直接在Github上 Clone下来1https://github.com/anmoljagetia/Flatabulous 把下载下来的zip包解压，移动到/usr/share/themes/下 1sudo mv Flatabulous-master /usr/share/themes/ 三、安装扁平化图标ultra-flat-icons123sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 或者到http://ppa.launchpad.net/noobslab/icons/ubuntu/pool/main/u/ultra-flat-icons/自己下载安装 注意，在Ubuntu15.04会提示找不到ultra-flat-icons这个包解决方法：在软件和更新中把ultra-flat-icons源中的vivid改成trusty，即可安装成功，最后记得改回来过 或者你也可以运行sudo apt-get install ultra-flat-icons-orange或者 sudo apt-get install ultra-flat-icons-green 根据你自己喜欢的颜色选择。 最后完成以上设置的效果图 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/itgoyo/tags/Linux/"}]},{"title":"决策","date":"2017-09-02T12:16:15.000Z","path":"2017/09/02/决策.html","text":"什么是我们一生中耗时最多、最让人纠结的事?是做出大大小小的决策。 我们的生活无时无刻的都充满了各种决策，比如午餐我要吃什么，到了商场我要买什么，今天衣服穿什么等等。 我们时常陷入个人主观感情或者是非理性感情中做出错误的决定，以致于做出让我们后悔终生的判断。 有一个很有趣的问题“扎克伯格为什么总是穿同一件衣服？” 其实扎克伯格的衣柜里的衣服是这样子的 而扎克伯格自己的回答则是 “我想通过清空我的生活来让我在除了如何更好服务社会这件事情以外的任何事情上都做尽可能少的决策。” 作为一个富豪，扎克伯格不是为了有趣才每天穿同一款式的衣服，他这样做确实是行之有效,每一个决定都会减少我们的意志力“血槽”。每一个决定都会让我们少一丝创造力、控制力和专注力。 引用一位名人的话 “我们必须尽早将尽可能多且有用的行动变成我们自发的和习以为常的决策……我们通过毫不费力的下意识行为解决的日常细节越多，我们就能解放越多应该用来处理高级事务的精神意志力。”——威廉·詹姆斯 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://github.com/itgoyo/tags/生活随笔/"}]},{"title":"Android开发工具大全","date":"2017-07-29T06:35:32.000Z","path":"2017/07/29/Android开发工具大全.html","text":"AndroidDevTools Android Dev Tools官网地址：www.androiddevtools.cn 收集整理Android开发所需的Android SDK、开发中用到的工具、Android开发教程、Android设计规范，免费的设计素材等。 欢迎大家推荐自己在Android开发过程中用的好用的工具、学习开发教程、用到设计素材，欢迎Star、Fork 😄。 Android Tools Android SDK在线更新镜像服务器 中国科学院开源协会镜像站地址: IPV4/IPV6: mirrors.opencas.cn 端口：80 IPV4/IPV6: mirrors.opencas.org 端口：80 IPV4/IPV6: mirrors.opencas.ac.cn 端口：80 上海GDG镜像服务器地址: sdk.gdgshanghai.com 端口：8000 北京化工大学镜像服务器地址: IPv4: ubuntu.buct.edu.cn/ 端口：80 IPv4: ubuntu.buct.cn/ 端口：80 IPv6: ubuntu.buct6.edu.cn/ 端口：80 大连东软信息学院镜像服务器地址: mirrors.neusoft.edu.cn 端口：80 腾讯Bugly 镜像: android-mirror.bugly.qq.com 端口：8080 腾讯镜像使用方法: http://android-mirror.bugly.qq.com:8080/include/usage.html 使用方法： 启动 Android SDK Manager ，打开主界面，依次选择『Tools』、『Options…』，弹出『Android SDK Manager - Settings』窗口； 在『Android SDK Manager - Settings』窗口中，在『HTTP Proxy Server」和「HTTP Proxy Port』输入框内填入上面镜像服务器地址(不包含http://，如下图)和端口，并且选中『Force https://… sources to be fetched using http://…』复选框。设置完成后单击『Close』按钮关闭『Android SDK Manager - Settings』窗口返回到主界面； 依次选择『Packages』、『Reload』。 Android Studio 注意:以下 Android Studio 下载链接全是 dl.google.com 开头的官方下载，无需tizi，建议用浏览器直接从官方原始链接下载，不要用迅雷下载、不要用迅雷下载、不要用迅雷下载，重要的事情说三遍，避免类似XCodeGhost的事件！！！ 版本号 Windows Mac OSX Linux SHA-1校验码 官方SHA-1校验码截图 2.1.3 正式版 下载 (推荐) 下载 (不含SDK Tools) 下载 下载 下载 Win: 10d319c772b80f3cb0cde952451af8429ea1b68b 43f84de7e61f37880a126c3d567b7fa6cb90c90e 8ad212c55c7f4dc7ab490e4b7e77ec48001ae224 Mac: 06166759b0e1e1ee91a147dcf5227d897a184277 Linux: 8729e6f2f1fa58f04df9f8d1caac2f5be9dfc549 查看 2.2 Beta 下载 下载 下载 Win: 7d2c9861e90dc985b1e6ba78ebd8497b610a8620 Mac:050a443ffee51922eabddbcd260c845a8e06e4a9 Linux: bafb5d7029d2678e8274e24da1c7ce0a00f3a644 查看 2.2 Preview7 下载 下载 下载 Win: e6ea4c9d9bf4ae46dbea82e3cc5638fd93194c33 Mac: 56327a0f97d999a6b7a15f3e9e513aa42881c989 Linux: b85c4e27401f7f18af19e39e453cca8575041dbb 查看 2.1.2 正式版 下载(推荐) 下载(不含SDK Tools) 下载 下载 下载 Win: 10d319c772b80f3cb0cde952451af8429ea1b68b 43f84de7e61f37880a126c3d567b7fa6cb90c90e 8ad212c55c7f4dc7ab490e4b7e77ec48001ae224 Mac: Linux: 查看 SDK Tools 版本号 Windows Mac OSX Linux SHA-1校验码 官方SHA-1校验码截图 24.4.1 installer_r24.4.1-windows.exe android-sdk_r24.4.1-windows.zip android-sdk_r24.4.1-macosx.zip android-sdk_r24.4.1-linux.tgz Win:f9b59d72413649d31e633207e31f456443e7ea0b 66b6a6433053c152b22bf8cab19c0f3fef4eba49 Mac: 85a9cccb0b1f9e6f1f616335c5f07107553840cd Linux: 725bb360f0f7d04eaccff5a2d57abdd49061326d 查看 24.3.4 installer_r24.3.4-windows.exe android-sdk_r24.3.4-windows.zip android-sdk_r24.3.4-macosx.zip android-sdk_r24.3.4-linux.tgz Win: 094dd45f98a31f839feae898b48f23704f2878dd 4a8718fb4a2bf2128d34b92f23ddd79fc65839e7 Mac: 128f10fba668ea490cc94a08e505a48a608879b9 Linux: fb293d7bca42e05580be56b1adc22055d46603dd 查看 SDK Platform-Tools这是 adb, fastboot 等工具包。把解压出来的 platform-tools 文件夹放在 android sdk 根目录下，并把 adb所在的目录添加到系统 PATH 路径里，即可在命令行里直接访问了 adb, fastboot 等工具。 版本号 Windows Mac OSX Linux platform-tools-r22 platform-tools_r22-windows.zip platform-tools_r22-mac.zip platform-tools_r22-linux.zip platform-tools-r21 platform-tools_r21-windows.zip platform-tools_r21-mac.zip platform-tools_r21-linux.zip platform-tools-r20 platform-tools_r20-windows.zip platform-tools_r20-mac.zip platform-tools_r20-linux.zip Build-Tools这是Android开发所需的Build-Tools，下载并解压后，将解压出的整个文件夹复制或者移动到 your sdk 路径/build-tools 文件夹即可。 版本号 Windows Mac OSX Linux 22.0.0 下载 下载 下载 21.1.2 下载 下载 21.1.1 下载 下载 21.1.0 下载 下载 21.0.2 下载 下载 21.0.1 下载 下载 21.0.0 下载 下载 20.0.0 下载 19.1.0 下载 下载 19.0.3 下载 下载 19.0.2 下载 下载 19.0.1 下载 下载 19.0.0 下载 下载 SDK这是Android开发所需的sdk，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/platforms文件夹，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本号 Windows Mac OSX Linux android 5.0 下载 下载 下载 android L Rev3 下载 下载 下载 android L 下载 下载 下载 android 4.4W 下载 下载 下载 android 4.4.2 下载 下载 下载 android 4.3 下载 下载 下载 android 4.2.2 下载 下载 下载 android 4.1.2 下载 下载 下载 android 4.0.3 下载 下载 下载 android 4.0 下载 下载 下载 android 3.2 下载 下载 下载 android 3.1 下载 下载 下载 android 3.0 下载 下载 下载 android 2.3.3 下载 下载 下载 android 2.2 下载 下载 下载 SDK System images这是在创建模拟器时需要的system image，也就是在创建模拟器时CPU/ABI项需要选择的，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/system-images文件夹下即可， 如果没有system-images目录就先创建此文件夹，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本号 Windows Mac OSX Linux android 5.0 下载 下载 下载 android L 下载 下载 下载 android 4.4W 下载 下载 下载 android 4.4.2 下载 下载 下载 android 4.3 下载 下载 下载 android 4.2.2 下载 下载 下载 android 4.1.2 下载 下载 下载 android 4.0.3 下载 下载 下载 android 4.0 下载 下载 下载 GoogleMap APIs SDK这是GoogleMap APIs SDK，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/add-ons文件夹下，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本号 Windows Mac OSX Linux android 4.4.2 下载ARM版 下载x86版 下载ARM版 下载x86版 下载ARM版 下载x86版 android 4.3 下载 下载 下载 android 4.2.2 下载 下载 下载 android 4.1.2 下载 下载 下载 android 4.0.3 下载 下载 下载 android 4.0 下载 下载 下载 android 3.2 下载 下载 下载 android 3.1 下载 下载 下载 android 3.0 下载 下载 下载 android 2.3.3 下载 下载 下载 android 2.2 下载 下载 下载 Google Glass SDK这是GDK，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/add-ons文件夹下，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本 Windows Mac OSX Linux android 4.4.2 下载 下载 下载 android 4.0.3 下载 Google TV Addon这是Google TV Addon，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/add-ons文件夹，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本 Windows Mac OSX Linux android 3.2 下载 下载 下载 ####Android Framework Source Code这是Android Framework Source Code，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/sources文件夹下，然后重启Eclipse(或Android Studio)，这样当你在Eclipse里面按住Ctrl键点击某个系统类时就可以打开该类的源码文件查看源码了。 系统版本 android 5.0 android 4.4W android 4.4.2 android 4.3 android 4.2.2 android 4.1.2 android 4.0.3 android 4.0 android 3.0 android 2.3.3 android 2.2 Android SDK Extras包含 Android Support Library 、 Google Cloud Messaging for Android Library 、Google Play services 、 Google Play services for fit preview 、Google Play services for Froyo 、Google Play APK Expansion Library、Google Play Billing Library 、Google Play Licensing Library 等，下载解压后将解压出的整个文件夹复制或者移动到your sdk根目录下下，如果已经存在extras文件夹就替换掉。 版本号 21.0.3 21.0.2 21 20 Support Library包含support v4、v7、v13、v17、multidex和m2repository，下载解压后将解压出的整个文件夹复制或者移动到your sdk 路径/extras下，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 版本号 21.0.3 21.0.2 21 20 SDK Samples这是Android SDK自带的示例代码，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/samples文件夹下，然后重启Eclipse(或Android Studio)。。 系统版本 android 21 android L android 4.4W android 4.4.2 android 4.3 android 4.2.2 android 4.1.2 android 4.0.3 android 4.0 android 3.2 android 3.1 android 3.0 android 2.3.3 android 2.2 NDKC/C++开发Android应用工具包,Linux/Mac OS X 下NDK r10c的安装方法请戳 这里 版本号 Windows Mac OSX Linux MD5/SHA-1校验码 官方SHA-1校验码截图 ndk-r11b 32位 64位 64位 64位 Win:b42da395440cc1c5dc4eeeb383679331addeb3ea 480eca1b29cfe73a5b35374730e6a82ca65c2aa6 Mac: c64fb355fec4da57d329ab45bf0aa29a1aec58dc Linux: cf0658956945c81d3d3fad5f9a24fa062d4c9d41 查看 ndk-r10e 32位 64位 64位 32位 64位 Win: 1a82445baaf62aec3a46386ab1e5772c 8412bb4991a95e08fda50b5a44d95df7 Mac: 2cb8893a5701603519d38a7e04c50e81 Linux: c3edd3273029da1cbd2f62c48249e978 19af543b068bdb7f27787c2bc69aba7f 查看 Additional Download (32-, 64-bit) Package r10 STL debug info android-ndk-r10-cxx-stl-libs-with-debug-info.zip r9 STL debug info android-ndk-r9-cxx-stl-libs-with-debug-info.zip Android L Preview System Image这个是Android L Preview系统的刷机镜像。 设备 下载 Nexus 5 (GSM/LTE) “hammerhead” hammerhead-lpv79-preview-ac1d8a8e.tgz Nexus 7 (Wifi) “razor” razor-lpv79-preview-d0ddf8ce.tgz JDK 版本号 Windows Mac OSX Linux 1.8 u77 32位 64位 64位 32位 64位 1.8 u74 32位 64位 64位 32位 64位 1.7 u80 32位 64位 64位 32位 64位 1.6 u45 32位 64位 64位 32位 64位 ADT BundleADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境。 版本号 Windows Mac OSX Linux 23.0.2 32位 64位 64位 32位 64位 23.0.0 32位 64位 64位 32位 64位 ADT Plugin离线安装ADT插件请戳项目wiki 版本号 ADT-23.0.7 ADT-23.0.6 ADT-23.0.4 ADT-23.0.3 ADT-23.0.2 ADT-23.0.0 ADT-22.6.3 AdT-22.6.1 Gradle 版本号 gradle-2.12-all.zip gradle-2.11-all.zip gradle-2.10-all.zip gradle-2.9-all.zip gradle-2.8-all.zip gradle-2.7-all.zip gradle-2.6-all.zip gradle-2.5-all.zip gradle-2.4-all.zip gradle-2.3-all.zip gradle-2.2.1-all.zip gradle-2.2-all.zip gradle-2.1-all.zip gradle-2.0-all.zip gradle-1.12-all.zip gradle-1.11-all.zip gradle-1.10-all.zip gradle-1.9-all.zip gradle-1.8-all.zip gradle-1.7-all.zip Android Gradle Plugin DSL 在线文档http://google.github.io/android-gradle-dsl/ Gradle Dependencies Configuration Generator（需要梯子）http://gradleplease.appspot.com 版本控制工具Git 版本号 Windows Mac OSX Linux Git-2.0.1 下载 下载 Git-1.9.4 下载 下载 Git-1.8.5.2 下载 下载 下载 SVN Plugin For Eclipse 版本号 1.10.5 1.8.22 1.6.18 反编译工具 名称 简介 下载地址 使用教程 Enjarify Enjarify 是一个用 Python 写的， Google 官方开源的可以将 Dalvik 字节码转换为 Java 字节码的工具。 下载 JEB Android Decompiler 下载 Virtuous Ten Studio 下载 Apk文件修改工具Root Tools 下载 Dex文件反编译工具Dedexer 下载 APK+Dex文件反编译及回编译工具 下载 android-apktool 下载 Onekey Decompile Apk] 下载 Baksmali 下载 Smali 下载 AXMLPrinter2 下载 JAD Java Decompiler 下载 JD-GUI Decompiler 下载 XJad V2.2 下载 Android APK Decompiler 在线反编译工具 下载 JADX - Dex to Java decompiler 下载 dex2jar 下载 SmaliViewer 是一款免费的APK分析软件，无论从分析的深度还是广度来看，都是一款能够满足用户需求的产品，使您在APK分析的过程中，更加得心应手。 下载 使用指南 Android逆向助手 Android逆向助手是一功能强大的逆向辅助软件。该软件可以帮助用户来进行apk反编译打包签名；dex/jar互转替换提取修复；so反编译；xml、txt加密；字符串编码等等，操作简单，只需要直接将文件拖放到源和目标文件。 下载 使用指南 Android Killer Android Killer 是一款可视化的安卓应用逆向工具，集Apk反编译、Apk打包、Apk签名，编码互转，ADB通信（应用安装-卸载-运行-设备文件管理）等特色功能于一 身，支持logcat日志输出，语法高亮，基于关键字（支持单行代码或多行代码段）项目内搜索，可自定义外部工具；吸收融汇多种工具功能与特点，打造一站 式逆向工具操作体验，大大简化了用户在安卓应用/游戏修改过程中的各类繁琐工作。 下载1下载2 使用指南 DexExtractor android dex extractor ，anti-shell，android 脱壳。 下载 jadx Dex to Java decompiler 下载 android-classyshark a handy Android and Java executables viewer 下载 ShakaApktool 下载 安全工具 名称 下载地址 使用教程 APKfuscator 下载 ApkAnalyser 下载 AppXplore 下载 Android analysis framework 下载 Androguard 下载 Droidbox 下载 dsploit 下载 Androwarn 下载 Anubis 下载 Drozer 下载 VirusTotal 下载 GDB for Android 下载 VisualGDB 下载 静态代码分析工具 名称 简介 下载地址 使用教程 infer Facebook 开源的静态代码分析工具，用于在发布移动应用之前对代码进行分析，找出潜在的问题。 下载 搜索工具 名称 简介 下载地址 使用教程 Structural Java Exception Search Java异常搜索工具 下载 Android Library Finder 最快的方式获取依赖库 下载 Codota 示例代码搜索网站 下载 Debug调试工具 名称 简介 下载地址 使用教程 Stetho Stetho 是Facebook推出的Android 调试平台，基于 Chrome Developer Tools ，调试网络请求方面特别方便。 下载 教程 Augmented Traffic Control Facebook宣布开源移动网络测试工具ATC，该工具支持利用Wi-Fi网络模拟2G、2.5G、3G以及LTE 4G移动网络环境，让测试工程师们能够快速对智能手机和App在不同国家地区和应用环境下的性能表现进行测试。 下载 Api测试工具 名称 简介 下载地址 使用教程 bat 一个用Go写的命令行API测试利器，支持文件下载，文件上传，支持Linux的pipe方式，总之就是炫酷。 下载 使用指南 Eclipse/Android Studio/IDEA插件Eclipse 名称 下载地址 使用教程 SVN 下载 Genymobile模拟器 下载 Memory-Analyzer-Tools 下载 Droidinspector 下载 SQLiteManager 下载 Color Theme 下载 RoboVM 下载 Newrelic 下载 Android Studio/IDEA 名称 下载地址 使用教程 Android Resource Resizer Plugin 下载 Gradle Dependencies Helper Plugin 下载 Android Parcelable code generation Plugin 下载 Android Holo Colors IDEA Plugin 下载 Android Toolbox Plugin 下载 Android Gradle Sign Plugin 下载 Android Permissions Usage Plugin 下载 Android Helper Plugin 下载 Android Studio Prettify Plugin 下载 IDEA ADB Plugin 下载 Otto Intellij Plugin 下载 Dagger intellij Plugin 下载 Gradle Gui Plugin 下载 Android Studio Unit Test Plugin 下载 Android Layout ID Converter Plugin 下载 IDEA protobuf Plugin 下载 Simple Team Code Reviewer Plugin 下载 Android XML Plugin 下载 ADF Plugin 下载 Java2smali Plugin 下载 IDEA gitignore Plugin 下载 IDEA Background Image Plugin 下载 IDEA Maven Plugin 下载 Gradle GooglePlay Publisher Plugin 下载 Drawable Selectors Generates Plugin 下载 Android Drawable Importer 下载 Color themes for IntelliJ IDEA 下载 GsonFormat 下载 ormlite-android-gradle-plugin 下载 Android资源/Themes/Style生成工具 名称 简介 下载地址 使用教程 Android Asset Studio 下载 Android Drawable Factory 下载 Android Action Bar Style Generator 下载 Android Holo Colors Generator 下载 Android Simple Nine-patch Generator 下载 Android Device Frame Generator 下载 Android 9-patch shadow generator 下载 Android资源分析工具 名称 简介 下载地址 使用教程 Android Assets Viewer 下载 Android Layout Parser工具 名称 简介 下载地址 使用教程 Android Layout Binder 下载 Android Content Provider代码生成工具 名称 简介 下载地址 使用教程 Content Provider Code Generator 下载 Android Fragment Code Generator代码生成工具 名称 简介 下载地址 使用教程 Android Fragment Code Generator 下载 代码生成工具 名称 简介 下载地址 使用教程 Android KickstartR AndroidKickstartR帮助您快速创建Android应用程序并使用最流行的库进行配置。它创建和配置你的项目给你。只专注于代码! 下载 Android Button Maker Android Button Maker是一个在线生成Android应用按钮代码的工具。Android的API提供可绘制资源，其中的XML文件定义的几何形状，包括颜色，边框和梯度。这些按钮是在shape drawable XML代码基础上产生的相比通常的PNG按钮加载速度更快。您可以在设置面板中自定义按钮的属性和获得源代码。 下载 DroidDraw 下载 Android SVG to VectorDrawable 一个可以将SVG图片转换为Vector Drawable xml文件的在线工具。 下载 Android Native开发工具 名称 简介 下载地址 使用教程 Android++ 下载 Android测试工具 名称 简介 下载地址 使用教程 Appurify 下载 Monkey 下载 Testin 下载 Spoon 下载 Little Eye 下载 易测云 下载 Emmagee 下载 Apk View Tracer 下载 APT APT是一个Android平台高效性能测试组件，提供丰富实用的功能，适用于开发自测、定位性能瓶颈；测试人员完成性能基准测试、竞品对比测试。 下载 教程 GT GT（随身调）是APP的随身调测平台，它是直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug&amp;Test Environment)。 下载 教程 Mobile-Checker 移动端页面检查工具,可以选择三种屏幕规格，通过工具发现网站在移动端存在的问题。 下载 Android多渠道打包工具 名称 简介 下载地址 使用教程 Umeng多渠道打包工具 下载 AppTools具 下载 package_tool 下载 RyApkTool 下载 兰贝壳儿 下载 教程 Android Bug日志收集工具 名称 简介 下载地址 使用教程 Crashlytics 下载 ACRA 下载 ChkBugReport 下载 Log Collector 下载 Android Crash Catcher 下载 其他语言开发Android应用工具 名称 简介 下载地址 使用教程 Xamarin 下载 Basic4android 下载 Scripting Layer 下载 Ruby Rhodes 移动设备上的Ruby 下载 PHP for Android 下载 Codename One 下载 Touchqode 下载 App Inventor 下载 传感器模拟工具 名称 简介 下载地址 使用教程 Sensor Simulator 独立的Java应用程序，它模拟传感器的数据并将它们传送到Android模拟器。 下载 Android串口开发工具 名称 简介 下载地址 使用教程 Android Serialport Api 下载 图片尺寸处理工具 名称 简介 下载地址 使用教程 9-Patch Resizer 下载 图片压缩工具 名称 简介 下载地址 使用教程 OptiPNG 下载 Pngcrush 下载 ImageOptim 下载 Tinypng 下载 资源清理工具 名称 简介 下载地址 使用教程 Android Lint 下载 Android Resource Cleaner 下载 Android Unused Resources 下载 Android Resource Remover 下载 px和dp转换/计算工具 名称 简介 下载地址 使用教程 Android dp px Calculator 下载 dp px converter 下载 pixelcalc 下载 androidpixels 下载 android dpi calculator 下载 DPI Calculator 下载 Android DPI Calculator插件 下载 Java To iOS 名称 简介 下载地址 使用教程 j2Objc 下载 RoboVM 下载 JSON/XML转换为POJO Class工具 名称 简介 下载地址 使用教程 jsonschema2pojo 下载 Convert XML or JSON to Java Pojo 下载 Java DAO Generate工具 名称 简介 下载地址 使用教程 Generate Java DAO for relational data table 下载 Chrome插件Android插件 名称 简介 下载地址 使用教程 Android SDK Search 下载 Android Resource Navigator 下载 ADB Plugin for remote debugging Chrome on Android 下载 Mobile/RWD Tester 下载 ExtensionAndroid SDK Samples Search 下载 Android Developer Improvements 下载 Android downloader 下载 JSON/XML格式化插件 名称 简介 下载地址 使用教程 JSONView 下载 JSON Formatter 下载 JSON Viewer 下载 JSON Finder 下载 Encode/Decode插件 名称 简介 下载地址 使用教程 Base64 Encode and Decode 下载 Git 名称 简介 下载地址 使用教程 Git Cheat Sheet 下载 GuidesGoogle Java编程风格指南中文版英文地址：http://google-styleguide.googlecode.com/svn/trunk/javaguide.html 地址0：http://hawstein.com/posts/google-java-style.html 地址1：https://github.com/codeset/google-java-styleguide Android Developers 国内镜像站地址: Android Developers 国内镜像站 Android Api中文版地址：http://www.embeddedlinux.org.cn/androidapi/ ####Android API指南中文版 地址：http://api.apkbus.com/guide Android Proguard混淆配置指南地址：https://github.com/inferjay/AndroidProguardGuide/ Gradle插件使用指南中文版地址：http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision Gradle User GuideGradle 1.12用户指南：http://pan.baidu.com/s/1dD7sC2d TutorialsAndroid学习之路地址：http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/ Google Android官方培训课程中文版地址：http://hukai.me/android-training-course-in-chinese/index.html Developing Android Apps地址：https://www.udacity.com/course/ud853 Java Design Patterns Samples in Java.Java Design Patterns Design Design ToolsPhotoshop插件 名称 简介 下载地址 使用教程 Cut&amp;Slice 切图神器 下载 DevRocket 切图神器 下载 Cutterman 最好用的切图工具 下载 Ink 下载 Corner Editor 路径圆角编辑工具 下载1 下载1 GuideGuide 辅助线工具 下载 Assistor PS 下载 Skeuomorphism.it 下载 QuickGuide 下载 Long Shadow Generator 长投影效果生成插件 下载 android_resizer_toolkit 下载 android-ps-tools 一些方便Android UI设计的PhototShop插件。 下载 LayerCraft A Photoshop plugin to export UI assets from layers 下载 矢量图设计工具 名称 简介 下载地址 使用教程 Sketch 3 下载 Affinity Designer 下载 Gravit 下载 Adobe Illustrator 下载 切图工具 名称 简介 下载地址 使用教程 Slicy 下载 设计稿尺寸标注工具 名称 简介 下载地址 使用教程 马克鳗 下载 PxCook像素大厨 UI设计师效率提升利器，让你专注于设计本质，不再为标注切图而烦恼，从设计到实现一气呵成 下载 使用教程 原型设计工具 名称 简介 下载地址 使用教程 Axure 下载 Fluid UI 下载 Briefs 下载 Flinto 下载 Balsamiq Mockups 下载 AppCooker 下载 Proto.io 下载 UXPin 下载 InVision 下载 POP 下载 快现 下载 Composite 下载 OmniGraffle 下载 Marvelapp 下载 Justinmind 下载 Form 下载 Prott 下载 Composite 下载 Avocado 下载 Pixate 下载 交互设计工具 名称 简介 下载地址 使用教程 Framer Studio 下载 Quartz Composer 下载 Origami 下载 jQC 下载 UI效果预览工具 名称 简介 下载地址 使用教程 Android Design Preview 下载 PS Play 下载 Pixl Preview 下载 Skala Preview 下载 LiveView 下载 配色工具 名称 简介 下载地址 使用教程 Android Material Design可视化调色板 下载 Android Material Design Colours.xml 下载 Colorube配色神器 下载 Adobe Kuler 下载 ColorSchemer Studio 下载 Piknik 下载 设计稿版本控制工具 名称 简介 下载地址 使用教程 LayerVault 下载 图标处理工具 名称 简介 下载地址 使用教程 Icon Slate 下载 在线Icon库 名称 简介 下载地址 使用教程 IconFont 下载 NounProject 下载 取色工具 名称 简介 下载地址 使用教程 ColorSnapper 下载 不透明度16进制值 不透明度 16进制值 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00 出自：http://stackoverflow.com/questions/5445085/understanding-colors-in-android-6-chars 手机To电脑同步预览工具 名称 简介 下载地址 使用教程 Reflector 下载 x-Mirage 下载 AirServer 下载 BBQScreen 下载 Gif图片录制工具 名称 简介 下载地址 使用教程 LICEcap 下载 GifCam 下载 Android Tool 下载 UI Programming LanguageUILang TutorialsHackDesign GamesThe Bezier Game 一个帮助你练习PS里钢笔工具的小游戏。 GuidesAndroid设计指南非官方简体中文版Topfun镜像地址：http://www.topfun.us/adchs/index.html Github镜像地址：http://adchs.github.io ApkBus镜像地址：http://www.apkbus.com/design/ Segmentfault镜像地址：http://mirrors.segmentfault.com/adchs/ 多看阅读镜像地址：http://www.duokan.com/book/47790 Android Cheatsheet for Graphic Designers地址:http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/ Google Material Design 中文版地址：http://design.1sters.com 地址： http://www.ui.cn/Material/ Designer’s Guide To dpi地址：http://sebastien-gabriel.com/designers-guide-to-dpi/home Email Design Guide地址：http://mailchimp.com/resources/email-design-guide/ Free Design ResourcesGoogle Material Design 素材(感谢 @SanityD) Material Design Icon Templates Material Design的图标集 Material Design UI Kit for Sketch Nexus 5 template for Sketch Free Design Resources 434 SVG icons UI Cloun 161个国内外社交网站矢量图标 250 free icons in 5 sizes and 14 colors MINIMALISTIC EVERYDAY ICONS Icons4Android Books Free Programming Books 一堆免费的Android开发相关的电子书。 50 Android Hacks 50 Android Hacks这本书分12个部分介绍了50个Android开发的小技巧。 免费的编程中文书籍索引 Disclaimer 版权归原作者所有，这里仅做收集整理，欢迎自由转载-非商用-非衍生-保持署名和链接。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"你真的了解AsyncTask吗","date":"2017-07-26T12:09:45.000Z","path":"2017/07/26/你真的了解AsyncTask吗.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 你真的了解AsyncTask?虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？ AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。 AsyncTask是什么？AsyncTask到底是什么呢？很简单，它不过是对线程池和Handler的封装；用线程池来处理后台任务，用Handler来处理与UI的交互。线程池使用的是Executor接口，我们先了解一下线程池的特性。 线程池ThreadPoolExecutorJDK5带来的一大改进就是Java的并发能力，它提供了三种并发武器：并发框架Executor，并发集合类型如ConcurrentHashMap，并发控制类如CountDownLatch等；圣经《Effective Java》也说，尽量使用Exector而不是直接用Thread类进行并发编程。 AsyncTask内部也使用了线程池处理并发；线程池通过ThreadPoolExector类构造，这个构造函数参数比较多，它允许开发者对线程池进行定制，我们先看看这每个参数是什么意思，然后看看Android是以何种方式定制的。 ThreadPoolExecutor的其他构造函数最终都会调用如下的构造函数完成对象创建工作： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize: 核心线程数目，即使线程池没有任务，核心线程也不会终止（除非设置了allowCoreThreadTimeOut参数）可以理解为“常驻线程” maximumPoolSize: 线程池中允许的最大线程数目；一般来说，线程越多，线程调度开销越大；因此一般都有这个限制。 keepAliveTime: 当线程池中的线程数目比核心线程多的时候，如果超过这个keepAliveTime的时间，多余的线程会被回收；这些与核心线程相对的线程通常被称为缓存线程 unit: keepAliveTime的时间单位 workQueue: 任务执行前保存任务的队列；这个队列仅保存由execute提交的Runnable任务 threadFactory: 用来构造线程池的工厂；一般都是使用默认的； handler: 当线程池由于线程数目和队列限制而导致后续任务阻塞的时候，线程池的处理方式。 那么，当一个新的任务到达的时候，线程池中的线程是如何调度的呢？（别慌，讲这么一大段线程池的知识，是为了理解AsyncTask；Be Patient） 如果线程池中线程的数目少于corePoolSize，就算线程池中有其他的没事做的核心线程，线程池还是会重新创建一个核心线程；直到核心线程数目到达corePoolSize（常驻线程就位） 如果线程池中线程的数目大于或者等于corePoolSize，但是工作队列workQueue没有满，那么新的任务会放在队列workQueue中，按照FIFO的原则依次等待执行；（当有核心线程处理完任务空闲出来后，会检查这个工作队列然后取出任务默默执行去） 如果线程池中线程数目大于等于corePoolSize，并且工作队列workQueue满了，但是总线程数目小于maximumPoolSize，那么直接创建一个线程处理被添加的任务。 如果工作队列满了，并且线程池中线程的数目到达了最大数目maximumPoolSize，那么就会用最后一个构造参数handler处理；默认的处理方式是直接丢掉任务，然后抛出一个异常。 总结起来，也即是说，当有新的任务要处理时，先看线程池中的线程数量是否大于 corePoolSize，再看缓冲队列 workQueue 是否满，最后看线程池中的线程数量是否大于 maximumPoolSize。另外，当线程池中的线程数量大于 corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。 我们以API 22为例，看一看AsyncTask里面的线程池是以什么参数构造的；AsyncTask里面有“两个”线程池；一个THREAD_POOL_EXECUTOR一个SERIAL_EXECUTOR；之所以打引号，是因为其实SERIAL_EXECUTOR也使用THREAD_POOL_EXECUTOR实现的，只不过加了一个队列弄成了串行而已，那么这个THREAD_POOL_EXECUTOR是如何构造的呢？ 123456789private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 可以看到，AsyncTask里面线程池是一个核心线程数为CPU + 1，最大线程数为CPU * 2 + 1，工作队列长度为128的线程池；并且没有传递handler参数，那么使用的就是默认的Handler（拒绝执行). 那么问题来了： 如果任务过多，那么超过了工作队列以及线程数目的限制导致这个线程池发生阻塞，那么悲剧发生，默认的处理方式会直接抛出一个异常导致进程挂掉。假设你自己写一个异步图片加载的框架，然后用AsyncTask实现的话，当你快速滑动ListView的时候很容易发生这种异常；这也是为什么各大ImageLoader都是自己写线程池和Handlder的原因。 这个线程池是一个静态变量；那么在同一个进程之内，所有地方使用到的AsyncTask默认构造函数构造出来的AsyncTask都使用的是同一个线程池，如果App模块比较多并且不加控制的话，很容易满足第一条的崩溃条件；如果你不幸在不同的AsyncTask的doInBackgroud里面访问了共享资源，那么就会发生各种并发编程问题。 在AsyncTask全部执行完毕之后，进程中还是会常驻corePoolSize个线程；在Android 4.4 （API 19）以下，这个corePoolSize是hardcode的，数值是5；API 19改成了cpu + 1；也就是说，在Android 4.4以前；如果你执行了超过五个AsyncTask；然后啥也不干了，进程中还是会有5个AsyncTask线程；不信，你看： HandlerAsyncTask里面的handler很简单，如下（API 22代码）： 12345private static final InternalHandler sHandler = new InternalHandler();public InternalHandler() &#123; super(Looper.getMainLooper());&#125; 注意，这里直接用的主线程的Looper；如果去看API 22以下的代码，会发现它没有这个构造函数，而是使用默认的；默认情况下，Handler会使用当前线程的Looper，如果你的AsyncTask是在子线程创建的，那么很不幸，你的onPreExecute和onPostExecute并非在UI线程执行，而是被Handler post到创建它的那个线程执行；如果你在这两个线程更新了UI，那么直接导致崩溃。这也是大家口口相传的AsyncTask必须在主线程创建的原因。 另外，AsyncTask里面的这个Handler是一个静态变量，也就是说它是在类加载的时候创建的；如果在你的APP进程里面，以前从来没有使用过AsyncTask，然后在子线程使用AsyncTask的相关变量，那么导致静态Handler初始化，如果在API 16以下，那么会出现上面同样的问题；这就是AsyncTask必须在主线程初始化 的原因。 事实上，在Android 4.1(API 16)以后，在APP主线程ActivityThread的main函数里面，直接调用了AscynTask.init函数确保这个类是在主线程初始化的；另外，init这个函数里面获取了InternalHandler的Looper，由于是在主线程执行的，因此，AsyncTask的Handler用的也是主线程的Looper。这个问题从而得到彻底的解决。 AsyncTask是并行执行的吗？现在知道AsyncTask内部有一个线程池，那么派发给AsyncTask的任务是并行执行的吗？ 答案是不确定。在Android 1.5刚引入的时候，AsyncTask的execute是串行执行的；到了Android 1.6直到Android 2.3.2，又被修改为并行执行了，这个执行任务的线程池就是THREAD_POOL_EXECUTOR，因此在一个进程内，所有的AsyncTask都是并行执行的；但是在Android 3.0以后，如果你使用execute函数直接执行AsyncTask，那么这些任务是串行执行的；（你说蛋疼不）源代码如下： 123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 这个sDefaultExecutor就是用来执行任务的线程池，那么它的值是什么呢？继续看代码： 1private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 因此结论就来了：Android 3.0以上，AsyncTask默认并不是并行执行的； 为什么默认不并行执行？也许你不理解，为什么AsyncTask默认把它设计为串行执行的呢？ 由于一个进程内所有的AsyncTask都是使用的同一个线程池执行任务；如果同时有几个AsyncTask一起并行执行的话，恰好AysncTask的使用者在doInbackgroud里面访问了相同的资源，但是自己没有处理同步问题；那么就有可能导致灾难性的后果！ 由于开发者通常不会意识到需要对他们创建的所有的AsyncTask对象里面的doInbackgroud做同步处理，因此，API的设计者为了避免这种无意中访问并发资源的问题，干脆把这个API设置为默认所有串行执行的了。如果你明确知道自己需要并行处理任务，那么你需要使用executeOnExecutor(Executor exec,Params... params)这个函数来指定你用来执行任务的线程池，同时为自己的行为负责。（处理同步问题） 实际上《Effective Java》里面有一条原则说的就是这种情况：不要在同步块里面调用不可信的外来函数。这里明显违背了这个原则：AsyncTask这个类并不知道使用者会在doInBackgroud这个函数里面做什么，但是对它的行为做了某种假设。 如何让AsyncTask并行执行？正如上面所说，如果你确定自己做好了同步处理，或者你没有在不同的AsyncTask里面访问共享资源，需要AsyncTask能够并行处理任务的话，你可以用带有两个参数的executeOnExecutor执行任务： 1234567new AsyncTask&lt;Void, Void, Vo @Override protected Void doInBackground(Void... params) &#123; // do something return null; &#125;&#125;.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR); 更好的AsyncTask从上面的分析得知，AsyncTask有如下问题： 默认的AsyncTask如果处理的任务过多，会导致程序直接崩溃； AsyncTask类必须在主线程初始化，必须在主线程创建，不然在API 16以下很大概率崩溃。 如果你曾经使用过AsyncTask，以后不用了；在Android 4.4以下，进程内也默认有5个AsyncTask线程；在Android 4.4以上，默认有CPU + 1个线程。 Android 3.0以上的AsyncTask默认是串行执行任务的；如果要并行执行需要调用低版本没有的API，处理麻烦。 因此我们对系统的AsyncTask做了一些修改，在不同Android版本提供一致的行为，并且提高了使用此类的安全性，主要改动如下： 添加对于任务过多导致崩溃的异常保护；在这里进行必要的数据统计上报工作；如果出现这个问题，说明AsyncTask不适合这种场景了，需要考虑重构； 移植API 22对于Handler的处理；这样就算在线程创建异步任务，也不会有任何问题； 提供串行执行和并行执行的execute方法；默认串行执行，如果明确知道自己在干什么，可以使用executeParallel并行执行。 在doInbackgroud里面频繁崩溃的地方加上try..catch；自己处理数据上报工作。 完整代码见gist，BetterAsyncTask 原文地址：http://weishu.me/2016/01/18/dive-into-asynctask/ 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"ViewDragHelper源码解析","date":"2017-07-26T12:08:18.000Z","path":"2017/07/26/ViewDragHelper源码解析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 ViewDragHelper源码解析1. 简介我们了解了ViewDragHelper是可以帮助我们处理各种拖拽事件的类.使用好ViewDragHelper能帮助我们做出各种酷炫的交互,今天我们就来分析一下ViewDragHelper的使用与实现 2. 使用方法我们这里就以翔总的这篇文章中的例子来介绍一下ViewDragHelper的使用.另外,本文中的demo可以在这里找到 首先我们创建一个DragLayout类并继承自LinearLayout,然后我们准备在DragLayout放置三个View第一个用来被我们拖动然后停止在松手的位置,第二个可以被我们拖动,松手的时候滑动到指定位置,第三个只可以通过触摸边缘来进行拖动, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class DragLayout extends LinearLayout &#123; private ViewDragHelper mDragger; private View mDragView; private View mAutoBackView; private View mEdgeTrackerView; private Point mAutoBackOriginPos = new Point(); public DragLayout(Context context) &#123; this(context, null); &#125; public DragLayout(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DragLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initViewDragHelper(); &#125; private void initViewDragHelper() &#123; mDragger = ViewDragHelper.create(this,myCallback); mDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_ALL); &#125; ViewDragHelper.Callback myCallback = new ViewDragHelper.Callback() &#123; @Override //child为当前触摸区域下的View,如果返回true,就可以拖拽. public boolean tryCaptureView(View child, int pointerId) &#123; return child == mDragView || child == mAutoBackView; &#125; //松手时的回调 @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; if (releasedChild == mAutoBackView) &#123; mDragger.settleCapturedViewAt(mAutoBackOriginPos.x, mAutoBackOriginPos.y); invalidate(); &#125; &#125; //边缘触摸开始时的回调 @Override public void onEdgeDragStarted(int edgeFlags, int pointerId) &#123; mDragger.captureChildView(mEdgeTrackerView, pointerId); &#125; //获取水平方向允许拖拽的区域,这里是父布局的宽-子控件的宽 @Override public int getViewHorizontalDragRange(View child) &#123; return getMeasuredWidth() - child.getMeasuredWidth(); &#125; //获取垂直方向允许拖拽的范围 @Override public int getViewVerticalDragRange(View child) &#123; return getMeasuredHeight() - child.getMeasuredHeight(); &#125; //left为child即将移动到的水平位置的值,但是返回值会最终决定移动到的值 //这里直接返回了left @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; return left; &#125; //同上只是这里是垂直方向 @Override public int clampViewPositionVertical(View child, int top, int dy) &#123; return top; &#125; &#125;; @Override public void computeScroll() &#123; if (mDragger.continueSettling(true)) &#123; invalidate(); &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragger.shouldInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mDragger.processTouchEvent(event); return true; &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); mDragView = getChildAt(0); mAutoBackView = getChildAt(1); mEdgeTrackerView = getChildAt(2); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mAutoBackOriginPos.x = mAutoBackView.getLeft(); mAutoBackOriginPos.y = mAutoBackView.getTop(); &#125;&#125; 我们首先在构造方法里传入了当前类的对象和我们定义的ViewDragHelper.Callback对象初始化了我们的ViewDragHelper,然后我们希望所有的边缘触摸都能触发mEdgeTrackerView的拖动,所以我们紧接着调用了mDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_ALL);方法. 在我们定义的Callback中,有多个回调方法,每个回调方法都有它的作用,在代码里注释比较清楚了，我们下面也会解析每一个Callback中回调方法的作用. 第三步我们需要在onInterceptTouchEvent()方法和onTouchEvent()将事件委托给ViewDragHelper去处理,这样ViewDragHelper才能根据响应的事件并回调我们自己编写的Callback接口来进行响应的处理, 由于ViewDragHelper中的滑动是交给Srcoller类来处理的所以这里我们要重写computeScroll()方法,配合Scroller完成滚动动画. 最后在onFinishInflate()里获取到我们的View对象即可. 3. 类关系图由于就一个类类图我们就不画了,但是作为一个强迫症患者,这个标题必须有… 4. 源码分析4.1 ViewDragHelper.Callback的实现在分析ViewDragHelper之前,我们先来分析一下Callback的定义,看看Callback都定义了哪些方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public static abstract class Callback &#123; //当View的拖拽状态改变时回调,state为STATE_IDLE,STATE_DRAGGING,STATE_SETTLING的一种 //STATE_IDLE: 当前未被拖拽 //STATE_DRAGGING：正在被拖拽 //STATE_SETTLING: 被拖拽后需要被安放到一个位置中的状态 public void onViewDragStateChanged(int state) &#123;&#125; //当View被拖拽位置发生改变时回调 //changedView ：被拖拽的View //left : 被拖拽后View的left边缘坐标 //top : 被拖拽后View的top边缘坐标 //dx : 拖动的x偏移量 //dy : 拖动的y偏移量 public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123;&#125; //当一个View被捕获到准备开始拖动时回调, //capturedChild : 捕获的View //activePointerId : 对应的PointerId public void onViewCaptured(View capturedChild, int activePointerId) &#123;&#125; //当被捕获拖拽的View被释放是回调 //releasedChild : 被释放的View //xvel : 释放View的x方向上的加速度 //yvel : 释放View的y方向上的加速度 public void onViewReleased(View releasedChild, float xvel, float yvel) &#123;&#125; //如果parentView订阅了边缘触摸,则如果有边缘触摸就回调的接口 //edgeFlags : 当前触摸的flag 有: EDGE_LEFT,EDGE_TOP,EDGE_RIGHT,EDGE_BOTTOM //pointerId : 用来描述边缘触摸操作的id public void onEdgeTouched(int edgeFlags, int pointerId) &#123;&#125; //是否锁定该边缘的触摸,默认返回false,返回true表示锁定 public boolean onEdgeLock(int edgeFlags) &#123; return false; &#125; //边缘触摸开始时回调 //edgeFlags : 当前触摸的flag 有: EDGE_LEFT,EDGE_TOP,EDGE_RIGHT,EDGE_BOTTOM //pointerId : 用来描述边缘触摸操作的id public void onEdgeDragStarted(int edgeFlags, int pointerId) &#123;&#125; //在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给tryCaptureViewForDrag()来尝试捕获。 //如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。 public int getOrderedChildIndex(int index) &#123; return index; &#125; //获取被拖拽View child 的水平拖拽范围,返回0表示无法被水平拖拽 public int getViewHorizontalDragRange(View child) &#123; return 0; &#125; //获取被拖拽View child 的垂直拖拽范围,返回0表示无法被水平拖拽 public int getViewVerticalDragRange(View child) &#123; return 0; &#125; //尝试捕获被拖拽的View public abstract boolean tryCaptureView(View child, int pointerId); //决定拖拽View在水平方向上应该移动到的位置 //child : 被拖拽的View //left : 期望移动到位置的View的left值 //dx : 移动的水平距离 //返回值 : 直接决定View在水平方向的位置 public int clampViewPositionHorizontal(View child, int left, int dx) &#123; return 0; &#125; //决定拖拽View在垂直方向上应该移动到的位置 //child : 被拖拽的View //top : 期望移动到位置的View的top值 //dy : 移动的垂直距离 //返回值 : 直接决定View在垂直方向的位置 public int clampViewPositionVertical(View child, int top, int dy) &#123; return 0; &#125;&#125; 想必注释已经很清楚了,正是这些回调方法,再结合ViewDragHelper中的各种方法,来帮助我们实现各种各样的拖拽的效果。 4.2 shouldInterceptTouchEvent()方法的实现在这里我们假设大家都清楚了Android的事件分发机制,如果不清楚请看这里,要想处理触摸事件,我们需要在onInterceptTouchEvent(MotionEvent ev)方法里判断是否需要拦截这次触摸事件,如果此方法返回true则触摸事件将会交给onTouchEvent(MotionEvent event)处理,这样我们就能处理触摸事件了,所以我们在上面的使用方法里会这样写: 1234567891011@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragger.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mDragger.processTouchEvent(event); return true;&#125; 这样就将是否拦截触摸事件,以及处理触摸事件委托给ViewDragHelper来处理了,所以我们先来看看ViewDragHelper中shouldInterceptTouchEvent();方法的实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public boolean shouldInterceptTouchEvent(MotionEvent ev) &#123; //获取action final int action = MotionEventCompat.getActionMasked(ev); //获取action对应的index final int actionIndex = MotionEventCompat.getActionIndex(ev); //如果是按下的action则重置一些信息,包括各种事件点的数组 if (action == MotionEvent.ACTION_DOWN) &#123; // Reset things for a new event stream, just in case we didn't get // the whole previous stream. cancel(); &#125; //初始化mVelocityTracker if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(ev); //根据action来做相应的处理 switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; final float x = ev.getX(); final float y = ev.getY(); //获取这个事件对应的pointerId,一般情况下只有一个手指触摸时为0 //两个手指触摸时第二个手指触摸返回的pointerId为1，以此类推 final int pointerId = MotionEventCompat.getPointerId(ev, 0); //保存点的数据 //TODO (1) saveInitialMotion(x, y, pointerId); //获取当前触摸点下最顶层的子View //TODO (2) final View toCapture = findTopChildUnder((int) x, (int) y); //如果toCapture是已经捕获的View,而且正在处于被释放状态 //那么就重新捕获 if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123; tryCaptureViewForDrag(toCapture, pointerId); &#125; //如果触摸了边缘,回调callback的onEdgeTouched()方法 final int edgesTouched = mInitialEdgesTouched[pointerId]; if ((edgesTouched &amp; mTrackingEdges) != 0) &#123; mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId); &#125; break; &#125; //当又有一个手指触摸时 case MotionEventCompat.ACTION_POINTER_DOWN: &#123; final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex); final float x = MotionEventCompat.getX(ev, actionIndex); final float y = MotionEventCompat.getY(ev, actionIndex); //保存触摸信息 saveInitialMotion(x, y, pointerId); //因为同一时间ViewDragHelper只能操控一个View,所以当有新的手指触摸时 //只讨论当无触摸发生时,回调边缘触摸的callback //或者正在处于释放状态时重新捕获View if (mDragState == STATE_IDLE) &#123; final int edgesTouched = mInitialEdgesTouched[pointerId]; if ((edgesTouched &amp; mTrackingEdges) != 0) &#123; mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId); &#125; &#125; else if (mDragState == STATE_SETTLING) &#123; // Catch a settling view if possible. final View toCapture = findTopChildUnder((int) x, (int) y); if (toCapture == mCapturedView) &#123; tryCaptureViewForDrag(toCapture, pointerId); &#125; &#125; break; &#125; //当手指移动时 case MotionEvent.ACTION_MOVE: &#123; if (mInitialMotionX == null || mInitialMotionY == null) break; // First to cross a touch slop over a draggable view wins. Also report edge drags. //得到触摸点的数量,并循环处理,只处理第一个发生了拖拽的事件 final int pointerCount = MotionEventCompat.getPointerCount(ev); for (int i = 0; i &lt; pointerCount; i++) &#123; final int pointerId = MotionEventCompat.getPointerId(ev, i); final float x = MotionEventCompat.getX(ev, i); final float y = MotionEventCompat.getY(ev, i); //获得拖拽偏移量 final float dx = x - mInitialMotionX[pointerId]; final float dy = y - mInitialMotionY[pointerId]; //获取当前触摸点下最顶层的子View final View toCapture = findTopChildUnder((int) x, (int) y); //如果找到了最顶层View,并且产生了拖动(checkTouchSlop()返回true) //TODO (3) final boolean pastSlop = toCapture != null &amp;&amp; checkTouchSlop(toCapture, dx, dy); if (pastSlop) &#123; //根据callback的四个方法getView[Horizontal|Vertical]DragRange和 //clampViewPosition[Horizontal|Vertical]来检查是否可以拖动 final int oldLeft = toCapture.getLeft(); final int targetLeft = oldLeft + (int) dx; final int newLeft = mCallback.clampViewPositionHorizontal(toCapture, targetLeft, (int) dx); final int oldTop = toCapture.getTop(); final int targetTop = oldTop + (int) dy; final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop, (int) dy); final int horizontalDragRange = mCallback.getViewHorizontalDragRange( toCapture); final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture); //如果都不允许移动则跳出循环 if ((horizontalDragRange == 0 || horizontalDragRange &gt; 0 &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == 0 || verticalDragRange &gt; 0 &amp;&amp; newTop == oldTop)) &#123; break; &#125; &#125; //记录并回调是否有边缘触摸 reportNewEdgeDrags(dx, dy, pointerId); if (mDragState == STATE_DRAGGING) &#123; // Callback might have started an edge drag break; &#125; //如果产生了拖动则调用tryCaptureViewForDrag() //TODO (4) if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123; break; &#125; &#125; //保存触摸点的信息 saveLastMotion(ev); break; &#125; //当有一个手指抬起时,清除这个手指的触摸数据 case MotionEventCompat.ACTION_POINTER_UP: &#123; final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex); clearMotionHistory(pointerId); break; &#125; //清除所有触摸数据 case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: &#123; cancel(); break; &#125; &#125; //如果mDragState等于正在拖拽则返回true return mDragState == STATE_DRAGGING;&#125; 上面就是整个shouldInterceptTouchEvent()的实现,上面的注释也足够清楚了,我们这里就先不分析某一种触摸事件,大家可以看到我上面留了几个TODO,下文会一起分析,这里我假设大家都已经对触摸事件分发处理都有充分的理解了,我们下面就直接看ViewDragHelper里processTouchEvent()方法的实现. 4.3 processTouchEvent()方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public void processTouchEvent(MotionEvent ev) &#123; final int action = MotionEventCompat.getActionMasked(ev); final int actionIndex = MotionEventCompat.getActionIndex(ev); ...（省去部分代码） switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; ...（省去部分代码） break; &#125; case MotionEventCompat.ACTION_POINTER_DOWN: &#123; ...（省去部分代码） break; &#125; case MotionEvent.ACTION_MOVE: &#123; //如果现在已经是拖拽状态 if (mDragState == STATE_DRAGGING) &#123; final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId); final float x = MotionEventCompat.getX(ev, index); final float y = MotionEventCompat.getY(ev, index); final int idx = (int) (x - mLastMotionX[mActivePointerId]); final int idy = (int) (y - mLastMotionY[mActivePointerId]); //拖拽至指定位置 //TODO (5) dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy); saveLastMotion(ev); &#125; else &#123; // Check to see if any pointer is now over a draggable view. //如果还不是拖拽状态,就检测是否经过了一个View final int pointerCount = MotionEventCompat.getPointerCount(ev); for (int i = 0; i &lt; pointerCount; i++) &#123; final int pointerId = MotionEventCompat.getPointerId(ev, i); final float x = MotionEventCompat.getX(ev, i); final float y = MotionEventCompat.getY(ev, i); final float dx = x - mInitialMotionX[pointerId]; final float dy = y - mInitialMotionY[pointerId]; reportNewEdgeDrags(dx, dy, pointerId); if (mDragState == STATE_DRAGGING) &#123; // Callback might have started an edge drag. break; &#125; final View toCapture = findTopChildUnder((int) x, (int) y); if (checkTouchSlop(toCapture, dx, dy) &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123; break; &#125; &#125; saveLastMotion(ev); &#125; break; &#125; //当多个手指中的一个手机松开时 case MotionEventCompat.ACTION_POINTER_UP: &#123; final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex); //如果当前点正在被拖拽,则再剩余还在触摸的点钟寻找是否正在View上 if (mDragState == STATE_DRAGGING &amp;&amp; pointerId == mActivePointerId) &#123; // Try to find another pointer that's still holding on to the captured view. int newActivePointer = INVALID_POINTER; final int pointerCount = MotionEventCompat.getPointerCount(ev); for (int i = 0; i &lt; pointerCount; i++) &#123; final int id = MotionEventCompat.getPointerId(ev, i); if (id == mActivePointerId) &#123; // This one's going away, skip. continue; &#125; final float x = MotionEventCompat.getX(ev, i); final float y = MotionEventCompat.getY(ev, i); if (findTopChildUnder((int) x, (int) y) == mCapturedView &amp;&amp; tryCaptureViewForDrag(mCapturedView, id)) &#123; newActivePointer = mActivePointerId; break; &#125; &#125; if (newActivePointer == INVALID_POINTER) &#123; // We didn't find another pointer still touching the view, release it. //如果没找到则释放View //TODO (6) releaseViewForPointerUp(); &#125; &#125; clearMotionHistory(pointerId); break; &#125; case MotionEvent.ACTION_UP: &#123; //如果是拖拽状态的释放则调用 //releaseViewForPointerUp() if (mDragState == STATE_DRAGGING) &#123; releaseViewForPointerUp(); &#125; cancel(); break; &#125; case MotionEvent.ACTION_CANCEL: &#123; if (mDragState == STATE_DRAGGING) &#123; dispatchViewReleased(0, 0); &#125; cancel(); break; &#125; &#125;&#125; 上面就是processTouchEvent()方法的实现,我们省去了部分大致与shouldInterceptTouchEvent()相同的逻辑代码,通过事件传递机制我们知道,如果程序已经进入到processTouchEvent()中,也就意味着触摸事件就不会再向下传递,都会交给此方法处理,所以在这里我们就需要处理拖拽事件了,通过上面的注释,我们也看到了在MotionEvent.ACTION_MOVE,MotionEventCompat.ACTION_POINTER_UP,MotionEvent.ACTION_UP和MotionEvent.ACTION_CANCEL都分别进行了处理 ,我们知道触摸事件大致的流程是: ACTION_DOWN -&gt; ACTION_MOVE -&gt; ... -&gt; ACTION_MOVE -&gt; ACTION_UP 再配合事件的分发机制,我们就能很清晰的分析出一次完整的事件调用过程,所以整个ViewDragHelper的拖拽过程也能很清晰的分为三个步骤: 捕获拖拽目标View -&gt; 拖拽目标View -&gt; 处理目标View释放操作 最后我们再分析上面两段代码的6个TODO: 4.4 saveInitialMotion()方法123456789101112private void saveInitialMotion(float x, float y, int pointerId) &#123; //确保各个数组的大小足够存放数据 ensureMotionHistorySizeForId(pointerId); //保存x坐标 mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x; //保存y坐标 mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y; //保存是否触摸到边缘 mInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y); //保存当前id是否在触摸,用于后续验证 mPointersDown |= 1 &lt;&lt; pointerId;&#125; 4.5 findTopChildUnder()方法1234567891011public View findTopChildUnder(int x, int y) &#123; final int childCount = mParentView.getChildCount(); for (int i = childCount - 1; i &gt;= 0; i--) &#123; final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i)); if (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp; y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123; return child; &#125; &#125; return null;&#125; 代码很简单就是根据x和y坐标和来找到指定View,注意这里回调了callback中的getOrderedChildIndex()方法,所以我们可以在这里返回指定的View的index. 4.6 checkTouchSlop()方法12345678910111213141516private boolean checkTouchSlop(View child, float dx, float dy) &#123; if (child == null) &#123; return false; &#125; final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; 0; final boolean checkVertical = mCallback.getViewVerticalDragRange(child) &gt; 0; if (checkHorizontal &amp;&amp; checkVertical) &#123; return dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop; &#125; else if (checkHorizontal) &#123; return Math.abs(dx) &gt; mTouchSlop; &#125; else if (checkVertical) &#123; return Math.abs(dy) &gt; mTouchSlop; &#125; return false;&#125; 用来根据mTouchSlop最小拖动的距离来判断是否属于拖动,mTouchSlop根据我们设定的灵敏度决定. 4.7 tryCaptureViewForDrag()方法12345678910111213141516boolean tryCaptureViewForDrag(View toCapture, int pointerId) &#123; //如果已经捕获该View 直接返回true if (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123; // Already done! return true; &#125; //根据mCallback.tryCaptureView()方法来最终决定是否可以捕获View if (toCapture != null &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123; mActivePointerId = pointerId; //如果可以则调用captureChildView(),并返回true captureChildView(toCapture, pointerId); return true; &#125; return false;&#125; 可以看到如果可以捕获View则调用了captureChildView()方法: 1234567891011121314public void captureChildView(View childView, int activePointerId) &#123; if (childView.getParent() != mParentView) &#123; throw new IllegalArgumentException(\"captureChildView: parameter must be a descendant \" + \"of the ViewDragHelper's tracked parent view (\" + mParentView + \")\"); &#125; //赋值mCapturedView mCapturedView = childView; mActivePointerId = activePointerId; //回调callback mCallback.onViewCaptured(childView, activePointerId); //设定mDragState的状态为STATE_DRAGGING setDragState(STATE_DRAGGING);&#125; 如果程序执行到这里,就证明View已经处于拖拽状态了,后续的触摸操作,将直接根据mDragState为STATE_DRAGGING的状态处理. 4.8 dragTo()方法的实现123456789101112131415161718192021222324252627private void dragTo(int left, int top, int dx, int dy) &#123; int clampedX = left; int clampedY = top; final int oldLeft = mCapturedView.getLeft(); final int oldTop = mCapturedView.getTop(); if (dx != 0) &#123; //回调callback来决定View最终被拖拽的x方向上的偏移量 clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx); //移动View ViewCompat.offsetLeftAndRight(mCapturedView, clampedX - oldLeft); &#125; if (dy != 0) &#123; //回调callback来决定View最终被拖拽的y方向上的偏移量 clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy); //移动View ViewCompat.offsetTopAndBottom(mCapturedView, clampedY - oldTop); &#125; if (dx != 0 || dy != 0) &#123; final int clampedDx = clampedX - oldLeft; final int clampedDy = clampedY - oldTop; //回调callback mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY, clampedDx, clampedDy); &#125;&#125; 因为dragTo()方法是在processTouchEvent()中的MotionEvent.ACTION_MOVE case被调用所以当程序运行到这里时View就会不断的被拖动了。如果一旦手指释放则最终会调用releaseViewForPointerUp()方法 4.8 releaseViewForPointerUp()方法的实现123456789101112private void releaseViewForPointerUp() &#123; //计算出当前x和y方向上的加速度 mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity); final float xvel = clampMag( VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId), mMinVelocity, mMaxVelocity); final float yvel = clampMag( VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId), mMinVelocity, mMaxVelocity); dispatchViewReleased(xvel, yvel);&#125; 计算完加速度后就调用了dispatchViewReleased(): 123456789101112131415private void dispatchViewReleased(float xvel, float yvel) &#123; //设定当前正处于释放阶段 mReleaseInProgress = true; //回调callback的onViewReleased()方法 mCallback.onViewReleased(mCapturedView, xvel, yvel); mReleaseInProgress = false; //设定状态 if (mDragState == STATE_DRAGGING) &#123; // onViewReleased didn't call a method that would have changed this. Go idle. //如果onViewReleased()中没有调用任何方法,则状态设定为STATE_IDLE setDragState(STATE_IDLE); &#125;&#125; 所以最后释放后的处理交给了callback中的onViewReleased()方法,如果我们什么都不做,那么这个被拖拽的View就是停止在当前位置,或者我们可以调用ViewDragHelper提供给我们的这几个方法: settleCapturedViewAt(int finalLeft, int finalTop)以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在Callback的onViewReleased()中调用。 flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在Callback的onViewReleased()中调用。 smoothSlideViewTo(View child, int finalLeft, int finalTop)指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。 引用自这篇文章,具体释放后的原理我们就不分析了,其实就是配合Scroller这个类来实现,具体也可以参照上面这篇文章。好,我们关于ViewDragHelper的源码分析就到这里. 5. 开源项目中的使用ViewDragHelper在各种关于拖拽和各种手势动画的开源库中使用广泛,我这里就简要列出一些,大家可以多去看看是如何使用ViewDragHelper的: SwipeBackLayout android-card-slide-panel FlowingDrawer 6. 个人评价ViewDragHelper的出现,大大简化了我们开发相关触摸和拖拽功能的复杂度和代码量,帮助我们比较容易的实现各种效果,让我们开发酷炫的交互更加容易了。但是从一些开源项目中发现,ViewDragHelper中还是有一些不足之处,比如给Scroller提供了一个固定的Interpolator,导致如果我们想实现例如反弹效果的话,还要把ViewDragHelper的代码拷贝一份并修改Interpolator,这样做肯定是不太好的.当然建议我们自己修改一个ViewDragHelper后如果项目里有多处使用,可以包装成一个提供给我们自己项目的模块使用,防止出现更多的多余代码 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"TextView源码解析","date":"2017-07-26T12:07:19.000Z","path":"2017/07/26/TextView源码解析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 TextView源码解析1.简介 TextView作为Android系统上显示和排版文字以及提供对文字的增删改查、图文混排等功能的控件，内部是相对比较复杂的。这么一个复杂的控件自然需要依赖于一些其他的辅助类，例如：Layout以及Layout的相关子类、Span相关的类、MovementMethod接口、TransformationMethod接口等。这篇文章主要介绍TextView的结构和内部处理文字的流程以及TextView相关的辅助类在TextView处理文字过程中的作用。 2.TextView的内部结构和辅助类TextView内部除了继承自View的相关属性和measure、layout、draw步骤，还包括： Layout: TextView的文字排版、折行策略以及文本绘制都是在Layout里面完成的，TextView的自身测量也受Layout的影响。Layout是TextView执行setText方法后，由TextView内部创建的实例，并不能由外部提供。可以用getLayout()方法获取。 TransformationMethod: 用来处理最终的显示结果的类，例如显示密码的时候把密码转换成圆点。这个类并不直接影响TextView内部储存的Text，只影响显示的结果。 MovementMethod: 用来处理TextView内部事件响应的类，可以针对TextView内文本的某一个区域做软键盘输入或者触摸事件的响应。 Drawables: TextView的静态内部类，用来处理和储存TextView的CompoundDrawables,包括TextView的上下左右的Drawable以及错误提示的Drawable。 Spans: Spans并不是特定的某一个类或者实现了某一个接口的类。它可以是任意类型，Spans实际上做的事情是在TextView的内部的text的某一个区域做标记。其中有部分Spans可以影响TextView的绘制和测量，如ImageSpan、BackgroundColorSpan、AbsoluteSizeSpan。还有可以响应点击事件的ClickableSpan。 Editor: TextView作为可编辑文本控件的时候(EditText)，使用Editor来处理文本的区域选择处理和判断、拼写检查、弹出文本菜单等。 InputConnection: EditText的文本输入部分是在TextView中完成的。而InputConnection是软键盘和TextView之间的桥梁，所有的软键盘的输入文字、修改文字和删除文字都是通过InputConnection传递给TextView的。 3.TextView的onTouchEvent处理TextView内部能处理触摸事件的，包括自身的触摸处理、Editor的onTouchEvent、MovementMethod的onTouchEvent。Editor的onTouchEvent主要处理出于编辑状态下的触摸事件，比如点击选中、长按等。MovementMethod则主要负责文本内部有Span的时候的相关处理，比较常见的就是LinkMovementMethod处理ClickableSpan的点击事件。我们来看一下TextView内部对这些触摸事件的处理和优先级的分配： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public boolean onTouchEvent(MotionEvent event) &#123; final int action = event.getActionMasked(); //当Editor不为空的时候，给Editor的双击事件预设值 if (mEditor != null &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123; if (mFirstTouch &amp;&amp; (SystemClock.uptimeMillis() - mLastTouchUpTime) &lt;= ViewConfiguration.getDoubleTapTimeout()) &#123; mEditor.mDoubleTap = true; mFirstTouch = false; &#125; else &#123; mEditor.mDoubleTap = false; mFirstTouch = true; &#125; &#125; if (action == MotionEvent.ACTION_UP) &#123; mLastTouchUpTime = SystemClock.uptimeMillis(); &#125; //当Editor不为空，优先处理Editor的触摸事件 if (mEditor != null) &#123; mEditor.onTouchEvent(event); //由于Editor内部onTouchEvent实际上交给了mSelectionModifierCursorController处理，所以这边判断mSelectionModifierCursorController是否需要处理接下来的一系列事件，如果是则直接返回跳过下面的步骤 if (mEditor.mSelectionModifierCursorController != null &amp;&amp; mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) &#123; return true; &#125; &#125; final boolean superResult = super.onTouchEvent(event); //处理API 23新加入的InsertionActinoMode if (mEditor != null &amp;&amp; mEditor.mDiscardNextActionUp &amp;&amp; action == MotionEvent.ACTION_UP) &#123; mEditor.mDiscardNextActionUp = false; if (mEditor.mIsInsertionActionModeStartPending) &#123; mEditor.startInsertionActionMode(); mEditor.mIsInsertionActionModeStartPending = false; &#125; return superResult; &#125; final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) &amp;&amp; (mEditor == null || !mEditor.mIgnoreActionUpEvent) &amp;&amp; isFocused(); if ((mMovement != null || onCheckIsTextEditor()) &amp;&amp; isEnabled() &amp;&amp; mText instanceof Spannable &amp;&amp; mLayout != null) &#123; boolean handled = false; //MovementMethod的触摸时间处理，如果MovementMethod类型是LinkMovementMethod则会处理文本内的所有ClickableSpan的点击 if (mMovement != null) &#123; handled |= mMovement.onTouchEvent(this, (Spannable) mText, event); &#125; final boolean textIsSelectable = isTextSelectable(); if (touchIsFinished &amp;&amp; mLinksClickable &amp;&amp; mAutoLinkMask != 0 &amp;&amp; textIsSelectable) &#123; //在文本可选择的情况下，默认是没有LinkMovementMethod来处理ClickableSpan相关的点击的，所以在文本可选择情况，TextView对所有的ClickableSpan进行统一处理 ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class); if (links.length &gt; 0) &#123; links[0].onClick(this); handled = true; &#125; &#125; if (touchIsFinished &amp;&amp; (isTextEditable() || textIsSelectable)) &#123; final InputMethodManager imm = InputMethodManager.peekInstance(); viewClicked(imm); if (!textIsSelectable &amp;&amp; mEditor.mShowSoftInputOnFocus) &#123; handled |= imm != null &amp;&amp; imm.showSoftInput(this, 0); &#125; mEditor.onTouchUpEvent(event); handled = true; &#125; if (handled) &#123; return true; &#125; &#125; return superResult; &#125; 4.TextView的创建Layout的过程TextView内部并不仅仅只有一个用来显示文本内容的Layout，在设置了hint的时候，还需要有一个mHintLayout来处理hint的内容。如果设置了Ellipsize类型为Marquee时，还会有一个mSavedMarqueeModeLayout专门用来显示marquee效果。这些Layout都是通过内部的makeNewLayout方法来创建的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138protected void makeNewLayout(int wantWidth, int hintWidth BoringLayout.Metrics boring, BoringLayout.Metrics hintBoring, int ellipsisWidth, boolean bringIntoView) &#123; //如果当前有marquee动画，则先停止动画 stopMarquee(); mOldMaximum = mMaximum; mOldMaxMode = mMaxMode; mHighlightPathBogus = true; if (wantWidth &lt; 0) &#123; wantWidth = 0; &#125; if (hintWidth &lt; 0) &#123; hintWidth = 0; &#125; //文本对齐方式 Layout.Alignment alignment = getLayoutAlignment(); final boolean testDirChange = mSingleLine &amp;&amp; mLayout != null &amp;&amp; (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE); int oldDir = 0; if (testDirChange) oldDir = mLayout.getParagraphDirection(0); //检测是否设置了ellipsize boolean shouldEllipsize = mEllipsize != null &amp;&amp; getKeyListener() == null; final boolean switchEllipsize = mEllipsize == TruncateAt.MARQUEE &amp;&amp; mMarqueeFadeMode != MARQUEE_FADE_NORMAL; TruncateAt effectiveEllipsize = mEllipsize; if (mEllipsize == TruncateAt.MARQUEE &amp;&amp; mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) &#123; effectiveEllipsize = TruncateAt.END_SMALL; &#125; //文本方向 if (mTextDir == null) &#123; mTextDir = getTextDirectionHeuristic(); &#125; //创建主Layout mLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, effectiveEllipsize == mEllipsize); //非常规的Marquee模式下，需要创建mSavedMarqueeModeLayout来保存marquee动画时所用的Layout，并且在动画期间把它和TextView的主Layout对换 if (switchEllipsize) &#123; TruncateAt oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE; mSavedMarqueeModeLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, oppositeEllipsize, effectiveEllipsize != mEllipsize); &#125; shouldEllipsize = mEllipsize != null; mHintLayout = null; //判断是否需要创建hintLayout if (mHint != null) &#123; if (shouldEllipsize) hintWidth = wantWidth; if (hintBoring == UNKNOWN_BORING) &#123; hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir, mHintBoring); if (hintBoring != null) &#123; mHintBoring = hintBoring; &#125; &#125; //判断是否为boring，如果是则创建BoringLayout if (hintBoring != null) &#123; if (hintBoring.width &lt;= hintWidth &amp;&amp; (!shouldEllipsize || hintBoring.width &lt;= ellipsisWidth)) &#123; if (mSavedHintLayout != null) &#123; mHintLayout = mSavedHintLayout. replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad); &#125; else &#123; mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad); &#125; mSavedHintLayout = (BoringLayout) mHintLayout; &#125; else if (shouldEllipsize &amp;&amp; hintBoring.width &lt;= hintWidth) &#123; if (mSavedHintLayout != null) &#123; mHintLayout = mSavedHintLayout. replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth); &#125; else &#123; mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth); &#125; &#125; &#125; //不是boring的状态下，用StaticLayout来创建 if (mHintLayout == null) &#123; StaticLayout.Builder builder = StaticLayout.Builder.obtain(mHint, 0, mHint.length(), mTextPaint, hintWidth) .setAlignment(alignment) .setTextDirection(mTextDir) .setLineSpacing(mSpacingAdd, mSpacingMult) .setIncludePad(mIncludePad) .setBreakStrategy(mBreakStrategy) .setHyphenationFrequency(mHyphenationFrequency); if (shouldEllipsize) &#123; builder.setEllipsize(mEllipsize) .setEllipsizedWidth(ellipsisWidth) .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE); &#125; mHintLayout = builder.build(); &#125; &#125; if (bringIntoView || (testDirChange &amp;&amp; oldDir != mLayout.getParagraphDirection(0))) &#123; registerForPreDraw(); &#125; //判断是否需要开始Marquee动画 if (mEllipsize == TextUtils.TruncateAt.MARQUEE) &#123; if (!compressText(ellipsisWidth)) &#123; final int height = mLayoutParams.height; if (height != LayoutParams.WRAP_CONTENT &amp;&amp; height != LayoutParams.MATCH_PARENT) &#123; startMarquee(); &#125; else &#123; mRestartMarquee = true; &#125; &#125; &#125; if (mEditor != null) mEditor.prepareCursorControllers(); &#125; TextView的布局创建过程涉及到一个boring的概念，boring是指布局所用的文本里面不包含任何Span，所有的文本方向都是从左到右的布局，并且仅需一行就能显示完全的布局。这种情况下，TextView会使用BoringLayout类来创建相关的布局，以节省不必要的文本测量以及文本折行、Span宽度、文本方向等的计算。下面我们来看一下makeNewLayout中使用频率比较高的makeSingleLayout的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Layout makeSingleLayout(int wantWidth, BoringLayout.Metrics boring, int ellipsisWidth, Layout.Alignment alignment, boolean shouldEllipsize, TruncateAt effectiveEllipsize, boolean useSaved) &#123; Layout result = null; //判断是否Spannable，如果是则用DynamicLayout类来创建布局，DynamicLayout内部实际也是使用StaticLayout来做文本的测量绘制，并在StaticLayout的基础上增加了文本或者Span改变时的监听，及时对文本或者Span的变化做出反应。 if (mText instanceof Spannable) &#123; result = new DynamicLayout(mText, mTransformed, mTextPaint, wantWidth, alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad, mBreakStrategy, mHyphenationFrequency, getKeyListener() == null ? effectiveEllipsize : null, ellipsisWidth); &#125; else &#123; //如果boring是未知状态，则重新判断一次是否boring if (boring == UNKNOWN_BORING) &#123; boring = BoringLayout.isBoring(mTransformed, mTextPaint, mTextDir, mBoring); if (boring != null) &#123; mBoring = boring; &#125; &#125; //根据boring的属性来创建对应的布局，如果有mSavedLayout则从mSavedLayout创建 if (boring != null) &#123; if (boring.width &lt;= wantWidth &amp;&amp; (effectiveEllipsize == null || boring.width &lt;= ellipsisWidth)) &#123; if (useSaved &amp;&amp; mSavedLayout != null) &#123; //从之前保存的Layout中创建 result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad); &#125; else &#123; //创建新的Layout result = BoringLayout.make(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad); &#125; if (useSaved) &#123; mSavedLayout = (BoringLayout) result; &#125; &#125; else if (shouldEllipsize &amp;&amp; boring.width &lt;= wantWidth) &#123; if (useSaved &amp;&amp; mSavedLayout != null) &#123; result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad, effectiveEllipsize, ellipsisWidth); &#125; else &#123; result = BoringLayout.make(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad, effectiveEllipsize, ellipsisWidth); &#125; &#125; &#125; &#125; //如果没有创建BoringLayout, 则使用StaticLayout类来创建布局 if (result == null) &#123; StaticLayout.Builder builder = StaticLayout.Builder.obtain(mTransformed, 0, mTransformed.length(), mTextPaint, wantWidth) .setAlignment(alignment) .setTextDirection(mTextDir) .setLineSpacing(mSpacingAdd, mSpacingMult) .setIncludePad(mIncludePad) .setBreakStrategy(mBreakStrategy) .setHyphenationFrequency(mHyphenationFrequency); if (shouldEllipsize) &#123; builder.setEllipsize(effectiveEllipsize) .setEllipsizedWidth(ellipsisWidth) .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE); &#125; result = builder.build(); &#125; return result; &#125; 5.TextView的文字处理和绘制TextView主要的文字排版和渲染并不是在TextView里面完成的，而是由Layout类来处理文字排版工作。在单纯地使用TextView来展示静态文本的时候，这件事情则是由Layout的子类StaticLayout来完成的。 StaticLayout接收到字符串后，首先做的事情是根据字符串里面的换行符对字符串进行拆分。 123456for (int paraStart = bufStart; paraStart &lt;= bufEnd; paraStart = paraEnd) &#123; paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd); if (paraEnd &lt; 0) paraEnd = bufEnd; else paraEnd++; 拆分后的段落(Paragraph)被分配给辅助类MeasuredText进行测量得到每个字符的宽度以及每个段落的FontMetric。并通过LineBreaker进行折行的判断 1234567//把段落载入到MeasuredText中，并分配对应的缓存空间measured.setPara(source, paraStart, paraEnd, textDir, b); char[] chs = measured.mChars; float[] widths = measured.mWidths; byte[] chdirs = measured.mLevels; int dir = measured.mDir; boolean easy = measured.mEasy; //把相关属性传给JNI层的LineBreaker nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int fmCacheCount = 0;int spanEndCacheCount = 0;for (int spanStart = paraStart, spanEnd; spanStart &lt; paraEnd; spanStart = spanEnd) &#123; if (fmCacheCount * 4 &gt;= fmCache.length) &#123; int[] grow = new int[fmCacheCount * 4 * 2]; System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4); fmCache = grow; &#125; if (spanEndCacheCount &gt;= spanEndCache.length) &#123; int[] grow = new int[spanEndCacheCount * 2]; System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount); spanEndCache = grow; &#125; if (spanned == null) &#123; spanEnd = paraEnd; int spanLen = spanEnd - spanStart; //段落没有Span的情况下，把整个段落交给MeasuredText计算每个字符的宽度和FontMetric measured.addStyleRun(paint, spanLen, fm); &#125; else &#123; spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class); int spanLen = spanEnd - spanStart; MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class); spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class); //把对排版有影响的Span交给MeasuredText测量宽度并计算FontMetric measured.addStyleRun(paint, spans, spanLen, fm); &#125; //把测量后的FontMetric缓存下来方便后面使用 fmCache[fmCacheCount * 4 + 0] = fm.top; fmCache[fmCacheCount * 4 + 1] = fm.bottom; fmCache[fmCacheCount * 4 + 2] = fm.ascent; fmCache[fmCacheCount * 4 + 3] = fm.descent; fmCacheCount++; spanEndCache[spanEndCacheCount] = spanEnd; spanEndCacheCount++;&#125;nGetWidths(b.mNativePtr, widths);//计算段落中需要折行的位置，并返回折行的数量int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length); 计算完每一行的测量相关信息、Span宽高以及折行位置，就可以开始按照最终的行数一行一行地保存下来，以供后面绘制和获取对应文本信息的时候使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657for (int spanStart = paraStart, spanEnd; spanStart &lt; paraEnd; spanStart = spanEnd) &#123; spanEnd = spanEndCache[spanEndCacheIndex++]; // 获取之前缓存的FontMetric信息 fm.top = fmCache[fmCacheIndex * 4 + 0]; fm.bottom = fmCache[fmCacheIndex * 4 + 1]; fm.ascent = fmCache[fmCacheIndex * 4 + 2]; fm.descent = fmCache[fmCacheIndex * 4 + 3]; fmCacheIndex++; if (fm.top &lt; fmTop) &#123; fmTop = fm.top; &#125; if (fm.ascent &lt; fmAscent) &#123; fmAscent = fm.ascent; &#125; if (fm.descent &gt; fmDescent) &#123; fmDescent = fm.descent; &#125; if (fm.bottom &gt; fmBottom) &#123; fmBottom = fm.bottom; &#125; while (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt; spanStart) &#123; breakIndex++; &#125; while (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt;= spanEnd) &#123; int endPos = paraStart + breaks[breakIndex]; boolean moreChars = (endPos &lt; bufEnd); //逐行把相关信息储存下来 v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars); if (endPos &lt; spanEnd) &#123; fmTop = fm.top; fmBottom = fm.bottom; fmAscent = fm.ascent; fmDescent = fm.descent; &#125; else &#123; fmTop = fmBottom = fmAscent = fmDescent = 0; &#125; here = endPos; breakIndex++; if (mLineCount &gt;= mMaximumVisibleLineCount) &#123; return; &#125; &#125; &#125; 这样StaticLayout的排版过程就完成了。文本的绘制则是交给父类Layout来做的，Layout的绘制分为两大部分，drawBackground和drawText。drawBackground做的事情是如果文本内有LineBackgroundSpan则绘制所有的LineBackgroundSpan，然后判断是否有高亮背景(文本选中的背景)，如果有则绘制高亮背景。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public void drawBackground(Canvas canvas, Path highlight, Paint highlightPaint, int cursorOffsetVertical, int firstLine, int lastLine) &#123; //判断并绘制LineBackgroundSpan if (mSpannedText) &#123; if (mLineBackgroundSpans == null) &#123; mLineBackgroundSpans = new SpanSet&lt;LineBackgroundSpan&gt;(LineBackgroundSpan.class); &#125; Spanned buffer = (Spanned) mText; int textLength = buffer.length(); mLineBackgroundSpans.init(buffer, 0, textLength); if (mLineBackgroundSpans.numberOfSpans &gt; 0) &#123; int previousLineBottom = getLineTop(firstLine); int previousLineEnd = getLineStart(firstLine); ParagraphStyle[] spans = NO_PARA_SPANS; int spansLength = 0; TextPaint paint = mPaint; int spanEnd = 0; final int width = mWidth; //逐行绘制LineBackgroundSpan for (int i = firstLine; i &lt;= lastLine; i++) &#123; int start = previousLineEnd; int end = getLineStart(i + 1); previousLineEnd = end; int ltop = previousLineBottom; int lbottom = getLineTop(i + 1); previousLineBottom = lbottom; int lbaseline = lbottom - getLineDescent(i); if (start &gt;= spanEnd) &#123; spanEnd = mLineBackgroundSpans.getNextTransition(start, textLength); spansLength = 0; if (start != end || start == 0) &#123; //排除不在绘制范围内的LineBackgroundSpan for (int j = 0; j &lt; mLineBackgroundSpans.numberOfSpans; j++) &#123; if (mLineBackgroundSpans.spanStarts[j] &gt;= end || mLineBackgroundSpans.spanEnds[j] &lt;= start) continue; spans = GrowingArrayUtils.append( spans, spansLength, mLineBackgroundSpans.spans[j]); spansLength++; &#125; &#125; &#125; //对当前行内的LineBackgroundSpan进行绘制 for (int n = 0; n &lt; spansLength; n++) &#123; LineBackgroundSpan lineBackgroundSpan = (LineBackgroundSpan) spans[n]; lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i); &#125; &#125; &#125; mLineBackgroundSpans.recycle(); &#125; //判断并绘制高亮背景(即选中的文本) if (highlight != null) &#123; if (cursorOffsetVertical != 0) canvas.translate(0, cursorOffsetVertical); canvas.drawPath(highlight, highlightPaint); if (cursorOffsetVertical != 0) canvas.translate(0, -cursorOffsetVertical); &#125; &#125; drawText用来逐行绘制Layout的文本、影响显示效果的Span、以及Emoji表情等。当有Emoji或者Span的时候，实际绘制工作交给TextLine类来完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public void drawText(Canvas canvas, int firstLine, int lastLine) &#123; int previousLineBottom = getLineTop(firstLine); int previousLineEnd = getLineStart(firstLine); ParagraphStyle[] spans = NO_PARA_SPANS; int spanEnd = 0; TextPaint paint = mPaint; CharSequence buf = mText; Alignment paraAlign = mAlignment; TabStops tabStops = null; boolean tabStopsIsInitialized = false; //获取TextLine实例 TextLine tl = TextLine.obtain(); //逐行绘制文本 for (int lineNum = firstLine; lineNum &lt;= lastLine; lineNum++) &#123; int start = previousLineEnd; previousLineEnd = getLineStart(lineNum + 1); int end = getLineVisibleEnd(lineNum, start, previousLineEnd); int ltop = previousLineBottom; int lbottom = getLineTop(lineNum + 1); previousLineBottom = lbottom; int lbaseline = lbottom - getLineDescent(lineNum); int dir = getParagraphDirection(lineNum); int left = 0; int right = mWidth; if (mSpannedText) &#123; Spanned sp = (Spanned) buf; int textLength = buf.length(); //检测是否段落的第一行 boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\\n'); //获得所有的段落风格相关的Span if (start &gt;= spanEnd &amp;&amp; (lineNum == firstLine || isFirstParaLine)) &#123; spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class); spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class); paraAlign = mAlignment; for (int n = spans.length - 1; n &gt;= 0; n--) &#123; if (spans[n] instanceof AlignmentSpan) &#123; paraAlign = ((AlignmentSpan) spans[n]).getAlignment(); break; &#125; &#125; tabStopsIsInitialized = false; &#125; //获取影响行缩进的Span final int length = spans.length; boolean useFirstLineMargin = isFirstParaLine; for (int n = 0; n &lt; length; n++) &#123; if (spans[n] instanceof LeadingMarginSpan2) &#123; int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount(); int startLine = getLineForOffset(sp.getSpanStart(spans[n])); if (lineNum &lt; startLine + count) &#123; useFirstLineMargin = true; break; &#125; &#125; &#125; for (int n = 0; n &lt; length; n++) &#123; if (spans[n] instanceof LeadingMarginSpan) &#123; LeadingMarginSpan margin = (LeadingMarginSpan) spans[n]; if (dir == DIR_RIGHT_TO_LEFT) &#123; margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this); right -= margin.getLeadingMargin(useFirstLineMargin); &#125; else &#123; margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this); left += margin.getLeadingMargin(useFirstLineMargin); &#125; &#125; &#125; &#125; boolean hasTabOrEmoji = getLineContainsTab(lineNum); if (hasTabOrEmoji &amp;&amp; !tabStopsIsInitialized) &#123; if (tabStops == null) &#123; tabStops = new TabStops(TAB_INCREMENT, spans); &#125; else &#123; tabStops.reset(TAB_INCREMENT, spans); &#125; tabStopsIsInitialized = true; &#125; //判断当前行的第五方式 Alignment align = paraAlign; if (align == Alignment.ALIGN_LEFT) &#123; align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE; &#125; else if (align == Alignment.ALIGN_RIGHT) &#123; align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL; &#125; int x; if (align == Alignment.ALIGN_NORMAL) &#123; if (dir == DIR_LEFT_TO_RIGHT) &#123; x = left + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT); &#125; else &#123; x = right + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT); &#125; &#125; else &#123; int max = (int)getLineExtent(lineNum, tabStops, false); if (align == Alignment.ALIGN_OPPOSITE) &#123; if (dir == DIR_LEFT_TO_RIGHT) &#123; x = right - max + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT); &#125; else &#123; x = left - max + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT); &#125; &#125; else &#123; // Alignment.ALIGN_CENTER max = max &amp; ~1; x = ((right + left - max) &gt;&gt; 1) + getIndentAdjust(lineNum, Alignment.ALIGN_CENTER); &#125; &#125; paint.setHyphenEdit(getHyphen(lineNum)); Directions directions = getLineDirections(lineNum); if (directions == DIRS_ALL_LEFT_TO_RIGHT &amp;&amp; !mSpannedText &amp;&amp; !hasTabOrEmoji) &#123; //没有任何Emoji或者span的时候，直接调用Canvas来绘制文本 canvas.drawText(buf, start, end, x, lbaseline, paint); &#125; else &#123; //当有Emoji或者Span的时候，交给TextLine类来绘制 tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops); tl.draw(canvas, x, ltop, lbaseline, lbottom); &#125; paint.setHyphenEdit(0); &#125; TextLine.recycle(tl); &#125; 我们下面再来看看TextLine是如何绘制有特殊情况的文本的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void draw(Canvas c, float x, int top, int y, int bottom) &#123; //判断是否有Tab或者Emoji if (!mHasTabs) &#123; if (mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) &#123; drawRun(c, 0, mLen, false, x, top, y, bottom, false); return; &#125; if (mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) &#123; drawRun(c, 0, mLen, true, x, top, y, bottom, false); return; &#125; &#125; float h = 0; int[] runs = mDirections.mDirections; RectF emojiRect = null; int lastRunIndex = runs.length - 2; //逐个绘制 for (int i = 0; i &lt; runs.length; i += 2) &#123; int runStart = runs[i]; int runLimit = runStart + (runs[i+1] &amp; Layout.RUN_LENGTH_MASK); if (runLimit &gt; mLen) &#123; runLimit = mLen; &#125; boolean runIsRtl = (runs[i+1] &amp; Layout.RUN_RTL_FLAG) != 0; int segstart = runStart; for (int j = mHasTabs ? runStart : runLimit; j &lt;= runLimit; j++) &#123; int codept = 0; Bitmap bm = null; if (mHasTabs &amp;&amp; j &lt; runLimit) &#123; codept = mChars[j]; if (codept &gt;= 0xd800 &amp;&amp; codept &lt; 0xdc00 &amp;&amp; j + 1 &lt; runLimit) &#123; codept = Character.codePointAt(mChars, j); if (codept &gt;= Layout.MIN_EMOJI &amp;&amp; codept &lt;= Layout.MAX_EMOJI) &#123; //获取Emoji对应的图像 bm = Layout.EMOJI_FACTORY.getBitmapFromAndroidPua(codept); &#125; else if (codept &gt; 0xffff) &#123; ++j; continue; &#125; &#125; &#125; if (j == runLimit || codept == '\\t' || bm != null) &#123; //绘制文字 h += drawRun(c, segstart, j, runIsRtl, x+h, top, y, bottom, i != lastRunIndex || j != mLen); if (codept == '\\t') &#123; h = mDir * nextTab(h * mDir); &#125; else if (bm != null) &#123; float bmAscent = ascent(j); float bitmapHeight = bm.getHeight(); float scale = -bmAscent / bitmapHeight; float width = bm.getWidth() * scale; if (emojiRect == null) &#123; emojiRect = new RectF(); &#125; //调整emoji图像绘制矩形 emojiRect.set(x + h, y + bmAscent, x + h + width, y); //绘制Emoji图像 c.drawBitmap(bm, null, emojiRect, mPaint); h += width; j++; &#125; segstart = j + 1; &#125; &#125; &#125; &#125; 这样就完成了文本的绘制工作，简单地总结就是：分析整体文本—&gt;拆分为段落—&gt;计算整体段落的文本包括Span的测量信息—&gt;对文本进行折行—&gt;根据最终行数把文本测量信息保存—&gt;绘制文本的行背景—&gt;判断并获取文本种的Span和Emoji图像—&gt;绘制最终的文本和图像。当然我们省略了一部分内容，比如段落文本方向，单行的文本排版方向的计算，实际的处理要更为复杂。 接下来我们来看一下在测量过程中出现的FontMetrics，这是一个Paint的静态内部类。主要用来储存文字排版的Y轴相关信息。内部仅包含ascent、descent、top、bottom、leading五个数值。如下图: 除了leading以外，其他的数值都是相对于每一行的baseline的，也就是说其他的数值需要加上对应行的baseline才能得到最终真实的坐标。 6.TextView接收软键盘输入Android上的标准文本编辑控件是EditText，而EditText对软键盘输入的处理，却是在TextView内部实现的。Android为所有的View预留了一个接收软键盘输入的接口类，叫InputConnection。软键盘以InputConnection为桥梁把文字输入、文字修改、文字删除等传递给View。任意View只要重写onCheckIsTextEditor()并返回true，然后重写onCreateInputConnection(EditorInfo outAttrs)返回一个InputConnection的实例，便可以接收软键盘的输入。TextView的软键盘输入接收，是通过EditableInputConnection类来实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; //判断是否处于可编辑状态 if (onCheckIsTextEditor() &amp;&amp; isEnabled()) &#123; mEditor.createInputMethodStateIfNeeded(); //设置输入法相关的信息 outAttrs.inputType = getInputType(); if (mEditor.mInputContentType != null) &#123; outAttrs.imeOptions = mEditor.mInputContentType.imeOptions; outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions; outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel; outAttrs.actionId = mEditor.mInputContentType.imeActionId; outAttrs.extras = mEditor.mInputContentType.extras; &#125; else &#123; outAttrs.imeOptions = EditorInfo.IME_NULL; &#125; if (focusSearch(FOCUS_DOWN) != null) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT; &#125; if (focusSearch(FOCUS_UP) != null) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS; &#125; if ((outAttrs.imeOptions&amp;EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) &#123; if ((outAttrs.imeOptions&amp;EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) &#123; //把软键盘的enter设为下一步 outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT; &#125; else &#123; //把软键盘的enter设为完成 outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE; &#125; if (!shouldAdvanceFocusOnEnter()) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION; &#125; &#125; if (isMultilineInputType(outAttrs.inputType)) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION; &#125; outAttrs.hintText = mHint; //判断TextView内部文本是否可编辑 if (mText instanceof Editable) &#123; //返回EditableInputConnection实例 InputConnection ic = new EditableInputConnection(this); outAttrs.initialSelStart = getSelectionStart(); outAttrs.initialSelEnd = getSelectionEnd(); outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType()); return ic; &#125; &#125; return null; &#125; 我们再来看一下EditableInputConnection里面的几个主要的方法： 首先是commitText方法，这个方法接收输入法输入的字符并提交给TextView。 12345678910111213141516171819public boolean commitText(CharSequence text, int newCursorPosition) &#123; //判断TextView是否为空 if (mTextView == null) &#123; return super.commitText(text, newCursorPosition); &#125; //判断文本是否Span，来自输入法的Span一般只有SuggestionSpan，SuggestionSpan携带了输入法的错别字修正的词 if (text instanceof Spanned) &#123; Spanned spanned = ((Spanned) text); SuggestionSpan[] spans = spanned.getSpans(0, text.length(), SuggestionSpan.class); mIMM.registerSuggestionSpansForNotification(spans); &#125; mTextView.resetErrorChangedFlag(); //提交字符 boolean success = super.commitText(text, newCursorPosition); mTextView.hideErrorIfUnchanged(); //返回是否成功 return success; &#125; getEditable方法，这个方法并不是InputConnection接口的一部分，而是EditableInputConnection的父类BaseInputConnection的方法，用来获取一个可编辑对象，EditableInputConnection里面的所有修改都针对这个可编辑对象来做。 12345678public Editable getEditable() &#123; TextView tv = mTextView; if (tv != null) &#123; //返回TextView的可编辑对象 return tv.getEditableText(); &#125; return null; &#125; deleteSurroundingText方法，这个方法用来删除光标前后的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean deleteSurroundingText(int beforeLength, int afterLength) &#123; if (DEBUG) Log.v(TAG, \"deleteSurroundingText \" + beforeLength + \" / \" + afterLength); final Editable content = getEditable(); if (content == null) return false; //批量删除标记 beginBatchEdit(); //获取当前已选择的文本的位置 int a = Selection.getSelectionStart(content); int b = Selection.getSelectionEnd(content); if (a &gt; b) &#123; int tmp = a; a = b; b = tmp; &#125; int ca = getComposingSpanStart(content); int cb = getComposingSpanEnd(content); if (cb &lt; ca) &#123; int tmp = ca; ca = cb; cb = tmp; &#125; if (ca != -1 &amp;&amp; cb != -1) &#123; if (ca &lt; a) a = ca; if (cb &gt; b) b = cb; &#125; int deleted = 0; //删除光标之前的文本 if (beforeLength &gt; 0) &#123; int start = a - beforeLength; if (start &lt; 0) start = 0; content.delete(start, a); deleted = a - start; &#125; //删除光标之后的文本 if (afterLength &gt; 0) &#123; b = b - deleted; int end = b + afterLength; if (end &gt; content.length()) end = content.length(); content.delete(b, end); &#125; //结束批量编辑 endBatchEdit(); return true; &#125; commitCompletion和commitCorrection方法，即是用来补全单词和修正错别字的方法，这两个方法内部都是调用TextView对应的方法来实现的。 12345678910111213141516public boolean commitCompletion(CompletionInfo text) &#123; if (DEBUG) Log.v(TAG, \"commitCompletion \" + text); mTextView.beginBatchEdit(); mTextView.onCommitCompletion(text); mTextView.endBatchEdit(); return true; &#125; @Override public boolean commitCorrection(CorrectionInfo correctionInfo) &#123; if (DEBUG) Log.v(TAG, \"commitCorrection\" + correctionInfo); mTextView.beginBatchEdit(); mTextView.onCommitCorrection(correctionInfo); mTextView.endBatchEdit(); return true; &#125; 8.总结一个展示文本+文本编辑器功能的控件需要做的事情很多，要对文本进行排版、处理不同的段落风格、处理段落内的不同emoji和span、进行折行计算，然后还需要做文本编辑、文本选择等。而TextView把这些事情明确分工给不同的类。这样不仅仅把复杂问题拆分成了一个个简单的小功能，同时也大大增加了可扩展性。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"TabLayout源码解析","date":"2017-07-26T12:06:13.000Z","path":"2017/07/26/TabLayout源码解析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 TabLayout 源码解析1. 功能介绍1.1 TabLayoutTabs跟随Actionbar在Android 3.0进入大家的视线，是一个很经典的设计。它也是Material Design 规范中提及的Component之一。Tabs or Bottom navigation？相信不少Android开发者与产品都撕过，就连微信在其中也有过抉择。Google在Google+以及Google Photo中相继采用Bottom navigation的设计把剧情推到向高潮，一度轰动整个社区。Google继而在Material Design 规范加入了Bottom navigation，表明了态度，也给这起争论画上了圆满的句号。 在 support desgin lib 发布前，大家基本都采用PagerSlidingTabStrip来实现tab效果。其实TabLayout在实现上和PagerSlidingTabStrip十分相似，今天我们来分析TabLayout。 1.2 TabLayout使用TabLayout使用比较简单。既可以单独使用，也可以与ViewPager配合使用。 1.2.1 TabLayout单独使用在java代码中添加Tabs1234TabLayout tabLayout = (TabLayout) findViewById(R.id.tabLayout);tabLayout.addTab(tabLayout.newTab().setText(\"Tab 1\"));tabLayout.addTab(tabLayout.newTab().setText(\"Tab 2\"));tabLayout.addTab(tabLayout.newTab().setText(\"Tab 3\")); 也可以在xml中添加Tabs1234567891011&lt;android.support.design.widget.TabLayout android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\"&gt; &lt;android.support.design.widget.TabItem android:text=\"@string/tab_text\"/&gt; &lt;android.support.design.widget.TabItem android:icon=\"@drawable/ic_android\"/&gt;&lt;/android.support.design.widget.TabLayout&gt; 1.2.2 与ViewPager搭配使用1234567891011121314// find viewTabLayout tabLayout = ...;ViewPager viewPager = ...;PagerAdapter adapter = new PagerAdapter()&#123; // ...Override some methods // TabLayout调用这个方法获取Tab的title @Override public CharSequence getPageTitle(int position) &#123; return \"Tab 1\"; &#125;&#125;viewPager.setAdapter(adapter);tabLayout.setupWithViewPager(viewPager); 2. 总体设计 TabLayout继承HorizontalScrollView天生就是一个可以横向滚动的ViewGroup. 我们知道, HorizontalScrollView与ScrollView一样, 最多只能包含一个子View. SlidingTabStrip继承于LinearLayout，是TabLayout的内部类。它是TabLayout唯一的子View. 所有的TabView都是它的子View. TabView继承于LinearLayout,以Tab为数据源，来展示Tab的样式。最终用for循环被add进SlidingTabStrip. Tab是一个简单的View Model实体类，控制TabView的title, icon, custom layout id等属性。 TabItem继承于View. 用于在layout xml中来描述Tab. 需要注意的是，它不会add到SlidingTabStrip中去。它的作用是从xml中获取到text，icon，custom layout id等属性。TabLayout inflate到TabItem并获取属性到装配到Tab中，最终add到SlidingTabStrip中的还是TabView. OnTabSelectedListener是TabLayout中的内部接口，用于监听SlidingTabStrip中子TabView选中状态的改变。 Mode是TabLayout滚动模式的描述，一共有两种状态。MODE_FIXED不可滚动模式，以及MODE_SCROLLABLE可以滚动模式。 Gravity是TabView在SlidingTabStrip中layout方式的描述。分为：GRAVITY_FILL，GRAVITY_CENTER. 3. 详细设计3.1 类关系图 3.2 分析3.2.1 TabLayout子View唯一性保证前面介绍TabLayout继承于HorizontalScrollView最多只能有1个子View. 但TabLayout可以在layout中添加多个子View节点. 这是怎么回事呢？1234567891011&lt;android.support.design.widget.TabLayout android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\"&gt; &lt;android.support.design.widget.TabItem android:text=\"@string/tab_text\"/&gt; &lt;android.support.design.widget.TabItem android:icon=\"@drawable/ic_android\"/&gt;&lt;/android.support.design.widget.TabLayout&gt; 看过LayoutInflater源码的同学可能会知道这个过程：先inflate到生成View对象，再调用ViewGroup#addView(...)系列方法把view添加到ViewGroup中。我们发现TabLayout的addView(...)系列方法，都删去super调用，且调用了共同的一个方法，addViewInternal(View view)。 1234567private void addViewInternal(final View child) &#123; if (child instanceof TabItem) &#123; addTabFromItemView((TabItem) child); &#125; else &#123; throw new IllegalArgumentException(\"Only TabItem instances can be added to TabLayout\"); &#125;&#125; 可见，若child非TabItem对象会抛出异常。所以xml中给TabLayout添加tab时，只能添加TabItem对象。若想添加其它View类型怎么办？TabItem有android:customView这个属性。我们继续来看。12345678910111213141516171819202122232425262728293031323334private void addTabFromItemView(@NonNull TabItem item) &#123; final Tab tab = newTab(); if (item.mText != null) &#123; tab.setText(item.mText); &#125; if (item.mIcon != null) &#123; tab.setIcon(item.mIcon); &#125; if (item.mCustomLayout != 0) &#123; tab.setCustomView(item.mCustomLayout); &#125; addTab(tab);&#125;public Tab newTab() &#123; Tab tab = sTabPool.acquire(); if (tab == null) &#123; tab = new Tab(); &#125; tab.mParent = this; tab.mView = createTabView(tab); return tab;&#125;private TabView createTabView(@NonNull final Tab tab) &#123; TabView tabView = mTabViewPool != null ? mTabViewPool.acquire() : null; if (tabView == null) &#123; tabView = new TabView(getContext()); &#125; tabView.setTab(tab); tabView.setFocusable(true); tabView.setMinimumWidth(getTabMinWidth()); return tabView;&#125; 这里调newTab()方法创建了一个tab对象，并且用对象池把创建的tab对象缓存起来。然后将TabItem对象的属性都赋值给tab对象。在createTabView(Tab tab)这个方法中，首先从TabView池中获取TabView对象，如果不存在，则实例化一个对象，并调用tabView.setTab(tab)方法来进行了数据绑定。 addTab(...)有三个重载方法，最终都会调用如下方法：1234567891011121314151617181920212223242526272829public void addTab(@NonNull Tab tab, boolean setSelected) &#123; if (tab.mParent != this) &#123; throw new IllegalArgumentException(\"Tab belongs to a different TabLayout.\"); &#125; addTabView(tab, setSelected); configureTab(tab, mTabs.size()); if (setSelected) &#123; tab.select(); &#125;&#125;private void addTabView(Tab tab, int position, boolean setSelected) &#123; final TabView tabView = tab.mView; mTabStrip.addView(tabView, position, createLayoutParamsForTabs()); if (setSelected) &#123; tabView.setSelected(true); &#125;&#125;private void configureTab(Tab tab, int position) &#123; tab.setPosition(position); mTabs.add(position, tab); final int count = mTabs.size(); for (int i = position + 1; i &lt; count; i++) &#123; mTabs.get(i).setPosition(i); &#125;&#125; 在addView(Tab, int, boolean)方法中，把TabView对象add进了SlidingTabStrip这个ViewGroup中。实际上SlidingTabStrip的对象mTabStrip才是TabLayout的唯一子View.在TabLayout的构造方法中:1234567891011public TabLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); // 禁用横向滑动条 setHorizontalScrollBarEnabled(false); // new 一个'SlidingTabStrip'的实例，并作为唯一的子View add进'TabLayout'. mTabStrip = new SlidingTabStrip(context); super.addView(mTabStrip, 0, new HorizontalScrollView.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT)); // 省略下面的无关代码...｝ 至此，我们就明白了TabLayout中子View的一致性是如何保证的。也明白了TabView其实才是亲生的，TabItem其实是后娘养的! 这些代码都很简单，不过我们可以从中学习到很多有用的思想。 至此，一个清晰的View层级图应该就出现在了各位同学的眼前。 3.2.2 与ViewPager搭配使用有了上面的的基础，我们再来看看TabLayout是如何和它的好基友ViewPager搭配使用的。12345678910111213141516171819202122232425262728293031323334353637383940414243public void setupWithViewPager(@Nullable final ViewPager viewPager) &#123; //... //为理解简单起见，删掉边角性干扰代码，主要来看核心逻辑 mViewPager = viewPager; // Add our custom OnPageChangeListener to the ViewPager if (mPageChangeListener == null) &#123; mPageChangeListener = new TabLayoutOnPageChangeListener(this); &#125; mPageChangeListener.reset(); viewPager.addOnPageChangeListener(mPageChangeListener); // Now we'll add a tab selected listener to set ViewPager's current item setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager)); // Now we'll populate ourselves from the pager adapter setPagerAdapter(adapter, true);&#125;public void setOnTabSelectedListener(OnTabSelectedListener onTabSelectedListener) &#123; mOnTabSelectedListener = onTabSelectedListener;&#125;private void setPagerAdapter(@Nullable final PagerAdapter adapter, final boolean addObserver) &#123; if (mPagerAdapter != null &amp;&amp; mPagerAdapterObserver != null) &#123; // If we already have a PagerAdapter, unregister our observer mPagerAdapter.unregisterDataSetObserver(mPagerAdapterObserver); &#125; mPagerAdapter = adapter; if (addObserver &amp;&amp; adapter != null) &#123; // Register our observer on the new adapter if (mPagerAdapterObserver == null) &#123; mPagerAdapterObserver = new PagerAdapterObserver(); &#125; adapter.registerDataSetObserver(mPagerAdapterObserver); &#125; // Finally make sure we reflect the new adapter populateFromPagerAdapter();&#125; 这里的TabLayoutOnPageChangeListener实现了ViewPager.OnPageChangeListener. 首先调用ViewPager对象addOnPageChangeListener(OnPageChangeListener)来监听ViewPager的滑动以及当前也的选中。然后设置ViewPagerOnTabSelectedListener对象，保证ViewPager的页面和TabLayout的item的选中状态保持一致，以及滚动的协同性。这里的监听在3.2.3中详细讲解。 我们一般调用viewPager.getAdapter().notifyDataSetChanged()来进行ViewPager的刷新. 现在我们在ViewPager的adapter中注册一个监听器，监听ViewPager的刷新行为。目的是为了刷新ViewPager的同时也可以刷新TabLayout. 我们来看看PagerAdapterObserver这个监听器是如何刷新TabLayout的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private class PagerAdapterObserver extends DataSetObserver &#123; @Override public void onChanged() &#123; populateFromPagerAdapter(); &#125; @Override public void onInvalidated() &#123; populateFromPagerAdapter(); &#125;&#125;private void populateFromPagerAdapter() &#123; removeAllTabs(); if (mPagerAdapter != null) &#123; final int adapterCount = mPagerAdapter.getCount(); for (int i = 0; i &lt; adapterCount; i++) &#123; addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false); &#125; // Make sure we reflect the currently set ViewPager item if (mViewPager != null &amp;&amp; adapterCount &gt; 0) &#123; final int curItem = mViewPager.getCurrentItem(); if (curItem != getSelectedTabPosition() &amp;&amp; curItem &lt; getTabCount()) &#123; selectTab(getTabAt(curItem)); &#125; &#125; &#125; else &#123; removeAllTabs(); &#125;&#125;public void removeAllTabs() &#123; // Remove all the views for (int i = mTabStrip.getChildCount() - 1; i &gt;= 0; i--) &#123; removeTabViewAt(i); &#125; for (final Iterator&lt;Tab&gt; i = mTabs.iterator(); i.hasNext();) &#123; final Tab tab = i.next(); i.remove(); tab.reset(); sTabPool.release(tab); &#125; mSelectedTab = null;&#125; 刷新方式很简单粗暴，从SlidingTabStrip对象中移除所有的TabView，继而从View ModelmTabs中移除所有Tab对象。然后从adapter中获取tab信息，循环调用addTab(Tab, boolean)方法重新添加TabView。最后调用ViewPager对象的getCurrentItem()方法，获取当前位置，然后调用selectTab(int position)恢复TabView的选中状态（针对TabView的选中，3.2.4中有详细介绍)。 3.2.3 ViewPager与TabLayout的Tab及indicaotr协同滚动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class TabLayoutOnPageChangeListener implements ViewPager.OnPageChangeListener &#123; private final WeakReference&lt;TabLayout&gt; mTabLayoutRef; private int mPreviousScrollState; private int mScrollState; public TabLayoutOnPageChangeListener(TabLayout tabLayout) &#123; mTabLayoutRef = new WeakReference&lt;&gt;(tabLayout); &#125; @Override public void onPageScrollStateChanged(int state) &#123; mPreviousScrollState = mScrollState; mScrollState = state; &#125; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; final TabLayout tabLayout = mTabLayoutRef.get(); if (tabLayout != null) &#123; // Only update the text selection if we're not settling, or we are settling after // being dragged final boolean updateText = mScrollState != SCROLL_STATE_SETTLING || mPreviousScrollState == SCROLL_STATE_DRAGGING; // Update the indicator if we're not settling after being idle. This is caused // from a setCurrentItem() call and will be handled by an animation from // onPageSelected() instead. final boolean updateIndicator = !(mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); tabLayout.setScrollPosition(position, positionOffset, updateText, updateIndicator); &#125; &#125; @Override public void onPageSelected(int position) &#123; final TabLayout tabLayout = mTabLayoutRef.get(); if (tabLayout != null &amp;&amp; tabLayout.getSelectedTabPosition() != position) &#123; // Select the tab, only updating the indicator if we're not being dragged/settled // (since onPageScrolled will handle that). final boolean updateIndicator = mScrollState == SCROLL_STATE_IDLE || (mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); tabLayout.selectTab(tabLayout.getTabAt(position), updateIndicator); &#125; &#125; private void reset() &#123; mPreviousScrollState = mScrollState = SCROLL_STATE_IDLE; &#125;&#125; 用过ViewPager的同学对OnPageChangeListener不会陌生，不多赘述。TabLayoutOnPageChangeListener实现了OnPageChangeListener, 在onPageScrolled(...)方法中做协同滚动处理。滚动的条件是：1final boolean updateIndicator = !(mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); 调用TabLayout的setScrollPosition(...)方法来控制TabLayout中TabView和indocator的协同滚动。12345678910111213141516171819202122private void setScrollPosition(int position, float positionOffset, boolean updateSelectedText, boolean updateIndicatorPosition) &#123; final int roundedPosition = Math.round(position + positionOffset); if (roundedPosition &lt; 0 || roundedPosition &gt;= mTabStrip.getChildCount()) &#123; return; &#125; // Set the indicator position, if enabled if (updateIndicatorPosition) &#123; mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset); &#125; // Now update the scroll position, canceling any running animation if (mScrollAnimator != null &amp;&amp; mScrollAnimator.isRunning()) &#123; mScrollAnimator.cancel(); &#125; scrollTo(calculateScrollXForTab(position, positionOffset), 0); // Update the 'selected state' view as we scroll, if enabled if (updateSelectedText) &#123; setSelectedTabView(roundedPosition); &#125;&#125; 3.2.3.1 TabLayout的Indicator协同滚动indicator的滚动由SlidingTabStrip来处理： 1234// Set the indicator position, if enabledif (updateIndicatorPosition) &#123; mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset);&#125; 这里的position是当前选中的位置。positionOffset是: 距当前Tab滑动的距离／从当前tab滑动到下一个tab的总距离 这样一个范围在［0，1］间的小数。 SlidingTabStrip#setIndicatorPositionFromTabPosition(int, float)123456789void setIndicatorPositionFromTabPosition(int position, float positionOffset) &#123; if (mIndicatorAnimator != null &amp;&amp; mIndicatorAnimator.isRunning()) &#123; mIndicatorAnimator.cancel(); &#125; mSelectedPosition = position; mSelectionOffset = positionOffset; updateIndicatorPosition();&#125; SlidingTabStrip#updateIndicatorPosition()12345678910111213141516171819202122private void updateIndicatorPosition() &#123; final View selectedTitle = getChildAt(mSelectedPosition); int left, right; if (selectedTitle != null &amp;&amp; selectedTitle.getWidth() &gt; 0) &#123; left = selectedTitle.getLeft(); right = selectedTitle.getRight(); if (mSelectionOffset &gt; 0f &amp;&amp; mSelectedPosition &lt; getChildCount() - 1) &#123; // Draw the selection partway between the tabs View nextTitle = getChildAt(mSelectedPosition + 1); left = (int) (mSelectionOffset * nextTitle.getLeft() + (1.0f - mSelectionOffset) * left); right = (int) (mSelectionOffset * nextTitle.getRight() + (1.0f - mSelectionOffset) * right); &#125; &#125; else &#123; left = right = -1; &#125; setIndicatorPosition(left, right);&#125; 通过getChildAt(mSelectedPosition), 获取到到mSelectedPosition处的TabView。若滑动的mSelectionOffset&gt;0f且当前选中的位置mSelectedPosition不是最后一个TabView. 获取到下一个TabView，并计算出indicator的left和right。 SlidingTabStrip＃setIndicatorPosition(int, int)12345678private void setIndicatorPosition(int left, int right) &#123; if (left != mIndicatorLeft || right != mIndicatorRight) &#123; // If the indicator's left/right has changed, invalidate mIndicatorLeft = left; mIndicatorRight = right; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 非常简单的代码，在调用ViewCompat.postInvalidateOnAnimation(this)重绘View之前，去掉一些重复绘制的帧。 12345678910@Overridepublic void draw(Canvas canvas) &#123; super.draw(canvas); // Thick colored underline below the current selection if (mIndicatorLeft &gt;= 0 &amp;&amp; mIndicatorRight &gt; mIndicatorLeft) &#123; canvas.drawRect(mIndicatorLeft, getHeight() - mSelectedIndicatorHeight, mIndicatorRight, getHeight(), mSelectedIndicatorPaint); &#125;&#125; 绘制逻辑很简单。调用canvas.drawRect(float left, float top, float right, float bottom, Paint paint)来绘制indicator.这里：1234left = mIndicatorLeft;top = getHeight() - mSelectedIndicatorHeight;right = mIndicatorRight;bottom = getHeight(); 3.2.3.2 TabLayout的TabView协同滚动我们回头来看 3.2.3中setScrollPosition(...)方法12345678910111213141516171819202122private void setScrollPosition(int position, float positionOffset, boolean updateSelectedText, boolean updateIndicatorPosition) &#123; final int roundedPosition = Math.round(position + positionOffset); if (roundedPosition &lt; 0 || roundedPosition &gt;= mTabStrip.getChildCount()) &#123; return; &#125; // Set the indicator position, if enabled if (updateIndicatorPosition) &#123; mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset); &#125; // Now update the scroll position, canceling any running animation if (mScrollAnimator != null &amp;&amp; mScrollAnimator.isRunning()) &#123; mScrollAnimator.cancel(); &#125; scrollTo(calculateScrollXForTab(position, positionOffset), 0); // Update the 'selected state' view as we scroll, if enabled if (updateSelectedText) &#123; setSelectedTabView(roundedPosition); &#125;&#125; 在3.2.3.1中我们知道indicator的滚动是通过mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset)实现的。那TabView的滚动呢？我们知道TabLayout是继承HorizonScrollView天生就是一个可以横行滚动的View，所以，我们只需要调用scrollTo(int x, int y)方法就可以实现横向滚动。1scrollTo(calculateScrollXForTab(position, positionOffset), 0); 这里x方向的偏移量调用calculateScrollXForTab(position, positionOffset)实时计算得出，y方向的偏移量为0。12345678910111213141516private int calculateScrollXForTab(int position, float positionOffset) &#123; if (mMode == MODE_SCROLLABLE) &#123; final View selectedChild = mTabStrip.getChildAt(position); final View nextChild = position + 1 &lt; mTabStrip.getChildCount() ? mTabStrip.getChildAt(position + 1) : null; final int selectedWidth = selectedChild != null ? selectedChild.getWidth() : 0; final int nextWidth = nextChild != null ? nextChild.getWidth() : 0; return selectedChild.getLeft() + ((int) ((selectedWidth + nextWidth) * positionOffset * 0.5f)) + (selectedChild.getWidth() / 2) - (getWidth() / 2); &#125; return 0;&#125; 至此，我们就明白了TabLayout是如何随ViewPager的滚动而滚动的。 3.2.4 Tab选中状态123456789private void setSelectedTabView(int position) &#123; final int tabCount = mTabStrip.getChildCount(); if (position &lt; tabCount &amp;&amp; !mTabStrip.getChildAt(position).isSelected()) &#123; for (int i = 0; i &lt; tabCount; i++) &#123; final View child = mTabStrip.getChildAt(i); child.setSelected(i == position); &#125; &#125;&#125; 调用View的setSelected(boolean)方法。 4. 开源项目中的使用开源项目中使用TabLayout的例子特别多, 这里给出我写的一个项目： SwipeToLoadLayout的demo 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"SwipeRefreshLayout源码分析","date":"2017-07-26T12:04:43.000Z","path":"2017/07/26/SwipeRefreshLayout源码分析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 简介官方文档 SwipeRefreshLayout 是一个下拉刷新控件，几乎可以包裹一个任何可以滚动的内容（ListView GridView ScrollView RecyclerView），可以自动识别垂直滚动手势。使用起来非常方便。 1.将需要下拉刷新的空间包裹起来 12345678910&lt;android.support.v4.widget.SwipeRefreshLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 2.设置刷新动画的触发回调 123456789101112131415161718192021222324252627282930//设置下拉出现小圆圈是否是缩放出现，出现的位置，最大的下拉位置mySwipeRefreshLayout.setProgressViewOffset(true, 50, 200);//设置下拉圆圈的大小，两个值 LARGE， DEFAULTmySwipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);// 设置下拉圆圈上的颜色，蓝色、绿色、橙色、红色mySwipeRefreshLayout.setColorSchemeResources( android.R.color.holo_blue_bright, android.R.color.holo_green_light, android.R.color.holo_orange_light, android.R.color.holo_red_light);// 通过 setEnabled(false) 禁用下拉刷新mySwipeRefreshLayout.setEnabled(false);// 设定下拉圆圈的背景mSwipeLayout.setProgressBackgroundColor(R.color.red);/* * 设置手势下拉刷新的监听 */mySwipeRefreshLayout.setOnRefreshListener( new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; // 刷新动画开始后回调到此方法 &#125; &#125;); 通过 setRefreshing(false) 和 setRefreshing(true) 来手动调用刷新的动画。 onRefresh 的回调只有在手势下拉的情况下才会触发，通过 setRefreshing 只能调用刷新的动画是否显示。SwipeRefreshLayout 也可放在 CoordinatorLayout 内共同处理滑动冲突，有兴趣可以尝试。 SwipeRefreshLayout 源码分析 本文基于 v4 版本 23.2.0 extends ViewGroup implements NestedScrollingParent NestedScrollingChild1234java.lang.Object ↳ android.view.View ↳ android.view.ViewGroup ↳ android.support.v4.widget.SwipeRefreshLayout SwipeRefreshLayout 的分析分为两个部分：自定义 ViewGroup 的部分，处理和子视图的嵌套滚动部分。 SwipeRefreshLayout extends ViewGroup其实就是一个自定义的 ViewGroup ，结合我们自己平时自定义 ViewGroup 的步骤： 初始化变量 onMeasure onLayout 处理交互 （dispatchTouchEvent onInterceptTouchEvent onTouchEvent） 接下来就按照上面的步骤进行分析。 1.初始化变量SwipeRefreshLayout 内部有 2 个 View，一个圆圈（mCircleView），一个内部可滚动的View（mTarget）。除了 View，还包含一个 OnRefreshListener 接口，当刷新动画被触发时回调。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Constructor that is called when inflating SwipeRefreshLayout from XML. * * @param context * @param attrs */public SwipeRefreshLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); // 系统默认的最小滚动距离 mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); // 系统默认的动画时长 mMediumAnimationDuration = getResources().getInteger( android.R.integer.config_mediumAnimTime); setWillNotDraw(false); mDecelerateInterpolator = new DecelerateInterpolator(DECELERATE_INTERPOLATION_FACTOR); // 获取 xml 中定义的属性 final TypedArray a = context.obtainStyledAttributes(attrs, LAYOUT_ATTRS); setEnabled(a.getBoolean(0, true)); a.recycle(); // 刷新的圆圈的大小，单位转换成 sp final DisplayMetrics metrics = getResources().getDisplayMetrics(); mCircleWidth = (int) (CIRCLE_DIAMETER * metrics.density); mCircleHeight = (int) (CIRCLE_DIAMETER * metrics.density); // 创建刷新动画的圆圈 createProgressView(); ViewCompat.setChildrenDrawingOrderEnabled(this, true); // the absolute offset has to take into account that the circle starts at an offset mSpinnerFinalOffset = DEFAULT_CIRCLE_TARGET * metrics.density; // 刷新动画的临界距离值 mTotalDragDistance = mSpinnerFinalOffset; // 通过 NestedScrolling 机制来处理嵌套滚动 mNestedScrollingParentHelper = new NestedScrollingParentHelper(this); mNestedScrollingChildHelper = new NestedScrollingChildHelper(this); setNestedScrollingEnabled(true);&#125; // 创建刷新动画的圆圈12345678private void createProgressView() &#123; mCircleView = new CircleImageView(getContext(), CIRCLE_BG_LIGHT, CIRCLE_DIAMETER/2); mProgress = new MaterialProgressDrawable(getContext(), this); mProgress.setBackgroundColor(CIRCLE_BG_LIGHT); mCircleView.setImageDrawable(mProgress); mCircleView.setVisibility(View.GONE); addView(mCircleView);&#125; 初始化的时候创建一个出来一个 View （下拉刷新的圆圈）。可以看出使用背景圆圈是 v4 包里提供的 CircleImageView 控件，中间的是 MaterialProgressDrawable 进度条。另一个 View 是在 xml 中包含的可滚动视图。 2.onMeasureonMeasure 确定子视图的大小。 123456789101112131415161718192021222324252627282930313233343536@Overridepublic void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); if (mTarget == null) &#123; // 确定内部要滚动的View，如 RecycleView ensureTarget(); &#125; if (mTarget == null) &#123; return; &#125; // 测量子 View （mTarget） mTarget.measure(MeasureSpec.makeMeasureSpec( getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec( getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY)); // 测量刷新的圆圈 mCircleView mCircleView.measure(MeasureSpec.makeMeasureSpec(mCircleWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(mCircleHeight, MeasureSpec.EXACTLY)); if (!mUsingCustomStart &amp;&amp; !mOriginalOffsetCalculated) &#123; mOriginalOffsetCalculated = true; mCurrentTargetOffsetTop = mOriginalOffsetTop = -mCircleView.getMeasuredHeight(); &#125; // 计算 mCircleView 在 ViewGroup 中的索引 mCircleViewIndex = -1; // Get the index of the circleview. for (int index = 0; index &lt; getChildCount(); index++) &#123; if (getChildAt(index) == mCircleView) &#123; mCircleViewIndex = index; break; &#125; &#125;&#125; 这个步骤确定了 mCircleView 和 SwipeRefreshLayout 的子视图的大小。 3.onLayoutonLayout 主要负责确定各个子视图的位置。 12345678910111213141516171819202122232425262728@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; // 获取 SwipeRefreshLayout 的宽高 final int width = getMeasuredWidth(); final int height = getMeasuredHeight(); if (getChildCount() == 0) &#123; return; &#125; if (mTarget == null) &#123; ensureTarget(); &#125; if (mTarget == null) &#123; return; &#125; // 考虑到给控件设置 padding，去除 padding 的距离 final View child = mTarget; final int childLeft = getPaddingLeft(); final int childTop = getPaddingTop(); final int childWidth = width - getPaddingLeft() - getPaddingRight(); final int childHeight = height - getPaddingTop() - getPaddingBottom(); // 设置 mTarget 的位置 child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight); int circleWidth = mCircleView.getMeasuredWidth(); int circleHeight = mCircleView.getMeasuredHeight(); // 根据 mCurrentTargetOffsetTop 变量的值来设置 mCircleView 的位置 mCircleView.layout((width / 2 - circleWidth / 2), mCurrentTargetOffsetTop, (width / 2 + circleWidth / 2), mCurrentTargetOffsetTop + circleHeight);&#125; 在 onLayout 中放置了 mCircleView 的位置，注意 顶部位置是 mCurrentTargetOffsetTop ，mCurrentTargetOffsetTop 初始距离是-mCircleView.getMeasuredHeight()，所以是在 SwipeRefreshLayout 外。 经过以上几个步骤，SwipeRefreshLayout 创建了子视图，确定他们的大小、位置，现在所有视图可以显示在界面了。 处理与子视图的滚动交互下拉刷新控件的主要功能是当子视图下拉到最顶部时，继续下拉可以出现刷新动画。而子视图可以滚动时需要将所有滚动事件都交给子视图。借助 Android 提供的 NestedScrolling 机制，使得 SwipeRefreshLayout 很轻松的解决了与子视图的滚动冲突问题。SwipeRefreshLayout 通过实现 NestedScrollingParent 和 NestedScrollingChild 接口来处理滚动冲突。SwipeRefreshLayout 作为 Parent 嵌套一个可以滚动的子视图，那么就需要了解一下 NestedScrollingParent 接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** 当你希望自己的自定义布局支持嵌套子视图并且处理滚动操作，就可以实现该接口。 实现这个接口后可以创建一个 NestedScrollingParentHelper 字段，使用它来帮助你处理大部分的方法。 处理嵌套的滚动时应该使用 `ViewCompat`，`ViewGroupCompat`或`ViewParentCompat` 中的方法来处理，这是一些兼容库， 他们保证 Android 5.0之前的兼容性垫片的静态方法，这样可以兼容 Android 5.0 之前的版本。 */public interface NestedScrollingParent &#123; /** * 当子视图调用 startNestedScroll(View, int) 后调用该方法。返回 true 表示响应子视图的滚动。 * 实现这个方法来声明支持嵌套滚动，如果返回 true，那么这个视图将要配合子视图嵌套滚动。当嵌套滚动结束时会调用到 onStopNestedScroll(View)。 * * @param child 可滚动的子视图 * @param target NestedScrollingParent 的直接可滚动的视图，一般情况就是 child * @param nestedScrollAxes 包含 ViewCompat#SCROLL_AXIS_HORIZONTAL, ViewCompat#SCROLL_AXIS_VERTICAL 或者两个值都有。 * @return 返回 true 表示响应子视图的滚动。 */ public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes); /** * 如果 onStartNestedScroll 返回 true ，然后走该方法，这个方法里可以做一些初始化。 */ public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes); /** * 子视图开始滚动前会调用这个方法。这时候父布局（也就是当前的 NestedScrollingParent 的实现类）可以通过这个方法来配合子视图同时处理滚动事件。 * * @param target 滚动的子视图 * @param dx 绝对值为手指在x方向滚动的距离，dx&lt;0 表示手指在屏幕向右滚动 * @param dy 绝对值为手指在y方向滚动的距离，dy&lt;0 表示手指在屏幕向下滚动 * @param consumed 一个数组，值用来表示父布局消耗了多少距离，未消耗前为[0,0], 如果父布局想处理滚动事件，就可以在这个方法的实现中为consumed[0]，consumed[1]赋值。 * 分别表示x和y方向消耗的距离。如父布局想在竖直方向（y）完全拦截子视图，那么让 consumed[1] = dy，就把手指产生的触摸事件给拦截了，子视图便响应不到触摸事件了 。 */ public void onNestedPreScroll(View target, int dx, int dy, int[] consumed); /** * 这个方法表示子视图正在滚动，并且把滚动距离回调用到该方法，前提是 onStartNestedScroll 返回了 true。 * &lt;p&gt;Both the consumed and unconsumed portions of the scroll distance are reported to the * ViewParent. An implementation may choose to use the consumed portion to match or chase scroll * position of multiple child elements, for example. The unconsumed portion may be used to * allow continuous dragging of multiple scrolling or draggable elements, such as scrolling * a list within a vertical drawer where the drawer begins dragging once the edge of inner * scrolling content is reached.&lt;/p&gt; * * @param target 滚动的子视图 * @param dxConsumed 手指产生的触摸距离中，子视图消耗的x方向的距离 * @param dyConsumed 手指产生的触摸距离中，子视图消耗的y方向的距离 ，如果 onNestedPreScroll 中 dy = 20， consumed[0] = 8，那么 dy = 12 * @param dxUnconsumed 手指产生的触摸距离中，未被子视图消耗的x方向的距离 * @param dyUnconsumed 手指产生的触摸距离中，未被子视图消耗的y方向的距离 */ public void onNestedScroll(View target, int dxConsumed, int dyConsumed,int dxUnconsumed, int dyUnconsumed); /** * 响应嵌套滚动结束 * * 当一个嵌套滚动结束后（如MotionEvent#ACTION_UP， MotionEvent#ACTION_CANCEL）会调用该方法，在这里可有做一些收尾工作，比如变量重置 */ public void onStopNestedScroll(View target); /** * 手指在屏幕快速滑触发Fling前回调，如果前面 onNestedPreScroll 中父布局消耗了事件，那么这个也会被触发 * 返回true表示父布局完全处理 fling 事件 * * @param target 滚动的子视图 * @param velocityX x方向的速度（px/s） * @param velocityY y方向的速度 * @return true if this parent consumed the fling ahead of the target view */ public boolean onNestedPreFling(View target, float velocityX, float velocityY); /** * 子视图fling 时回调，父布局可以选择监听子视图的 fling。 * true 表示父布局处理 fling，false表示父布局监听子视图的fling * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @param consumed true 表示子视图处理了fling */ public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed); /** * 返回当前 NestedScrollingParent 的滚动方向， * * @return * @see ViewCompat#SCROLL_AXIS_HORIZONTAL * @see ViewCompat#SCROLL_AXIS_VERTICAL * @see ViewCompat#SCROLL_AXIS_NONE */ public int getNestedScrollAxes();&#125; 看一下 SwipeRefreshLayout 实现 NestedScrollingParent 的相关方法123456789101112131415161718// NestedScrollingParent// 子 View （NestedScrollingChild）开始滚动前回调此方法,返回 true 表示接 Parent 收嵌套滚动，然后调用 onNestedScrollAccepted// 具体可以看 NestedScrollingChildHelper 的源码@Overridepublic boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123; // 子 View 回调，判断是否开始嵌套滚动 ， return isEnabled() &amp;&amp; !mReturningToStart &amp;&amp; !mRefreshing &amp;&amp; (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;&#125;@Override public void onNestedScrollAccepted(View child, View target, int axes) &#123; // Reset the counter of how much leftover scroll needs to be consumed. mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes); // ...省略代码 &#125; SwipeRefreshLayout 只接受竖直方向（Y轴）的滚动，并且在刷新动画进行中不接受滚动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// NestedScrollingChild 在滚动的时候会触发， 看父类消耗了多少距离// * @param dx x 轴滚动的距离// * @param dy y 轴滚动的距离// * @param consumed 代表 父 View 消费的滚动距离//@Overridepublic void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; // dy &gt; 0 表示手指在屏幕向上移动 // mTotalUnconsumed 表示子视图Y轴未消费的距离 // 现在表示 if (dy &gt; 0 &amp;&amp; mTotalUnconsumed &gt; 0) &#123; if (dy &gt; mTotalUnconsumed) &#123; consumed[1] = dy - (int) mTotalUnconsumed; // SwipeRefreshLayout 就吧子视图位消费的距离全部消费了。 mTotalUnconsumed = 0; &#125; else &#123; mTotalUnconsumed -= dy; // 消费的 y 轴的距离 consumed[1] = dy; &#125; // 出现动画圆圈，并向上移动 moveSpinner(mTotalUnconsumed); &#125; // ... 省略代码&#125;// onStartNestedScroll 返回 true 才会调用此方法。此方法表示子View将滚动事件分发到父 View（SwipeRefreshLayout）@Overridepublic void onNestedScroll(final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; // ... 省略代码 // This is a bit of a hack. Nested scrolling works from the bottom up, and as we are // sometimes between two nested scrolling views, we need a way to be able to know when any // nested scrolling parent has stopped handling events. We do that by using the // 'offset in window 'functionality to see if we have been moved from the event. // This is a decent indication of whether we should take over the event stream or not. // 手指在屏幕上向下滚动，并且子视图不可以滚动 final int dy = dyUnconsumed + mParentOffsetInWindow[1]; if (dy &lt; 0 &amp;&amp; !canChildScrollUp()) &#123; mTotalUnconsumed += Math.abs(dy); moveSpinner(mTotalUnconsumed); &#125;&#125; SwipeRefreshLayout 通过 NestedScrollingParent 接口完成了处理子视图的滚动的冲突，中间省略了一些 SwipeRefreshLayout作为 child 的相关代码，这种情况是为了兼容将 SwipeRefreshLayout 作为子视图放在知识嵌套滚动的父布局的情况，这里不做深入讨论。但是下拉刷新需要判断手指在屏幕的状态来进行一个刷新的动画，所以我们还需要处理触摸事件，判断手指在屏幕中的状态。 首先是 onInterceptTouchEvent，返回 true 表示拦截触摸事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; ensureTarget(); final int action = MotionEventCompat.getActionMasked(ev); // 手指按下时恢复状态 if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123; mReturningToStart = false; &#125; // 控件可用 || 刷新事件刚结束正在恢复初始状态时 || 子 View 可滚动 || 正在刷新 || 父 View 正在滚动 if (!isEnabled() || mReturningToStart || canChildScrollUp() || mRefreshing || mNestedScrollInProgress) &#123; // Fail fast if we're not in a state where a swipe is possible return false; &#125; switch (action) &#123; case MotionEvent.ACTION_DOWN: setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop(), true); mActivePointerId = MotionEventCompat.getPointerId(ev, 0); mIsBeingDragged = false; // 记录手指按下的位置，为了判断是否开始滚动 final float initialDownY = getMotionEventY(ev, mActivePointerId); if (initialDownY == -1) &#123; return false; &#125; mInitialDownY = initialDownY; break; case MotionEvent.ACTION_MOVE: if (mActivePointerId == INVALID_POINTER) &#123; Log.e(LOG_TAG, \"Got ACTION_MOVE event but don't have an active pointer id.\"); return false; &#125; final float y = getMotionEventY(ev, mActivePointerId); if (y == -1) &#123; return false; &#125; // 判断当拖动距离大于最小距离时设置 mIsBeingDragged = true; final float yDiff = y - mInitialDownY; if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123; mInitialMotionY = mInitialDownY + mTouchSlop; mIsBeingDragged = true; // 正在拖动状态，更新圆圈的 progressbar 的 alpha 值 mProgress.setAlpha(STARTING_PROGRESS_ALPHA); &#125; break; case MotionEventCompat.ACTION_POINTER_UP: onSecondaryPointerUp(ev); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mIsBeingDragged = false; mActivePointerId = INVALID_POINTER; break; &#125; return mIsBeingDragged;&#125; 可以看到源码也就是进行简单处理，DOWN 的时候记录一下位置，MOVE 时判断移动的距离，返回值 mIsBeingDragged 为 true 时， 即 onInterceptTouchEvent 返回true，SwipeRefreshLayout 拦截触摸事件，不分发给 mTarget，然后把 MotionEvent 传给 onTouchEvent 方法。其中有一个判断子View的是否还可以滚动的方法 canChildScrollUp。 12345678910111213141516171819/** * @return Whether it is possible for the child view of this layout to * scroll up. Override this if the child view is a custom view. */public boolean canChildScrollUp() &#123; if (android.os.Build.VERSION.SDK_INT &lt; 14) &#123; // 判断 AbsListView 的子类 ListView 或者 GridView 等 if (mTarget instanceof AbsListView) &#123; final AbsListView absListView = (AbsListView) mTarget; return absListView.getChildCount() &gt; 0 &amp;&amp; (absListView.getFirstVisiblePosition() &gt; 0 || absListView.getChildAt(0) .getTop() &lt; absListView.getPaddingTop()); &#125; else &#123; return ViewCompat.canScrollVertically(mTarget, -1) || mTarget.getScrollY() &gt; 0; &#125; &#125; else &#123; return ViewCompat.canScrollVertically(mTarget, -1); &#125;&#125; 当SwipeRefreshLayout 拦截了触摸事件之后（ mIsBeingDragged 为 true ），将 MotionEvent 交给 onTouchEvent 处理。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; // ... 省略代码 switch (action) &#123; case MotionEvent.ACTION_DOWN: // 获取第一个按下的手指 mActivePointerId = MotionEventCompat.getPointerId(ev, 0); mIsBeingDragged = false; break; case MotionEvent.ACTION_MOVE: &#123; // 处理多指触控 pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId); // ... 省略代码 final float y = MotionEventCompat.getY(ev, pointerIndex); final float overscrollTop = (y - mInitialMotionY) * DRAG_RATE; if (mIsBeingDragged) &#123; if (overscrollTop &gt; 0) &#123; // 正在拖动状态，更新圆圈的位置 moveSpinner(overscrollTop); &#125; else &#123; return false; &#125; &#125; break; &#125; // ... 省略代码 case MotionEvent.ACTION_UP: &#123; pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId); if (pointerIndex &lt; 0) &#123; Log.e(LOG_TAG, \"Got ACTION_UP event but don't have an active pointer id.\"); return false; &#125; final float y = MotionEventCompat.getY(ev, pointerIndex); final float overscrollTop = (y - mInitialMotionY) * DRAG_RATE; mIsBeingDragged = false; // 手指松开，将圆圈移动到正确的位置 finishSpinner(overscrollTop); mActivePointerId = INVALID_POINTER; return false; &#125; // ... 省略代码 &#125; return true;&#125; 在手指滚动过程中通过判断 mIsBeingDragged 来移动刷新的圆圈（对应的是 moveSpinner ），手指松开将圆圈移动到正确位置（初始位置或者刷新动画的位置，对应的是 finishSpinner 方法）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 手指下拉过程中触发的圆圈的变化过程，透明度变化，渐渐出现箭头，大小的变化private void moveSpinner(float overscrollTop) &#123; // 设置为有箭头的 progress mProgress.showArrow(true); // 进度转化成百分比 float originalDragPercent = overscrollTop / mTotalDragDistance; // 避免百分比超过 100% float dragPercent = Math.min(1f, Math.abs(originalDragPercent)); // 调整拖动百分比，造成视差效果 float adjustedPercent = (float) Math.max(dragPercent - .4, 0) * 5 / 3; // float extraOS = Math.abs(overscrollTop) - mTotalDragDistance; // 这里mUsingCustomStart 为 true 代表用户自定义了起始出现的坐标 float slingshotDist = mUsingCustomStart ? mSpinnerFinalOffset - mOriginalOffsetTop : mSpinnerFinalOffset; // 弹性系数 float tensionSlingshotPercent = Math.max(0, Math.min(extraOS, slingshotDist * 2) / slingshotDist); float tensionPercent = (float) ((tensionSlingshotPercent / 4) - Math.pow( (tensionSlingshotPercent / 4), 2)) * 2f; float extraMove = (slingshotDist) * tensionPercent * 2; // 因为有弹性系数，不同的手指滚动距离不同于view的移动距离 int targetY = mOriginalOffsetTop + (int) ((slingshotDist * dragPercent) + extraMove); // where 1.0f is a full circle if (mCircleView.getVisibility() != View.VISIBLE) &#123; mCircleView.setVisibility(View.VISIBLE); &#125; // 设置的是否有缩放 if (!mScale) &#123; ViewCompat.setScaleX(mCircleView, 1f); ViewCompat.setScaleY(mCircleView, 1f); &#125; // 设置缩放进度 if (mScale) &#123; setAnimationProgress(Math.min(1f, overscrollTop / mTotalDragDistance)); &#125; // 移动距离未达到最大距离 if (overscrollTop &lt; mTotalDragDistance) &#123; if (mProgress.getAlpha() &gt; STARTING_PROGRESS_ALPHA &amp;&amp; !isAnimationRunning(mAlphaStartAnimation)) &#123; // Animate the alpha startProgressAlphaStartAnimation(); &#125; &#125; else &#123; if (mProgress.getAlpha() &lt; MAX_ALPHA &amp;&amp; !isAnimationRunning(mAlphaMaxAnimation)) &#123; // Animate the alpha startProgressAlphaMaxAnimation(); &#125; &#125; // 出现的进度，裁剪 mProgress float strokeStart = adjustedPercent * .8f; mProgress.setStartEndTrim(0f, Math.min(MAX_PROGRESS_ANGLE, strokeStart)); mProgress.setArrowScale(Math.min(1f, adjustedPercent)); // 旋转 float rotation = (-0.25f + .4f * adjustedPercent + tensionPercent * 2) * .5f; mProgress.setProgressRotation(rotation); setTargetOffsetTopAndBottom(targetY - mCurrentTargetOffsetTop, true /* requires update */);&#125; 刷新圆圈的移动过程也是有好几种状态，看上面的注释基本上就比较清楚了。 12345678910111213141516private void finishSpinner(float overscrollTop) &#123; if (overscrollTop &gt; mTotalDragDistance) &#123; //移动距离超过了刷新的临界值，触发刷新动画 setRefreshing(true, true /* notify */); &#125; else &#123; // 取消刷新的圆圈，将圆圈移动到初始位置 mRefreshing = false; mProgress.setStartEndTrim(0f, 0f); // ...省略代码 // 移动到初始位置 animateOffsetToStartPosition(mCurrentTargetOffsetTop, listener); // 设置没有箭头 mProgress.showArrow(false) &#125;&#125; 可以看到调用 setRefresh(true,true) 方法触发刷新动画并进行回调，但是这个方法是 private 的。前面提到我们自己调用 setRefresh(true) 只能产生动画，而不能回调刷新函数，那么我们就可以用反射调用 2 个参数的 setRefresh 函数。 或者手动调 setRefreshing(true)+ OnRefreshListener.onRefresh 方法。 setRefresh123456789101112131415161718192021222324/** * 改变刷新动画的的圆圈刷新状态。Notify the widget that refresh state has changed. Do not call this when * refresh is triggered by a swipe gesture. * * @param refreshing 是否显示刷新的圆圈 */ public void setRefreshing(boolean refreshing) &#123; if (refreshing &amp;&amp; mRefreshing != refreshing) &#123; // scale and show mRefreshing = refreshing; int endTarget = 0; if (!mUsingCustomStart) &#123; endTarget = (int) (mSpinnerFinalOffset + mOriginalOffsetTop); &#125; else &#123; endTarget = (int) mSpinnerFinalOffset; &#125; setTargetOffsetTopAndBottom(endTarget - mCurrentTargetOffsetTop, true /* requires update */); mNotify = false; startScaleUpAnimation(mRefreshListener); &#125; else &#123; setRefreshing(refreshing, false /* notify */); &#125; &#125; startScaleUpAnimation 开启一个动画，然后在动画结束后回调 onRefresh 方法。 12345678910111213141516171819private Animation.AnimationListener mRefreshListener = new Animation.AnimationListener() &#123; // .. 省略代码 @Override public void onAnimationEnd(Animation animation) &#123; if (mRefreshing) &#123; mProgress.setAlpha(MAX_ALPHA); //确保刷新圆圈中间的进度条是完全不透明了 mProgress.start(); if (mNotify) &#123; // 当 mNotify 为 true 时才会回调 onRefresh if (mListener != null) &#123; // 回调 listener 的 onRefresh 方法 mListener.onRefresh(); &#125; &#125; mCurrentTargetOffsetTop = mCircleView.getTop(); &#125; else &#123; reset(); &#125; &#125;&#125;; 总结分析 SwipeRefreshLayout 的流程就是按照平时我们自定义 ViewGroup 的流程，但是其中也有好多需要我们借鉴的地方，如何使用 NestedScrolling相关机制 ，多点触控的处理，onMeasure 中减去了 padding，如何判断子 View 是否可滚动，如何确定 ViewGroup 中某一个 View 的索引等。此外，一个好的下拉刷新框架不仅仅要兼容各种滚动的子控件，还要考虑自己要兼容 NestedScrollingChild 的情况，比如放到 CooCoordinatorLayout 的情况，目前大多数开源的下拉刷新好像都没有达到这个要求，一般都是只考虑了内部嵌套滚动子视图的情况，没有考虑自己作为滚动子视图的情况。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"SearchView源码解析","date":"2017-07-26T11:59:27.000Z","path":"2017/07/26/SearchView源码解析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 SearchView源码解析SearchView是一个搜索框控件，样式也挺好看的。这次解析主要围绕android.support.v7.widget包下的SearchView（API &gt;= 7）,android.widget.SearchView支持API &gt;= 11，另外有个android.support.v4.widget.SearchViewCompat 1. 源码解析v7版本：23.2.1 1.1 继承关系12345java.lang.Object ↳ android.view.View ↳ android.view.ViewGroup ↳ android.support.v7.widget.LinearLayoutCompat ↳ android.support.v7.widget.SearchView 1.2 主要组件12345678910private final SearchAutoComplete mSearchSrcTextView;private final View mSearchEditFrame;private final View mSearchPlate;private final View mSubmitArea;private final ImageView mSearchButton;private final ImageView mGoButton;private final ImageView mCloseButton;private final ImageView mVoiceButton;private final View mDropDownAnchor;private final ImageView mCollapsedIcon; 看命名也能大概知道控件各自充当了什么角色了。 1.3 构造方法和自定义接下来看构造方法public SearchView(Context context, AttributeSet attrs, int defStyleAttr),v7的SearchView并不是用TypedArray而是使用TintTypedArray，看了源码发现TintTypedArray里有个：final TypedArray mWrapped; ```所以主要还是`TypedArray`，不同点是`getDrawable(int index)`和新加的`getDrawableIfKnown(int index)`方法，123456789101112131415并在满足条件下会调用`AppCompatDrawableManager.get().getDrawable(mContext, resourceId)`。为了能更好的自定义，`SearchView`的layout也是可以指定的，不过自定义的layout必须包括上面那些控件，同时id也是指定的，不然后面会报错，因为`findViewById(id)`无法找到各自控件，然后调用控件方法的时候就。。。构造方法最后是更新控件状态，`mIconifiedByDefault`默认是`true`的，`setIconifiedByDefault(boolean iconified)`改变值后也会执行如下方法：```java public void setIconifiedByDefault(boolean iconified) &#123; if (mIconifiedByDefault == iconified) return; mIconifiedByDefault = iconified; //更新组件 updateViewsVisibility(iconified); updateQueryHint(); &#125; 所以setIconifiedByDefault(false)会让SearchView一直呈现展开状态，并且输入框内icon也会不显示。具体方法如下，该方法在updateQueryHint()中被调用：12345678910111213141516private CharSequence getDecoratedHint(CharSequence hintText) &#123; //如果mIconifiedByDefault为false或者mSearchHintIcon为null //将不会添加搜索icon到提示hint中 if (!mIconifiedByDefault || mSearchHintIcon == null) &#123; return hintText; &#125; final int textSize = (int) (mSearchSrcTextView.getTextSize() * 1.25); mSearchHintIcon.setBounds(0, 0, textSize, textSize); final SpannableStringBuilder ssb = new SpannableStringBuilder(\" \"); ssb.setSpan(new ImageSpan(mSearchHintIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); ssb.append(hintText); return ssb;&#125; 1.4 Listener然后，我们来看看SearchView里面有哪些Listener： 1234567891011121314151617181920212223//里面有2个方法： //onQueryTextSubmit(String query)：当用户提交查询的时候会调用 //onQueryTextChange(String newText)：当查询文字改变的时候会调用private OnQueryTextListener mOnQueryChangeListener;//里面有1个方法：boolean onClose(); //onClose()：当mCloseButton被点击和setIconified(true)会判断是否调用 //是否调用是在onCloseClicked()里判断，后面会进行分析private OnCloseListener mOnCloseListener;//View类里定义的接口private OnFocusChangeListener mOnQueryTextFocusChangeListener;//里面有2个方法： //onSuggestionSelect(int position)：选择建议可选项（搜索框下方出现的）后触发 //onSuggestionClick(int position)：点击建议可选项后触发private OnSuggestionListener mOnSuggestionListener;//View类里定义的接口private OnClickListener mOnSearchClickListener;//还有其他mOnClickListener，mTextKeyListener等 我们看看OnQueryTextListener是怎样进行监听的： onQueryTextChange(String newText) 12//在构造方法里添加了监听mSearchSrcTextView.addTextChangedListener(mTextWatcher); 然后在mTextWatcher的onTextChanged()方法里调用了SearchView的onTextChanged(CharSequence newText)方法，也就是在这里进行了判断触发: 12345678910111213private void onTextChanged(CharSequence newText) &#123; /** * 省略代码,主要是更新组件 */ //当listener!=null和当文本不一样的时候会触发。 if (mOnQueryChangeListener != null &amp;&amp; !TextUtils.equals(newText, mOldQueryText)) &#123; mOnQueryChangeListener.onQueryTextChange(newText.toString()); &#125; //省略代码&#125; onQueryTextSubmit(String query) 12345678910111213141516171819202122232425262728293031323334353637//同在构造方法里添加了监听mSearchSrcTextView.setOnEditorActionListener(mOnEditorActionListener);private final OnEditorActionListener mOnEditorActionListener = new OnEditorActionListener() &#123; /** * Called when the input method default action key is pressed. */ public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; onSubmitQuery(); return true; &#125;&#125;;private void onSubmitQuery() &#123; CharSequence query = mSearchSrcTextView.getText(); if (query != null &amp;&amp; TextUtils.getTrimmedLength(query) &gt; 0) &#123; //当监听OnQueryChangeListener了之后， //当onQueryTextSubmit() return true的话，是不会执行下面操作的 if (mOnQueryChangeListener == null || !mOnQueryChangeListener.onQueryTextSubmit(query.toString())) &#123; //设置了Searchable后，会startActivity到配置指定的Activity if (mSearchable != null) &#123; launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, query.toString()); &#125; //设置键盘是否显示 setImeVisibility(false); //下拉可选项是用ListPopupWindow显示的，具体可看 AutoCompleteTextView 源码 //搜索提交后，dismiss后就不会继续显示而挡住内容什么的 dismissSuggestions(); &#125; &#125;&#125; 在if里加入!mOnQueryChangeListener.onQueryTextSubmit(query.toString())，这样做就可以让使用者自己决定是否完全自己处理，灵活性也更高。 其他Listener差不多也是这样，那接下来看看其他的。 1.5 CollapsibleActionView接口SearchView实现了CollapsibleActionView接口：onActionViewExpanded()和onActionViewCollapsed(),具体操作就是设置键盘及控件，并使用全局变量mExpandedInActionView记录ActionView是否伸展。只有当SearchView作为MenuItem的时候才会触发，如果是使用v7包的话，想要通过menu获取SearchView就需要使用MenuItemCompat类，具体可以看demo。1MenuItemCompat.getActionView(android.view.MenuItem item); 1.6 状态的保存和恢复SearchView覆写了onSaveInstanceState()和onRestoreInstanceState(Parcelable state)用来保存和恢复状态，为什么要覆写呢？因为需要额外保存boolean mIconified，为此还建了个内部静态类SavedState用来保存mIconified。 123456789//实现了Parcelable序列化static class SavedState extends BaseSavedState &#123; boolean isIconified; /** * 省略其他代码 */&#125; 1.7 关于Suggestions和Searchable如果你使用了Suggestions，而且没有setSearchableInfo，那么当你点击建议可选项的时候会log： 12345678W/SearchView: Search suggestions cursor at row 0 returned exception. java.lang.NullPointerException at android.support.v7.widget.SearchView.createIntentFromSuggestion(SearchView.java:1620) at android.support.v7.widget.SearchView.launchSuggestion(SearchView.java:1436) at android.support.v7.widget.SearchView.onItemClicked(SearchView.java:1349) at android.support.v7.widget.SearchView.access$1800(SearchView.java:103) at android.support.v7.widget.SearchView$10.onItemClick(SearchView.java:1373) ...... 定位到第1620行： 123456789101112131415161718192021222324252627private Intent createIntentFromSuggestion(Cursor c, int actionKey, String actionMsg) &#123; try &#123; // use specific action if supplied, or default action if supplied, or fixed default String action = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_ACTION); //在这里并没有检查mSearchable是否为null if (action == null &amp;&amp; Build.VERSION.SDK_INT &gt;= 8) &#123; action = mSearchable.getSuggestIntentAction(); //第1620行 &#125; /** *省略部分代码 */ return createIntent(action, dataUri, extraData, query, actionKey, actionMsg); &#125; catch (RuntimeException e ) &#123; /** *省略部分代码 */ Log.w(LOG_TAG, \"Search suggestions cursor at row \" + rowNum + \" returned exception.\", e); return null; &#125;&#125; 发现调用mSearchable的方法之前并没有检查mSearchable是否为null，其他地方是有判断的，由于做了catch所以不会crash，也不影响使用，另外，如果setOnSuggestionListener： 1234567891011mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() &#123; @Override public boolean onQueryTextSubmit(String query) &#123; return false; &#125; @Override public boolean onQueryTextChange(String newText) &#123; return true; //返回true &#125;&#125;); onSuggestionClick(int position) 返回 true 就不会执行createIntentFromSuggestion(~)，也就不会log了，但这样，键盘的隐藏和可选项pop的dismiss也不会执行，需要自己处理，使用SearchView的clearFocus()方法就能达到同样的效果。 那既然是报null，那就设置Searchable吧，设置后是会startActivity的(执行完createIntentFromSuggestion(~)后就会执行)。然后效果就是当你点击了可选项就会startActivity，看需求做选择吧。。 1.8 语音搜索功能SearchView还有语音搜索功能(API &gt;= 8)，需要通过配置Searchable来开启，在xml配置文件中加入： 1android:voiceSearchMode=\"showVoiceSearchButton|launchRecognizer\" showVoiceSearchButton显示语音搜索按钮，launchRecognizer表示要启动一个语音识别器来转换成文字传给指定的searchable activity。有个全局变量boolean mVoiceButtonEnabled表示是否启用，在setSearchableInfo(~)方法里进行了设置： 1mVoiceButtonEnabled = IS_AT_LEAST_FROYO &amp;&amp; hasVoiceSearch(); IS_AT_LEAST_FROYO是Build.VERSION.SDK_INT &gt;= 8，为了确保正确性，我试了下，结果并没有显示语言搜索按钮，debug后发现在hasVoiceSearch()里： 123ResolveInfo ri = getContext().getPackageManager().resolveActivity(testIntent, PackageManager.MATCH_DEFAULT_ONLY);return ri != null; 在这里并没有resolve到Activity，结果return false，mVoiceButtonEnabled也就变成false了 终于知道为什么了，原来阉割版的系统都不会出现语音搜索按钮，华为/魅族/Genymotion试过都不行(没有试过全版本系统)，AS自带模拟器可以(有Google服务)，具体应该就是没有resolve到Google语音识别Activity。对语音识别有兴趣的同学可以搜索RecognizerIntent。 1.9 AutoCompleteTextViewReflectorv7包的SearchView使用了反射机制，通过反射拿到AutoCompleteTextView和InputMethodManager隐藏的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041static final AutoCompleteTextViewReflector HIDDEN_METHOD_INVOKER = new AutoCompleteTextViewReflector();private static class AutoCompleteTextViewReflector &#123; private Method doBeforeTextChanged, doAfterTextChanged; private Method ensureImeVisible; private Method showSoftInputUnchecked; AutoCompleteTextViewReflector() &#123; /** * 省略部分代码 */ try &#123; showSoftInputUnchecked = InputMethodManager.class.getMethod( \"showSoftInputUnchecked\", int.class, ResultReceiver.class); showSoftInputUnchecked.setAccessible(true); &#125; catch (NoSuchMethodException e) &#123; // Ah well. &#125; &#125; /** * 省略部分代码 */ void showSoftInputUnchecked(InputMethodManager imm, View view, int flags) &#123; if (showSoftInputUnchecked != null) &#123; try &#123; showSoftInputUnchecked.invoke(imm, flags, null); return; &#125; catch (Exception e) &#123; &#125; &#125; //只有这个方法才有在if后面做处理 // Hidden method failed, call public version instead imm.showSoftInput(view, flags); &#125; &#125; 1.10 onMeasure 测量查看了下onMeasure，发现有个地方还是比较在意的。 当isIconified()返回false的时候，width的mode在最后都会被设置成MeasureSpec.EXACTLY。 在SearchView伸展收缩的时候，onMeasure会被执行多次，width根据其mode改变, 之后mode设置为EXACTLY再调用父类super方法进行测量。 设置为EXACTLY，这样父控件就能确切的决定view的大小，那为什么只对width而不对height进行设置呢? 通过查看默认的 layout，可以看到主要组件的layout_height的大多都是match_parent(对应EXACTLY模式)，而layout_width基本都是wrap_content(对应AT_MOST模式)。 另外，不是只有伸展收缩的时候，onMeasure才会被执行, 点击语音搜索按钮/输入框获取焦点的时候/…也会执行。 1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Let the standard measurements take effect in iconified state. if (isIconified()) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); return; &#125; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); switch (widthMode) &#123; case MeasureSpec.AT_MOST: // If there is an upper limit, don't exceed maximum width (explicit or implicit) if (mMaxWidth &gt; 0) &#123; width = Math.min(mMaxWidth, width); &#125; else &#123; width = Math.min(getPreferredWidth(), width); &#125; break; case MeasureSpec.EXACTLY: // If an exact width is specified, still don't exceed any specified maximum width if (mMaxWidth &gt; 0) &#123; width = Math.min(mMaxWidth, width); &#125; break; case MeasureSpec.UNSPECIFIED: // Use maximum width, if specified, else preferred width width = mMaxWidth &gt; 0 ? mMaxWidth : getPreferredWidth(); break; &#125; widthMode = MeasureSpec.EXACTLY; super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), heightMeasureSpec);&#125; 2. 展望未来在v7包的SearchView里，有一个声明并初始化了的变量，但并没有用到过: 1234private final AppCompatDrawableManager mDrawableManager;//在构造方法里初始化mDrawableManager = AppCompatDrawableManager.get(); 或许后续版本会用到吧! 抱着好奇的心去看了AppCompatDrawableManager源码，但并没有注释说明这个类是干什么用的，看名字只知道是管理Drawable的。 既然这样，那就来看下AppCompatDrawableManager能干些什么吧。 一步一步来，先看看它初始化的时候干了些什么，查看get()方法: 123456789101112131415161718192021222324public static AppCompatDrawableManager get() &#123; //使用了懒汉式 if (INSTANCE == null) &#123; INSTANCE = new AppCompatDrawableManager(); installDefaultInflateDelegates(INSTANCE); &#125; return INSTANCE;&#125;private static void installDefaultInflateDelegates(@NonNull AppCompatDrawableManager manager) &#123; final int sdk = Build.VERSION.SDK_INT; // 只在Android 5.0以下的系统 if (sdk &lt; 21) &#123; // 在需要的时候使用 VectorDrawableCompat 进行自动处理 manager.addDelegate(\"vector\", new VdcInflateDelegate()); if (sdk &gt;= 11) &#123; // AnimatedVectorDrawableCompat 只能在 API v11+ 使用 manager.addDelegate(\"animated-vector\", new AvdcInflateDelegate()); &#125; &#125;&#125; 从这里, 我们可以看出跟Vector(矢量)有关。 VectorDrawable能创建一个基于xml描述的矢量图; AnimatedVectorDrawable使用ObjectAnimator和AnimatorSet为VectorDrawable创建动画。 然后我粗略的看了方法名，有几个关键词: Tint着色，Cache，…… 有兴趣的同学可以搜下相关资料，这里就不再深入了。 如果我哪里分析错了，请大家及时纠正我，谢谢。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Scroller源码解析","date":"2017-07-26T11:58:31.000Z","path":"2017/07/26/Scroller源码解析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 本文分析版本: Android API 22 1. 简介Android开发中，如果我们希望使一个View滑动的话，除了使用属性动画外。我们还可以使用系统提供给我们的两个类Scroller和OverScroller用来实现弹性滑动。在我以前的一篇ViewDragHelper源码分析中我们有讲到过Scroller的作用。那么我们今天就来仔细分析一下Scroller的使用方法以及实现方式。 2. 使用方法在看Scroller的使用方法之前我们需要先了解一下View中的scrollBy()和scrollTo()方法，scrollTo()方法的实现如下： 1234567891011121314151617 public void scrollTo(int x, int y) &#123; //如果当前偏移量变化 if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY;//赋值偏移量 mScrollX = x; mScrollY = y; invalidateParentCaches(); //回调onScrollChanged方法 onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125; &#125; scrollTo()是指将当前视图内容横向偏移x距离，纵向偏移y距离。注意这里是View的内容的偏移，而不是View本身。而scrollBy()方法如下： 123public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; scrollBy()方法里直接调用了scrollTo()方法，表示在当前偏移量的基础上继续偏移(x,y)。现在我们来看看Scroller的用法。SkyScrollerDemo是我写的一个Scroller和OverScroller的使用demo。下面的用法都是来自于这个demo里，大家可以clone下来配合本文一起阅读。本文我们主要研究Scroller。对于OverScroller我在demo里也写了相关的使用方法，在本文的最后我们再做讨论。 Scroller一般需要配合重写computeScroll()一起使用，代码如下： 123456789101112131415161718192021222324252627282930313233public class ScrollTextView extends TextView &#123; private Context mContext; private Scroller mScroller; public ScrollTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.mContext = context; init(); &#125; private void init() &#123; mScroller = new Scroller(mContext); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; offsetLeftAndRight(mScroller.getCurrX() - mLeft); offsetTopAndBottom(mScroller.getCurrY() - mTop); invalidate(); &#125; &#125; //以mLeft,mTop为初始点，在DEFAULT_DURATION的时间内，在Y轴上滑动-400的偏移量 public void startScrollerScroll() &#123; mScroller.startScroll(mLeft, mTop, 0, -400, DEFAULT_DURATION); invalidate(); &#125; //以mLeft,mTop为初始点，并以Y方向上-5000的加速度滑动，最小Y坐标为200，最大Y坐标为1200 public void startScrollerFling() &#123; mScroller.fling(mLeft, mTop, 0, -5000, mLeft, mLeft, 200, 1200); invalidate(); &#125;&#125; 在上面的代码里，当我们调用startScrollerScroll()与startScrollerFling()方法时我们就发现View滑动了。如果以前没了解过Scroller的同学可能会不理解。这里大致分析一下调用流程，首先我们要知道Scroller其实只负责计算，它并不负责滑动View，当我们调用了Scroller的startScrollerScroll()方法时，我们紧接着调用了invalidate()方法。invalidate()方法会使View重新绘制。因此会调用View的draw()方法，在View的draw()方法中又会去调用computeScroll()方法，computeScroll()方法在View中是一个空实现，所以需要我们自己实现computeScroll()方法。在上面的computeScroll()方法中，我们调用了mScroller.computeScrollOffset()方法来计算当前滑动的偏移量。如果还在滑动过程中就会返回true。所以我们就能在if中通过Scroller拿到当前的滑动坐标从而做任何我们想做的处理。在demo里我们根据滑动的偏移量来改变了View的坐标偏移量。从而形成了滑动动画。下面我们解释一下Scroller的两个方法的具体作用： 1.startScroll(int startX, int startY, int dx, int dy, int duration):通过起始点、偏移的距离和滑动的时间来开始滑动。 startX 起始滑动点的X坐标 startY 起始滑动点的Y坐标 dx 滑动的水平偏移量。&gt;0 则表示往左滑动。 dy 滑动的垂直偏移量。&gt;0 则表示往上滑动。 duration 滑动执行的时间 2.fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY) :基于一个快速滑动手势下的滑动。滑动的距离与这个手势最初的加速度有关。 startX 起始滑动点的X坐标 startY 起始滑动点的Y坐标 velocityX X方向上的加速度 velocityY Y方向上的加速度 minX X方向上滑动的最小值，不会滑动超过这个点 maxX X方向上滑动的最大值，不会滑动超过这个点 minY Y方向上滑动的最小值，不会滑动超过这个点 maxY Y方向上滑动的最大值，不会滑动超过这个点 3. 源码分析我们依然通过调用流程来分析Scroller的实现： 1.构造方法12345678910111213141516171819202122public Scroller(Context context) &#123; this(context, null);&#125;public Scroller(Context context, Interpolator interpolator) &#123; this(context, interpolator, context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB);&#125;public Scroller(Context context, Interpolator interpolator, boolean flywheel) &#123; mFinished = true; if (interpolator == null) &#123; mInterpolator = new ViscousFluidInterpolator(); &#125; else &#123; mInterpolator = interpolator; &#125; mPpi = context.getResources().getDisplayMetrics().density * 160.0f; mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction()); mFlywheel = flywheel; mPhysicalCoeff = computeDeceleration(0.84f); // look and feel tuning&#125; 最终都会调用最后一个构造方法。必须传入Context对象。可以传入自定义的interpolator和是否支持飞轮flywheel的功能，当然这两个并不是必须的。如果不传入interpolator会默认创建一个ViscousFluidInterpolator，从字面意义上看是一个粘性流体插值器。对于flywheel是指是否支持在滑动过程中，如果有新的fling()方法调用是否累加加速度。如果不传默认在2.3以上都会支持。剩下就是初始化了一些用于计算的参数。这样就完成了Scroller的初始化了。下面我们来看看startScroll()方法的实现： 2.startScroll()方法的实现123456789101112131415161718192021222324public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; // mMode 分两种方式 1.滑动:SCROLL_MODE 2. 加速度滑动:FLING_MODE mMode = SCROLL_MODE; // 是否滑动结束 这里是开始所以设置为false mFinished = false; // 滑动的时间 mDuration = duration; // 开始的时间 mStartTime = AnimationUtils.currentAnimationTimeMillis(); // 开始滑动点的X坐标 mStartX = startX; // 开始滑动点的Y坐标 mStartY = startY; // 最终滑动到位置的X坐标 mFinalX = startX + dx; // 最终滑动到位置的Y坐标 mFinalY = startY + dy; // X方向上滑动的偏移量 mDeltaX = dx; // Y方向上滑动的偏移量 mDeltaY = dy; // 持续时间的倒数 最终用来计算得到插值器返回的值 mDurationReciprocal = 1.0f / (float) mDuration;&#125; 很简单只是一些变量的赋值。根据我们前面使用方法里的分析，最终会调用computeScrollOffset()方法： 3.computeScrollOffset() 方法中 SCROLL_MODE 的实现12345678910111213141516171819202122232425262728293031// 当你需要知道新的位置的时候调用这个方法，如果动画还未结束则返回truepublic boolean computeScrollOffset() &#123; //如果已经结束 则直接返回false if (mFinished) &#123; return false; &#125; //得到以及度过的时间 int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); //如果还在动画时间内 if (timePassed &lt; mDuration) &#123; switch (mMode) &#123; case SCROLL_MODE: // 根据timePassed * mDurationReciprocal,从mInterpolator中取出当前需要偏移量的比例 final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal); // 赋值给 mCurrX，mCurrY mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(x * mDeltaY); break; case FLING_MODE: ... break; &#125; &#125; else &#123; mCurrX = mFinalX; mCurrY = mFinalY; mFinished = true; &#125; return true;&#125; 首先的到当前时间与滑动开始时间的时间差，如果还在滑动时间内则通过插值器获得当前的进度并乘以总偏移量并赋值给mCurrX，mCurrY。如果已经结束则直接将mFinalX和mFinalY赋值并将mFinished设置\b为true。所以这样我们就能通过getCurrX()和getCurrY()来得到对应的mCurrX和mCurrY来做相应的处理了。整个Scroll的过程就是这样了。 4.fling()方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY) &#123; // 如果前一次滑动还未结束，又调用了新的fling()方法时， // 则累加相同方向上加速度 if (mFlywheel &amp;&amp; !mFinished) &#123; float oldVel = getCurrVelocity(); float dx = (float) (mFinalX - mStartX); float dy = (float) (mFinalY - mStartY); float hyp = FloatMath.sqrt(dx * dx + dy * dy); float ndx = dx / hyp; float ndy = dy / hyp; float oldVelocityX = ndx * oldVel; float oldVelocityY = ndy * oldVel; if (Math.signum(velocityX) == Math.signum(oldVelocityX) &amp;&amp; Math.signum(velocityY) == Math.signum(oldVelocityY)) &#123; velocityX += oldVelocityX; velocityY += oldVelocityY; &#125; &#125; //设置为FLING_MODE mMode = FLING_MODE; mFinished = false; //根据勾股定理获得总加速度 float velocity = FloatMath.sqrt(velocityX * velocityX + velocityY * velocityY); mVelocity = velocity; // 通过加速度得到滑动持续时间 mDuration = getSplineFlingDuration(velocity); mStartTime = AnimationUtils.currentAnimationTimeMillis(); mStartX = startX; mStartY = startY; float coeffX = velocity == 0 ? 1.0f : velocityX / velocity; float coeffY = velocity == 0 ? 1.0f : velocityY / velocity; double totalDistance = getSplineFlingDistance(velocity); mDistance = (int) (totalDistance * Math.signum(velocity)); mMinX = minX; mMaxX = maxX; mMinY = minY; mMaxY = maxY; mFinalX = startX + (int) Math.round(totalDistance * coeffX); // Pin to mMinX &lt;= mFinalX &lt;= mMaxX mFinalX = Math.min(mFinalX, mMaxX); mFinalX = Math.max(mFinalX, mMinX); mFinalY = startY + (int) Math.round(totalDistance * coeffY); // Pin to mMinY &lt;= mFinalY &lt;= mMaxY mFinalY = Math.min(mFinalY, mMaxY); mFinalY = Math.max(mFinalY, mMinY);&#125; 依然是为计算需要的各种变量赋值。因为引入了加速度的概念所以变得相对复杂，首先先判断了如果一次滑动未结束又触发另一次滑动时，是否需要累加加速度。然后是设置mMode为FLING_MODE。然后根据velocityX和velocityY算出总的加速度velocity，紧接着算出这个加速度下可以滑动的距离mDistance。最后再通过x或y方向上的加速度比值以及我们设定的最大值和最小值来给mFinalX或mFinalY赋值。赋值结束后，通过调用invalidate()，最终依然会调用computeScrollOffset()方法： 5.computeScrollOffset() 方法中 FLING_MODE 的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public boolean computeScrollOffset() &#123; if (mFinished) &#123; return false; &#125; int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); if (timePassed &lt; mDuration) &#123; switch (mMode) &#123; case SCROLL_MODE: ... break; case FLING_MODE: // 当前已滑动的时间与总滑动时间的比值 final float t = (float) timePassed / mDuration; final int index = (int) (NB_SAMPLES * t); // 距离系数 float distanceCoef = 1.f; // 加速度系数 float velocityCoef = 0.f; if (index &lt; NB_SAMPLES) &#123; final float t_inf = (float) index / NB_SAMPLES; final float t_sup = (float) (index + 1) / NB_SAMPLES; final float d_inf = SPLINE_POSITION[index]; final float d_sup = SPLINE_POSITION[index + 1]; velocityCoef = (d_sup - d_inf) / (t_sup - t_inf); distanceCoef = d_inf + (t - t_inf) * velocityCoef; &#125; // 计算出当前的加速度 mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f; // 计算出当前的mCurrX 与mCurrY mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX)); // Pin to mMinX &lt;= mCurrX &lt;= mMaxX mCurrX = Math.min(mCurrX, mMaxX); mCurrX = Math.max(mCurrX, mMinX); mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY)); // Pin to mMinY &lt;= mCurrY &lt;= mMaxY mCurrY = Math.min(mCurrY, mMaxY); mCurrY = Math.max(mCurrY, mMinY); // 如果到达了终点 则结束 if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123; mFinished = true; &#125; break; &#125; &#125; else &#123; mCurrX = mFinalX; mCurrY = mFinalY; mFinished = true; &#125; return true;&#125; 由于fling()方法中将mMode赋值为FLING_MODE。所以我们直接来看FLING_MODE中的代码。可以看出根据当前滑动时间与总滑动时间的比例。再根据一个SPLINE_POSITION数组计算出了距离系数distanceCoef与加速度系数velocityCoef。再根据这两个系数计算出当前加速度与当前的mCurrX与mCurrY。关于SPLINE_POSITION的初始化是在下面的静态代码块里赋值的： 1234567891011121314151617181920212223242526272829303132static &#123; float x_min = 0.0f; float y_min = 0.0f; for (int i = 0; i &lt; NB_SAMPLES; i++) &#123; final float alpha = (float) i / NB_SAMPLES; float x_max = 1.0f; float x, tx, coef; while (true) &#123; x = x_min + (x_max - x_min) / 2.0f; coef = 3.0f * x * (1.0f - x); tx = coef * ((1.0f - x) * P1 + x * P2) + x * x * x; if (Math.abs(tx - alpha) &lt; 1E-5) break; if (tx &gt; alpha) x_max = x; else x_min = x; &#125; SPLINE_POSITION[i] = coef * ((1.0f - x) * START_TENSION + x) + x * x * x; float y_max = 1.0f; float y, dy; while (true) &#123; y = y_min + (y_max - y_min) / 2.0f; coef = 3.0f * y * (1.0f - y); dy = coef * ((1.0f - y) * START_TENSION + y) + y * y * y; if (Math.abs(dy - alpha) &lt; 1E-5) break; if (dy &gt; alpha) y_max = y; else y_min = y; &#125; SPLINE_TIME[i] = coef * ((1.0f - y) * P1 + y * P2) + y * y * y; &#125; SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0f;&#125; 我并没有看懂这段代码的实际意义。网上也没有找到比较清晰的解释。通过debug得知SPLINE_POSITION是一个长度为101并且从0-1递增数组。猜想这应该是一个函数模型并且最终用于计算出滑动过程中的加速度与位置。至此Scroller的两个主要方法的实现我们就分析完了。 4. OverScroller解析OverScroller是对Scroller的拓展，它在Scroller的基础上拓展出了更多的方法。OverScroller的fling方法支持滑动到终点之后并超出一段距离并返回，类似于弹性效果。另外一个springBack()方法是指将指定的点平滑滚动到指定的终点上。这个终点由设置的参数决定。原理我们就不再探究了，大家可以自行研究这两个类的差别。最后具体的使用方法在文章最上面的demo里都有提供。可以clone下来帮助理解。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"LruCache源码解析","date":"2017-07-26T11:57:39.000Z","path":"2017/07/26/LruCache源码解析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 1. 简介 LRU 是 Least Recently Used 最近最少使用算法。 曾经，在各大缓存图片的框架没流行的时候。有一种很常用的内存缓存技术：SoftReference 和 WeakReference（软引用和弱引用）。但是走到了 Android 2.3（Level 9）时代，垃圾回收机制更倾向于回收 SoftReference 或 WeakReference 的对象。后来，又来到了 Android3.0，图片缓存在内容中，因为不知道要在是什么时候释放内存，没有策略，没用一种可以预见的场合去将其释放。这就造成了内存溢出。 2. 使用方法当成一个 Map 用就可以了，只不过实现了 LRU 缓存策略。 使用的时候记住几点即可： 1.（必填）你需要提供一个缓存容量作为构造参数。 2.（必填） 覆写 sizeOf 方法 ，自定义设计一条数据放进来的容量计算，如果不覆写就无法预知数据的容量，不能保证缓存容量限定在最大容量以内。 3.（选填） 覆写 entryRemoved 方法 ，你可以知道最少使用的缓存被清除时的数据（ evicted, key, oldValue, newVaule ）。 4.（记住）LruCache是线程安全的，在内部的 get、put、remove 包括 trimToSize 都是安全的（因为都上锁了）。 5.（选填） 还有就是覆写 create 方法 。 一般做到 1、2、3、4就足够了，5可以无视 。 以下是 一个 LruCache 实现 Bitmap 小缓存的案例, entryRemoved 里的自定义逻辑可以无视，想看的可以去到我的我的展示 demo 里的看自定义 entryRemoved 逻辑。1234567891011121314private static final float ONE_MIB = 1024 * 1024;// 7MBprivate static final int CACHE_SIZE = (int) (7 * ONE_MIB);private LruCache&lt;String, Bitmap&gt; bitmapCache;this.bitmapCache = new LruCache&lt;String, Bitmap&gt;(CACHE_SIZE) &#123; protected int sizeOf(String key, Bitmap value) &#123; return value.getByteCount(); &#125; @Override protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123; ... &#125;&#125;; 3. 效果展示LruCache 效果展示 4. 源码分析4.1 LruCache 原理概要解析LruCache 就是 利用 LinkedHashMap 的一个特性（ accessOrder＝true 基于访问顺序 ）再加上对 LinkedHashMap 的数据操作上锁实现的缓存策略。 LruCache 的数据缓存是内存中的。 1.首先设置了内部 LinkedHashMap 构造参数 accessOrder=true， 实现了数据排序按照访问顺序。 2.然后在每次 LruCache.get(K key) 方法里都会调用 LinkedHashMap.get(Object key)。 3.如上述设置了 accessOrder=true 后，每次 LinkedHashMap.get(Object key) 都会进行 LinkedHashMap.makeTail(LinkedEntry&amp;lt;K, V&gt; e)。 4.LinkedHashMap 是双向循环链表，然后每次 LruCache.get -&gt; LinkedHashMap.get 的数据就被放到最末尾了。 5.在 put 和 trimToSize 的方法执行下，如果发生数据量移除，会优先移除掉最前面的数据（因为最新访问的数据在尾部）。 具体解析在： 4.2、4.3、4.4、4.5 4.2 LruCache 的唯一构造方法12345678910111213141516/** * LruCache的构造方法：需要传入最大缓存个数 */public LruCache(int maxSize) &#123; ... this.maxSize = maxSize; /* * 初始化LinkedHashMap * 第一个参数：initialCapacity，初始大小 * 第二个参数：loadFactor，负载因子=0.75f * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 */ this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 第一个参数 initialCapacity 用于初始化该 LinkedHashMap 的大小。 先简单介绍一下 第二个参数 loadFactor，这个其实的 HashMap 里的构造参数，涉及到扩容问题，比如 HashMap 的最大容量是100，那么这里设置0.75f的话，到75容量的时候就会扩容。 主要是第三个参数 accessOrder=true ，这样的话 LinkedHashMap 数据排序就会基于数据的访问顺序，从而实现了 LruCache 核心工作原理。 4.3 LruCache.get(K key)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 根据 key 查询缓存，如果存在于缓存或者被 create 方法创建了。 * 如果值返回了，那么它将被移动到双向循环链表的的尾部。 * 如果没有缓存的值，则返回 null。 */public final V get(K key) &#123; ... V mapValue; synchronized (this) &#123; // 关键点：LinkedHashMap每次get都会基于访问顺序来重整数据顺序 mapValue = map.get(key); // 计算 命中次数 if (mapValue != null) &#123; hitCount++; return mapValue; &#125; // 计算 丢失次数 missCount++; &#125; /* * 官方解释： * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时 * 候，一个冲突的值被添加到Map，我们在Map中删除这个值，释放被创造的值。 */ V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; /*************************** * 不覆写create方法走不到下面 * ***************************/ /* * 正常情况走不到这里 * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑 * 因为默认的 create(K key) 逻辑为null */ synchronized (this) &#123; // 记录 create 的次数 createCount++; // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值 mapValue = map.put(key, createdValue); // 如果之前存在相同key的value，即有冲突。 if (mapValue != null) &#123; /* * 有冲突 * 所以 撤销 刚才的 操作 * 将 之前相同key 的值 重新放回去 */ map.put(key, mapValue); &#125; else &#123; // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, createdValue); &#125; &#125; // 如果上面 判断出了 将要放入的值发生冲突 if (mapValue != null) &#123; /* * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了 * 告诉 自定义 的 entryRemoved 方法 */ entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; // 上面 进行了 size += 操作 所以这里要重整长度 trimToSize(maxSize); return createdValue; &#125;&#125; 上述的 get 方法表面并没有看出哪里有实现了 LRU 的缓存策略。主要在 mapValue = map.get(key);里，调用了 LinkedHashMap 的 get 方法，再加上 LruCache 构造里默认设置 LinkedHashMap 的 accessOrder=true。 4.4 LinkedHashMap.get(Object key)1234567891011121314151617181920212223242526272829303132333435/** * Returns the value of the mapping with the specified key. * * @param key * the key. * @return the value of the mapping with the specified key, or &#123;@code null&#125; * if no mapping for the specified key is found. */@Override public V get(Object key) &#123; /* * This method is overridden to eliminate the need for a polymorphic * invocation in superclass at the expense of code duplication. */ if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; if (e == null) return null; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; &#125; return null;&#125; 其实仔细看 if (accessOrder) 的逻辑即可，如果 accessOrder=true 那么每次 get 都会执行 N 次 makeTail(LinkedEntry&amp;lt;K, V&gt; e) 。 接下来看看： 4.5 LinkedHashMap.makeTail(LinkedEntry&lt;K, V&gt; e)123456789101112131415161718/** * Relinks the given entry to the tail of the list. Under access ordering, * this method is invoked whenever the value of a pre-existing entry is * read by Map.get or modified by Map.put. */private void makeTail(LinkedEntry&lt;K, V&gt; e) &#123; // Unlink e e.prv.nxt = e.nxt; e.nxt.prv = e.prv; // Relink e as tail LinkedEntry&lt;K, V&gt; header = this.header; LinkedEntry&lt;K, V&gt; oldTail = header.prv; e.nxt = header; e.prv = oldTail; oldTail.nxt = header.prv = e; modCount++;&#125; // Unlink e // Relink e as tail LinkedHashMap 是双向循环链表，然后此次 LruCache.get -&gt; LinkedHashMap.get 的数据就被放到最末尾了。 以上就是 LruCache 核心工作原理。 接下来介绍 LruCache 的容量溢出策略。 4.6 LruCache.put(K key, V value)123456789101112public final V put(K key, V value) &#123; ... synchronized (this) &#123; ... // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, value); ... &#125; ... trimToSize(maxSize); return previous;&#125; 记住几点： 1.put 开始的时候确实是把值放入 LinkedHashMap 了，不管超不超过你设定的缓存容量。 2.然后根据 safeSizeOf 方法计算 此次添加数据的容量是多少，并且加到 size 里 。 3.说到 safeSizeOf 就要讲到 sizeOf(K key, V value) 会计算出此次添加数据的大小 。 4.直到 put 要结束时，进行了 trimToSize 才判断 size 是否 大于 maxSize 然后进行最近很少访问数据的移除。 4.7 LruCache.trimToSize(int maxSize)1234567891011121314151617181920212223242526272829303132333435public void trimToSize(int maxSize) &#123; /* * 这是一个死循环， * 1.只有 扩容 的情况下能立即跳出 * 2.非扩容的情况下，map的数据会一个一个删除，直到map里没有值了，就会跳出 */ while (true) &#123; K key; V value; synchronized (this) &#123; // 在重新调整容量大小前，本身容量就为空的话，会出异常的。 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException( getClass().getName() + \".sizeOf() is reporting inconsistent results!\"); &#125; // 如果是 扩容 或者 map为空了，就会中断，因为扩容不会涉及到丢弃数据的情况 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); // 拿到键值对，计算出在容量中的相对长度，然后减去。 size -= safeSizeOf(key, value); // 添加一次收回次数 evictionCount++; &#125; /* * 将最后一次删除的最少访问数据回调出去 */ entryRemoved(true, key, value, null); &#125;&#125; 简单描述：会判断之前 size 是否大于 maxSize 。是的话，直接跳出后什么也不做。不是的话，证明已经溢出容量了。由 makeTail 图已知，最近经常访问的数据在最末尾。拿到一个存放 key 的 Set，然后一直一直从头开始删除，删一个判断是否溢出，直到没有溢出。 最后看看： 4.8 覆写 entryRemoved 的作用entryRemoved被LruCache调用的场景： 1.（put） put 发生 key 冲突时被调用，evicted=false，key=此次 put 的 key，oldValue=被覆盖的冲突 value，newValue=此次 put 的 value。 2.（trimToSize） trimToSize 的时候，只会被调用一次，就是最后一次被删除的最少访问数据带回来。evicted=true，key=最后一次被删除的 key，oldValue=最后一次被删除的 value，newValue=null（此次没有冲突，只是 remove）。 3.（remove） remove的时候，存在对应 key，并且被成功删除后被调用。evicted=false，key=此次 put的 key，oldValue=此次删除的 value，newValue=null（此次没有冲突，只是 remove）。 4.（get后半段，查询丢失后处理情景，不过建议忽略） get 的时候，正常的话不实现自定义 create 的话，代码上看 get 方法只会走一半，如果你实现了自定义的 create(K key) 方法，并且在 你 create 后的值放入 LruCache 中发生 key 冲突时被调用，evicted=false，key=此次 get 的 key，oldValue=被你自定义 create(key)后的 value，newValue=原本存在 map 里的 key-value。 解释一下第四点吧： 第四点是这样的，先 get(key)，然后没拿到，丢失。 如果你提供了 自定义的 create(key) 方法，那么 LruCache 会根据你的逻辑自造一个 value，但是当放入的时候发现冲突了，但是已经放入了。 此时，会将那个冲突的值再让回去覆盖，此时调用上述4.的 entryRemoved。 因为 HashMap 在数据量大情况下，拿数据可能造成丢失，导致前半段查不到，你自定义的 create(key) 放入的时候发现又查到了（有冲突）。然后又急忙把原来的值放回去，此时你就白白create一趟，无所作为，还要走一遍entryRemoved。 综上就如同注释写的一样：12345678910/** * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用 * 或者替换条目值时put调用，默认实现什么都没做。 * 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。 * 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove） evicted=false：put冲突后 或 get里成功create后 * 导致 * 4.newValue!=null，那么则被put()或get()调用。 */protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125; 可以参考我的 demo 里的 entryRemoved 。 4.9 LruCache 局部同步锁在 get, put, trimToSize, remove 四个方法里的 entryRemoved 方法都不在同步块里。因为 entryRemoved 回调的参数都属于方法域参数，不会线程不安全。 本地方法栈和程序计数器是线程隔离的数据区 5. 开源项目中的使用square/picasso 6. 总结LruCache重要的几点： 1.LruCache 是通过 LinkedHashMap 构造方法的第三个参数的 accessOrder=true 实现了 LinkedHashMap 的数据排序基于访问顺序 （最近访问的数据会在链表尾部），在容量溢出的时候，将链表头部的数据移除。从而，实现了 LRU 数据缓存机制。 2.LruCache 在内部的get、put、remove包括 trimToSize 都是安全的（因为都上锁了）。 3.LruCache 自身并没有释放内存，将 LinkedHashMap 的数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存。 4.覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突，也可以去手动释放资源。 5.maxSize 和 sizeOf(K key, V value) 方法的覆写息息相关，必须相同单位。（ 比如 maxSize 是7MB，自定义的 sizeOf 计算每个数据大小的时候必须能算出与MB之间有联系的单位 ） 7. 资源LruCacheActivity LruCache 注释源码 原文链接 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"FloatingActionButton源码解析","date":"2017-07-26T11:55:14.000Z","path":"2017/07/26/FloatingActionButton源码解析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 背景FloatingActionButton（下文以fab代替）是android support design组件库中提供的一个视图控件，是material design设计中fab的官方实现。 此控件的官方介绍如下： Floating action buttons are used for a promoted action. They are distinguished by a circled icon floating above the UI and have motion behaviors that include morphing, launching, and a transferring anchor point. 关于该控件的设计规范及使用场景请参考文档： http://www.google.com/design/spec/components/buttons-floating-action-button.html# 如果你还不了解design组件库，请参考官方博客: http://android-developers.blogspot.hk/2015/05/android-design-support-library.html 开始源码版本:23.3.0 fab间接继承自ImageView（ImageButton是ImageView的子类），因而拥有ImageView的大部分特性。但是其内部还是做了很多定制，我们一一来看。 1. fab的自定义属性、背景着色相关从构造器开始： 12345678910111213141516171819202122public FloatingActionButton(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //检查是否使用Theme.Appcompat主题 ThemeUtils.checkAppCompatTheme(context); //拿到自定义属性并赋值 TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.FloatingActionButton, defStyleAttr, R.style.Widget_Design_FloatingActionButton); ... a.recycle(); final int maxImageSize = (int) getResources().getDimension(R.dimen.design_fab_image_size); mImagePadding = (getSizeDimension() - maxImageSize) / 2; //背景着色 getImpl().setBackgroundDrawable(mBackgroundTint, mBackgroundTintMode, mRippleColor, mBorderWidth); //绘制阴影 getImpl().setElevation(elevation); ... &#125; 构造器中主要是拿到用户设置的自定义属性，比如着色、波纹颜色、大小等等,一共有以下几个属性可以定义。 12345678910111213&lt;declare-styleable name=\"FloatingActionButton\"&gt;&lt;attr name=\"backgroundTint\"/&gt;&lt;attr name=\"backgroundTintMode\"/&gt;&lt;attr format=\"color\" name=\"rippleColor\"/&gt;&lt;attr name=\"fabSize\"&gt; &lt;enum name=\"normal\" value=\"0\"/&gt; &lt;enum name=\"mini\" value=\"1\"/&gt;&lt;/attr&gt;&lt;attr name=\"elevation\"/&gt;&lt;attr format=\"dimension\" name=\"pressedTranslationZ\"/&gt;&lt;attr format=\"dimension\" name=\"borderWidth\"/&gt;&lt;attr format=\"boolean\" name=\"useCompatPadding\"/&gt;&lt;/declare-styleable&gt; 属性的默认值定义如下： 1234567891011&lt;style name=\"Widget.Design.FloatingActionButton\" parent=\"android:Widget\"&gt; &lt;item name=\"android:background\"&gt;@drawable/design_fab_background&lt;/item&gt; &lt;item name=\"backgroundTint\"&gt;?attr/colorAccent&lt;/item&gt; &lt;item name=\"fabSize\"&gt;normal&lt;/item&gt; &lt;item name=\"elevation\"&gt;@dimen/design_fab_elevation&lt;/item&gt; &lt;item name=\"pressedTranslationZ\"&gt;@dimen/design_fab_translation_z_pressed&lt;/item&gt; &lt;item name=\"rippleColor\"&gt;?attr/colorControlHighlight&lt;/item&gt; &lt;item name=\"borderWidth\"&gt;@dimen/design_fab_border_width&lt;/item&gt; &lt;/style&gt; 需要注意的是android:background属性，这里指定了background为design_fab_background,并且不允许改变: 1234@Override public void setBackgroundDrawable(Drawable background) &#123; Log.i(LOG_TAG, \"Setting a custom background is not supported.\"); &#125; 那么我们来看下这个background长啥样： 1234&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"oval\"&gt; &lt;solid android:color=\"@android:color/white\" /&gt;&lt;/shape&gt; 很显然，fab的形状固定为圆形都是因为这个background。那么这里指定了背景色为白色，那是不是fab只能是白色背景呢？当然不是，还有我们牛逼的backgroundTint(即背景着色)，tint是android 5.x引进的一个新特性，可以动态地给drawable资源着色，其原理就是通过给控件设置colorFilter: drawable.java 123public void setColorFilter(@ColorInt int color, @NonNull PorterDuff.Mode mode) &#123; setColorFilter(new PorterDuffColorFilter(color, mode)); &#125; 默认的着色模式为SRC_IN(取交集、显示上层，故底层白色会被忽略)： 1static final PorterDuff.Mode DEFAULT_TINT_MODE = PorterDuff.Mode.SRC_IN; 在fab构造的时候，会指定着色为？attr/colorAccent，即当前主题的colorAccent属性值。然后执行如下代码，进行着色。 12getImpl().setBackgroundDrawable(mBackgroundTint, mBackgroundTintMode, mRippleColor, mBorderWidth); 因为不同版本间的实现略有不同，所以这里会根据不同版本创建不同的FloatingActionButtonImpl实现类： 12345678910private FloatingActionButtonImpl createImpl() &#123; final int sdk = Build.VERSION.SDK_INT; if (sdk &gt;= 21) &#123; return new FloatingActionButtonLollipop(this, new ShadowDelegateImpl()); &#125; else if (sdk &gt;= 14) &#123; return new FloatingActionButtonIcs(this, new ShadowDelegateImpl()); &#125; else &#123; return new FloatingActionButtonEclairMr1(this, new ShadowDelegateImpl()); &#125; &#125; 以5.x为例，其setBackgroundDrawable实现代码如下: 先创建着色的背景drawable。 123456GradientDrawable createShapeDrawable() &#123; GradientDrawable d = new GradientDrawable(); d.setShape(GradientDrawable.OVAL); d.setColor(Color.WHITE); return d; &#125; 再对此drawable设置tint： 1234567891011121314151617181920212223242526272829@Override void setBackgroundDrawable(ColorStateList backgroundTint, PorterDuff.Mode backgroundTintMode, int rippleColor, int borderWidth) &#123; // Now we need to tint the shape background with the tint mShapeDrawable = DrawableCompat.wrap(createShapeDrawable()); //着色，这里会其实就是设置了下colorFilter DrawableCompat.setTintList(mShapeDrawable, backgroundTint); if (backgroundTintMode != null) &#123; DrawableCompat.setTintMode(mShapeDrawable, backgroundTintMode); &#125; final Drawable rippleContent; if (borderWidth &gt; 0) &#123; mBorderDrawable = createBorderDrawable(borderWidth, backgroundTint); rippleContent = new LayerDrawable(new Drawable[]&#123;mBorderDrawable, mShapeDrawable&#125;); &#125; else &#123; mBorderDrawable = null; rippleContent = mShapeDrawable; &#125; mRippleDrawable = new RippleDrawable(ColorStateList.valueOf(rippleColor), rippleContent, null); mContentBackground = mRippleDrawable; mShadowViewDelegate.setBackgroundDrawable(mRippleDrawable); &#125; 经过着色，fab就呈现出我们想要的颜色啦。 2. fab的大小再来看fab的大小，fab有两种大小，一种是NORMAL，一种是MINI，实际大小分别是56dp和40dp，其定义可以在design库的values.xml中看到。 fab如何控制控件大小只有这两种规格呢(这样说不准确，事实上你可以通过设置fab的layout_width/layout_height指定为任意大小，但是我们最好按照MD规范来)?必然是通过复写onMeasure啦: 12345678910111213141516@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //我们希望的大小 final int preferredSize = getSizeDimension(); //最终测量的大小 final int w = resolveAdjustedSize(preferredSize, widthMeasureSpec); final int h = resolveAdjustedSize(preferredSize, heightMeasureSpec); //取小值，保证最后绘制的是圆形 final int d = Math.min(w, h); // We add the shadow's padding to the measured dimension setMeasuredDimension( d + mShadowPadding.left + mShadowPadding.right, d + mShadowPadding.top + mShadowPadding.bottom); &#125; 其中getSizeDimension方法计算出来的是我们期望的大小: 12345678910final int getSizeDimension() &#123; switch (mSize) &#123; case SIZE_MINI: return getResources().getDimensionPixelSize(R.dimen.design_fab_size_mini);//40dp case SIZE_NORMAL: default: return getResources().getDimensionPixelSize(R.dimen.design_fab_size_normal);//56dp &#125; &#125; 但是最终的值还是得看我们设置的LayoutParams。关于控件测量相关内容不在此文介绍范围内，大家可以自行google。 3.fab的动画fab还支持fab以动画的方式显现/隐藏，通常和AppBarLayout一起使用，可以通过hide()/show()两个方法控制。 那么动画是如何实现的呢: 1234567private void show(OnVisibilityChangedListener listener, boolean fromUser) &#123; getImpl().show(wrapOnVisibilityChangedListener(listener), fromUser); &#125;private void hide(@Nullable OnVisibilityChangedListener listener, boolean fromUser) &#123; getImpl().hide(wrapOnVisibilityChangedListener(listener), fromUser);&#125; 这里因为要兼容不同版本，所以具体实现也交给了不同的fab实现类。3.x之后很好办，直接使用属性动画，如果是3.x之前的话，那么只能使用传统的Animation了 以hide()为例，使用属性动画较为简单，直接使用View#animate()即可链式调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override void hide(@Nullable final InternalVisibilityChangedListener listener, final boolean fromUser) &#123; if (mIsHiding || mView.getVisibility() != View.VISIBLE) &#123; // A hide animation is in progress, or we're already hidden. Skip the call if (listener != null) &#123; listener.onHidden(); &#125; return; &#125; if (!ViewCompat.isLaidOut(mView) || mView.isInEditMode()) &#123; // If the view isn't laid out, or we're in the editor, don't run the animation mView.internalSetVisibility(View.GONE, fromUser); if (listener != null) &#123; listener.onHidden(); &#125; &#125; else &#123; mView.animate().cancel(); mView.animate() .scaleX(0f) .scaleY(0f) .alpha(0f) .setDuration(SHOW_HIDE_ANIM_DURATION) .setInterpolator(AnimationUtils.FAST_OUT_LINEAR_IN_INTERPOLATOR) .setListener(new AnimatorListenerAdapter() &#123; private boolean mCancelled; @Override public void onAnimationStart(Animator animation) &#123; mIsHiding = true; mCancelled = false; mView.internalSetVisibility(View.VISIBLE, fromUser); &#125; @Override public void onAnimationCancel(Animator animation) &#123; mIsHiding = false; mCancelled = true; &#125; @Override public void onAnimationEnd(Animator animation) &#123; mIsHiding = false; if (!mCancelled) &#123; mView.internalSetVisibility(View.GONE, fromUser); if (listener != null) &#123; listener.onHidden(); &#125; &#125; &#125; &#125;); &#125; &#125; 如果使用传统动画的话，则先在xml中定义好动画，然后构造Animation实例，启动动画。 12345678910111213141516171819202122232425262728293031@Override void hide(@Nullable final InternalVisibilityChangedListener listener, final boolean fromUser) &#123; if (mIsHiding || mView.getVisibility() != View.VISIBLE) &#123; // A hide animation is in progress, or we're already hidden. Skip the call if (listener != null) &#123; listener.onHidden(); &#125; return; &#125; Animation anim = android.view.animation.AnimationUtils.loadAnimation( mView.getContext(), R.anim.design_fab_out); anim.setInterpolator(AnimationUtils.FAST_OUT_LINEAR_IN_INTERPOLATOR); anim.setDuration(SHOW_HIDE_ANIM_DURATION); anim.setAnimationListener(new AnimationUtils.AnimationListenerAdapter() &#123; @Override public void onAnimationStart(Animation animation) &#123; mIsHiding = true; &#125; @Override public void onAnimationEnd(Animation animation) &#123; mIsHiding = false; mView.internalSetVisibility(View.GONE, fromUser); if (listener != null) &#123; listener.onHidden(); &#125; &#125; &#125;); mView.startAnimation(anim); &#125; 4. fab与CoordinatorLayout的交互 这块内容因为与CoordinatorLayout/CoordinatorLayout#Behavior有很大关联，如果不熟悉，请先google相关资料。本文假设读者对这块内容已经有一定理解。 fab并不直接与CoordinatorLayout联系，而是通过CoordinatorLayout#Behavior作为桥梁。CoordinatorLayout类通过CoordinatorLayout#Behavior可以间接控制其直系子View的行为，能控制什么行为？View测量、布局、touch事件拦截、监听、NestedScroll等等。是不是很屌。 fab内部实现了CoordinatorLayout#Behavior抽象类。该抽象类有如下接口: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public static abstract class Behavior&lt;V extends View&gt; &#123; ... public boolean onInterceptTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev) &#123; return false; &#125; public boolean onTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev) &#123; return false; &#125; ... /** * Determine whether the supplied child view has another specific sibling view as a * layout dependency. * * &lt;p&gt;This method will be called at least once in response to a layout request. If it * returns true for a given child and dependency view pair, the parent CoordinatorLayout * will:&lt;/p&gt; * &lt;ol&gt; * &lt;li&gt;Always lay out this child after the dependent child is laid out, regardless * of child order.&lt;/li&gt; * &lt;li&gt;Call &#123;@link #onDependentViewChanged&#125; when the dependency view's layout or * position changes.&lt;/li&gt; * &lt;/ol&gt; */ public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; /** * Respond to a change in a child's dependent view * * &lt;p&gt;This method is called whenever a dependent view changes in size or position outside * of the standard layout flow. A Behavior may use this method to appropriately update * the child view in response.&lt;/p&gt; * * &lt;p&gt;A view's dependency is determined by * &#123;@link #layoutDependsOn(CoordinatorLayout, android.view.View, android.view.View)&#125; or * if &#123;@code child&#125; has set another view as it's anchor.&lt;/p&gt; * * &lt;p&gt;Note that if a Behavior changes the layout of a child via this method, it should * also be able to reconstruct the correct position in * &#123;@link #onLayoutChild(CoordinatorLayout, android.view.View, int) onLayoutChild&#125;. * &lt;code&gt;onDependentViewChanged&lt;/code&gt; will not be called during normal layout since * the layout of each child view will always happen in dependency order.&lt;/p&gt; * * &lt;p&gt;If the Behavior changes the child view's size or position, it should return true. * The default implementation returns false.&lt;/p&gt; * */ public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; ... /** * Called when the parent CoordinatorLayout is about the lay out the given child view. * * &lt;p&gt;This method can be used to perform custom or modified layout of a child view * in place of the default child layout behavior. The Behavior's implementation can * delegate to the standard CoordinatorLayout measurement behavior by calling * &#123;@link CoordinatorLayout#onLayoutChild(android.view.View, int) * parent.onLayoutChild&#125;.&lt;/p&gt; * * &lt;p&gt;If a Behavior implements * &#123;@link #onDependentViewChanged(CoordinatorLayout, android.view.View, android.view.View)&#125; * to change the position of a view in response to a dependent view changing, it * should also implement &lt;code&gt;onLayoutChild&lt;/code&gt; in such a way that respects those * dependent views. &lt;code&gt;onLayoutChild&lt;/code&gt; will always be called for a dependent view * &lt;em&gt;after&lt;/em&gt; its dependency has been laid out.&lt;/p&gt; * */ public boolean onLayoutChild(CoordinatorLayout parent, V child, int layoutDirection) &#123; return false; &#125; ... public void onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; // Do nothing &#125; &#125; 看到这个抽象类，有两点需要注意: 此抽象类并无抽象方法，也即子类可选择任何想复写的方法进行复写。 此抽象类接受一个泛型。该泛型需要是View的子类。 fab实现此抽象类: 1public static class Behavior extends CoordinatorLayout.Behavior&lt;FloatingActionButton&gt; &#123;&#125; 有选择性地实现了三个方法: 12345678public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency);public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency); public boolean onLayoutChild(CoordinatorLayout parent, FloatingActionButton child, int layoutDirection); fab为啥要实现Behavior?主要是为了配合其他控件完成一些复杂的交互，比较经典的像这个: fab动画效果 fab需要在snackBar弹出的时候自动向上平移，这就得知道SnackBar的状态了，实现Behavior让fab有机会监听到其他CoordinatorLayout子View的状态，并根据状态更新自己。 复写layoutDependsOn方法可以告诉CoordinatorLayout我对哪个View感兴趣， 这里当然是SnackBar了。（注意哦，SnackBar最终展现的是SnackbarLayout，SnackBar本身并不是View） 12345678private static final boolean SNACKBAR_BEHAVIOR_ENABLED = Build.VERSION.SDK_INT &gt;= 11; @Override public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; // We're dependent on all SnackbarLayouts (if enabled) return SNACKBAR_BEHAVIOR_ENABLED &amp;&amp; dependency instanceof Snackbar.SnackbarLayout; &#125; 为什么API LEVEL要大于11呢？因为google偷懒想直接使用属性动画。 前面告诉了CoordinatorLayoutfab对SnackBar比较感兴趣,那么当SnackBar状态改变的时候，CoordinatorLayout就会通过onDependentViewChanged回调通知fab: fab就可以更新自己的UI拉（这里当然是平移喽）: 123456789101112@Override public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; if (dependency instanceof Snackbar.SnackbarLayout) &#123; updateFabTranslationForSnackbar(parent, child, dependency); &#125; else if (dependency instanceof AppBarLayout) &#123; // If we're depending on an AppBarLayout we will show/hide it automatically // if the FAB is anchored to the AppBarLayout updateFabVisibility(parent, (AppBarLayout) dependency, child); &#125; return false; &#125; 如果是SnackBar状态变化了，那么fab就会根据情况进行平移： 1234567891011121314151617181920212223242526272829303132333435363738394041private void updateFabTranslationForSnackbar(CoordinatorLayout parent, final FloatingActionButton fab, View snackbar) &#123; final float targetTransY = getFabTranslationYForSnackbar(parent, fab); if (mFabTranslationY == targetTransY) &#123; // We're already at (or currently animating to) the target value, return... return; &#125; final float currentTransY = ViewCompat.getTranslationY(fab); // Make sure that any current animation is cancelled if (mFabTranslationYAnimator != null &amp;&amp; mFabTranslationYAnimator.isRunning()) &#123; mFabTranslationYAnimator.cancel(); &#125; if (fab.isShown() &amp;&amp; Math.abs(currentTransY - targetTransY) &gt; (fab.getHeight() * 0.667f)) &#123; // If the FAB will be travelling by more than 2/3 of it's height, let's animate // it instead if (mFabTranslationYAnimator == null) &#123; mFabTranslationYAnimator = ViewUtils.createAnimator(); mFabTranslationYAnimator.setInterpolator( AnimationUtils.FAST_OUT_SLOW_IN_INTERPOLATOR); mFabTranslationYAnimator.setUpdateListener( new ValueAnimatorCompat.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimatorCompat animator) &#123; ViewCompat.setTranslationY(fab, animator.getAnimatedFloatValue()); &#125; &#125;); &#125; mFabTranslationYAnimator.setFloatValues(currentTransY, targetTransY); mFabTranslationYAnimator.start(); &#125; else &#123; // Now update the translation Y ViewCompat.setTranslationY(fab, targetTransY); &#125; mFabTranslationY = targetTransY; &#125; 代码里的注释很多，我就不解释了。 前面说到AppBarLayout和fab一起使用可以完成另一个效果，即AppBarLayout伸缩时，fab也可以以动画的形式显现、隐藏，其实现如下： 123456789101112131415161718192021222324252627282930313233private boolean updateFabVisibility(CoordinatorLayout parent, AppBarLayout appBarLayout, FloatingActionButton child) &#123; final CoordinatorLayout.LayoutParams lp = (CoordinatorLayout.LayoutParams) child.getLayoutParams(); //注意到我们必须为fab指定layout_anchor为appBarLayout if (lp.getAnchorId() != appBarLayout.getId()) &#123; // The anchor ID doesn't match the dependency, so we won't automatically // show/hide the FAB return false; &#125; if (child.getUserSetVisibility() != VISIBLE) &#123; // The view isn't set to be visible so skip changing it's visibility return false; &#125; if (mTmpRect == null) &#123; mTmpRect = new Rect(); &#125; // First, let's get the visible rect of the dependency final Rect rect = mTmpRect; ViewGroupUtils.getDescendantRect(parent, appBarLayout, rect); if (rect.bottom &lt;= appBarLayout.getMinimumHeightForVisibleOverlappingContent()) &#123; // If the anchor's bottom is below the seam, we'll animate our FAB out child.hide(null, false); &#125; else &#123; // Else, we'll animate our FAB back in child.show(null, false); &#125; return true; &#125; 除此之外，fab#Behavior还实现了onLayoutChild,主要是为了根据AppBarLayout的当前状态来判断自己是否需要隐藏。 123456789101112131415161718@Override public boolean onLayoutChild(CoordinatorLayout parent, FloatingActionButton child, int layoutDirection) &#123; // First, lets make sure that the visibility of the FAB is consistent final List&lt;View&gt; dependencies = parent.getDependencies(child); for (int i = 0, count = dependencies.size(); i &lt; count; i++) &#123; final View dependency = dependencies.get(i); if (dependency instanceof AppBarLayout &amp;&amp; updateFabVisibility(parent, (AppBarLayout) dependency, child)) &#123; break; &#125; &#125; // Now let the CoordinatorLayout lay out the FAB parent.onLayoutChild(child, layoutDirection); // Now offset it if needed offsetIfNeeded(parent, child); return true; &#125; 此方法会在CoordinatorLayout对孩子布局的时候进行调用(即CoordinatorLayout#onLayout)，CoordinatorLayout会检查所有的直系孩子，是否设置了Behavior，如果设置了，那么就执行其onLayoutChild方法: CoordinatorLayout#onLayout 1234567891011121314@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; final int layoutDirection = ViewCompat.getLayoutDirection(this); final int childCount = mDependencySortedChildren.size(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = mDependencySortedChildren.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Behavior behavior = lp.getBehavior(); if (behavior == null || !behavior.onLayoutChild(this, child, layoutDirection)) &#123; onLayoutChild(child, layoutDirection); &#125; &#125; &#125; 如果该Behavior实现了OnLayoutChild，并且返回了true，那么将不会执行CoordinatorLayout #onLayoutChild,否则执行默认的布局方案。最后一点，这里的Behavior如何生效的呢？通过注解： 12@CoordinatorLayout.DefaultBehavior(FloatingActionButton.Behavior.class)public class FloatingActionButton extends VisibilityAwareImageButton &#123; CoordinatorLayout在解析孩子的LayoutParams时，会check有无注解： 123456789101112131415161718192021LayoutParams getResolvedLayoutParams(View child) &#123; final LayoutParams result = (LayoutParams) child.getLayoutParams(); if (!result.mBehaviorResolved) &#123; Class&lt;?&gt; childClass = child.getClass(); DefaultBehavior defaultBehavior = null; while (childClass != null &amp;&amp; (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) == null) &#123; childClass = childClass.getSuperclass(); &#125; if (defaultBehavior != null) &#123; try &#123; result.setBehavior(defaultBehavior.value().newInstance()); &#125; catch (Exception e) &#123; Log.e(TAG, \"Default behavior class \" + defaultBehavior.value().getName() + \" could not be instantiated. Did you forget a default constructor?\", e); &#125; &#125; result.mBehaviorResolved = true; &#125; return result; &#125; 至此fab解析完毕，谢谢观看！ 如有疑惑，可以issue。 微博：楚奕RX License123456789101112131415161718192021The MIT License (MIT)Copyright (c) 2016 RowandjjPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE. 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"CoordinatorLayout源码分析","date":"2017-07-26T11:53:52.000Z","path":"2017/07/26/CoordinatorLayout源码分析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 CoordinatorLayout 源码分析CoordinatorLayout有一些很有意思的特性，设置anchor、NestedScroll配合Toolbar/TabLayout的显隐or伸缩、Fab的移动等。今天咱就来一探究竟！ 1. 从LayoutParam开始 CoordinatorLayout.LayoutParam中有一些不太一样的属性和元素，在此先进行介绍。 1.1 特殊属性 属性 对应xml属性 用途 AndchorId layout_anchor &amp;layout_anchorGravity 布局时根据自身gravity 与 layout_anchorGravity放置在被anchor的View中 Behavior layout_behavior 辅助Coordinator对View进行layout、nestedScroll的处理 KeyLine layout_keyline &amp; keylines 给Coordinator设置了keylines（整数数组）后，可以为子View设置layout_keyline=&quot;i&quot;使其的水平位置根据对应keylines[i]进行layout。 LastChildRect 无 记录每一次Layout的位置，从而判断是否新的一帧改变了位置 注： keyline是一个非常奇怪的属性，我在看源码时才第一次看到到这玩意，网上的资料也非常之少。分析下来，就是如果设置了keyline，那么gravity就会被无视，直接放置在对应的水平位置keyline上。CoordinatorLayout里面也没有其他的特性是根据keyline实现的，个人认为没卵用，本文对它的分析基本都会略过。 1.2 依赖关系假设此时有两个View: A 和B，那么有两种情况会导致依赖关系： A的anchor是B ； A的behavior对B有依赖（比如FloatingActionButton依赖SnackBar)。 依赖关系建立的前提是两个View在同一个Coordinatorlayout中。 CoordinatorLayout中维护了一个mDependencySortedChildren列表，里面含有所有的子View，按依赖关系排序，被依赖者排在前面。我们可以看一下用来排序的Comparator： 12345678910111213141516final Comparator&lt;View&gt; mLayoutDependencyComparator = new Comparator&lt;View&gt;() &#123; @Override public int compare(View lhs, View rhs) &#123; if (lhs == rhs) &#123; return 0; &#125; else if (((LayoutParams) lhs.getLayoutParams()).dependsOn( CoordinatorLayout.this, lhs, rhs)) &#123; return 1; &#125; else if (((LayoutParams) rhs.getLayoutParams()).dependsOn( CoordinatorLayout.this, rhs, lhs)) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125;; 注意，在建立mDependencySortedChildren并排序完成之后（在measure的第一步处理完成），每次对子View的遍历都是通过它进行顺序遍历，保证了被依赖的View最先被处理。 1.3 Behavior在CoordinatorLayout中定义了Behavior类，它是用来辅助layout的工具。如果一个CoordinatorLayout的直接子View设置了Behavior（或者通过类注解@DefaultBehavior指定Behavior），则该Behavior会储存在该View的LayoutParam中。 注意：不是CoordinatorLayout的直接子View，设置Behavior是无效的。你可以看到任何一处对于Behavior的处理都是直接getChildCount（）遍历。 在Behavior中有几类功能，我们一一进行介绍： 1.3.1 触摸响应类Behavior中有两个函数：onInterceptTouchEvent、 onTouchEvent。在CoordinatorLayout每次触发对应事件的时候会选择一个最适合的子View的Behavior执行对应函数。我们来看一下CoordinatorLayout是怎么分发和处理Touch事件的： intercept12345678910111213141516171819202122232425@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); // 重置响应的Behavoir if (action == MotionEvent.ACTION_DOWN) &#123; resetTouchBehaviors(); &#125; // 在这里选择一个最佳Behavior进行处理 final boolean intercepted = performIntercept(ev, TYPE_ON_INTERCEPT); if (cancelEvent != null) &#123; cancelEvent.recycle(); &#125; // 重置响应的Behavior if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123; resetTouchBehaviors(); &#125; return intercepted;&#125; 在performIntercept去选择一个最适合的Behavior来进行处理，这个方法不仅用于onInterceptTouchEvent，并且也用于onTouchEvent，根据传入type不同来识别对应方法。我们来看看它的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243private boolean performIntercept(MotionEvent ev, final int type) &#123; boolean intercepted = false; boolean newBlock = false; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); final List&lt;View&gt; topmostChildList = mTempList1; // API&gt;=21时，使用elevation由低到高排列View；API&lt;21时，按View添加顺序排列 getTopSortedChildren(topmostChildList); final int childCount = topmostChildList.size(); for (int i = 0; i &lt; childCount; i) &#123; final View child = topmostChildList.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Behavior b = lp.getBehavior(); // ...(省略代码) 如果此次判定intercept，则对上次的Behavior发送CANCEL事件。 // 根据传入type不同调用不同的方法 if (!intercepted &amp;&amp; b != null) &#123; switch (type) &#123; case TYPE_ON_INTERCEPT: intercepted = b.onInterceptTouchEvent(this, child, ev); break; case TYPE_ON_TOUCH: intercepted = b.onTouchEvent(this, child, ev); break; &#125; if (intercepted) &#123; mBehaviorTouchView = child; &#125; &#125; //...(省略代码) 如果Behavior.blocksInteractionBelow()返回true，则不处理后续的事件。 &#125; topmostChildList.clear(); return intercepted;&#125; 1.3.2 依赖关系类 这部分比较简单，就俩函数： layoutDependsOn：返回true则表示对另一个View有依赖关系； onDependentViewChanged&amp;onDependentViewRemoved：如果被依赖的View在正常layout之后仍有size/position上的变化，或者被remove掉，都会触发对应方法。 那么问题来了，CoordinatorLayout是怎么监听这个被依赖的View改变的事件的呢？ 原来它里面有一个ViewTreeObserver.OnPreDrawListener，它在onMeasure的时候被添加到了ViewTreeObserver中，这样每一帧被绘制出来之前都会调用这个回调。 1234567class OnPreDrawListener implements ViewTreeObserver.OnPreDrawListener &#123; @Override public boolean onPreDraw() &#123; dispatchOnDependentViewChanged(false); return true; &#125;&#125; 这个dispatchOnDependentViewChanged里面代码比较多，就不放上来了，总结下来就是这样： 根据依赖关系遍历子View，对每一个View做如下操作 判断一下新的布局边界与lastChildRect是否相同，是则记录新的布局边界为lastChildRect，并继续后续流程，否则跳过； 对于之后每一个View，如果它依赖于本View，则调用它的Behavior.onDependentViewChanged（如果有Behavior的话）。 至于onDependentViewRemoved，是在初始化的时候就会调用ViewGroup.setOnHierarchyChangeListener()方法设置一个OnHierarchyChangeListener，这样每次add和remove子View的时候就会接收到回调，同时对相应依赖关系的View进行处理。 1.3.3 布局类onMeasureChild&amp;onLayoutChild：如果重写了该方法并返回true，则CoordinatorLayout会使用Behavior对这个子View进行measure/layout。具体的可以见下面的Measure&amp;Layout 1.3.4 嵌套滑动类CoordinatorLayout实现了NestedScrollingParent，当CoordinatorLayout内有一个支持NestedScroll的子View时，它的嵌套滑动事件通过NestedScrollingParent的回调分发到各直接子View的Behavior处理。虽然Behavior类没有实现NestedScrollingParent，但是实际上它的方法都有。有兴趣的同学可以去看看这个类，我们这里重点讲CoordinatorLayout的分发过程。 各个事件的分发过程类似，此处就举一个例子： 1234567891011121314151617181920public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123; boolean handled = false; final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i) &#123; final View view = getChildAt(i); final LayoutParams lp = (LayoutParams) view.getLayoutParams(); final Behavior viewBehavior = lp.getBehavior(); if (viewBehavior != null) &#123; final boolean accepted = viewBehavior.onStartNestedScroll(this, view, child, target, nestedScrollAxes); handled |= accepted; lp.acceptNestedScroll(accepted); &#125; else &#123; lp.acceptNestedScroll(false); &#125; &#125; return handled;&#125; 非常简单吧，就遍历一下直接子View，每个都调一下对应的回调方法，只要有任何一个子View的behavior消耗了这个事件，就算消耗了这个事件。 ##2. Measure&amp;Layout 我们知道，ViewGroup要把子View准确地放置到屏幕上都是要走onMeasure onLayout的，那么我们看看CoordinatorLayout在这里干了什么。 在看懂时请确保你明白measure/layout的意义以及基本用法，否则可能会导致身体不适=。= 2.1 Measure最直接的就是看代码，如果不喜欢，可以跳过代码看总结。： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; prepareChildren(); /* 解析依赖关系，并用1.2中提到的Comparator对View按依赖关系进行排序 */ ensurePreDrawListener(); /* 若PreDrawListener未添加，则添加到ViewTreeObserver */ //...(省略代码) 解析paddingmeasureSpec final int childCount = mDependencySortedChildren.size(); for (int i = 0; i &lt; childCount; i) &#123; final View child = mDependencySortedChildren.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //...(省略代码)处理keyline int childWidthMeasureSpec = widthMeasureSpec; int childHeightMeasureSpec = heightMeasureSpec; //...(省略代码) 处理由于fitSystemWindows带来的padding /* 如果childView有Behavior并且它的onMeasureChild返回true，则由behavior来对childView进行measure，否则就自己measure. */ final Behavior b = lp.getBehavior(); if (b == null || !b.onMeasureChild(this, child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0)) &#123; onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0); &#125; /* 取最大的child width/height 加上margin 作为已经消耗的尺寸。 */ widthUsed = Math.max(widthUsed, widthPadding child.getMeasuredWidth() lp.leftMargin lp.rightMargin); heightUsed = Math.max(heightUsed, heightPadding child.getMeasuredHeight() lp.topMargin lp.bottomMargin); childState = ViewCompat.combineMeasuredStates(childState, ViewCompat.getMeasuredState(child)); &#125; /* 设置自身的measure尺寸 */ final int width = ViewCompat.resolveSizeAndState(widthUsed, widthMeasureSpec, childState &amp; ViewCompat.MEASURED_STATE_MASK); final int height = ViewCompat.resolveSizeAndState(heightUsed, heightMeasureSpec, childState &lt;&lt; ViewCompat.MEASURED_HEIGHT_STATE_SHIFT); setMeasuredDimension(width, height);&#125; 总结下来，onMeasure干了这么几件事： 根据依赖关系对所有子View进行排序 保证OnPreDrawListener被添加 按依赖关系遍历子View: 如果子View有Behavior，并且它的onMeasureChild返回true，则使用Behavior进行measure；否则直接使用measureSpec对子View进行measure； 取子VIew最大的measure尺寸为已使用的measure尺寸。 更新本身的Measure尺寸。 2.2 Layout 在onLayout中，我们可以看到CoordinatorLayout会对每一个子View依照以下判断顺序进行layout： 如果子View设置了Behavior，并且该Behavior的behavior.onLayoutChild返回true，则使用behavior.onLayoutChild对该子View进行layout； 如果Behavior不进行layout，则进入自身的onLayoutChild()，内部依次进行如下判断： 如果子View设置了Anchor，则调用layoutChildWithAnchor（根据anchor进行layout）； 如果子View含有keyline，则调用layoutChildWithKeyline（根据keyline进行layout）； 如果以上判断都不符合，则直接将View根据padding/margin/measure结果按照Gravity放置。 我们一一来看一下这些过程。 2.2.1 使用Behavior进行layout 默认的Behavior的onLayoutChild都是返回false的，那么我们看看FloatingActionButton的默认Behavior是怎么处理的吧： 1234567891011121314151617181920@Overridepublic boolean onLayoutChild(CoordinatorLayout parent, FloatingActionButton child, int layoutDirection) &#123; // 检查该FAB是否依赖AppBarLayout final List&lt;View&gt; dependencies = parent.getDependencies(child); for (int i = 0, count = dependencies.size(); i &lt; count; i) &#123; final View dependency = dependencies.get(i); if (dependency instanceof AppBarLayout &amp;&amp; updateFabVisibility(parent, (AppBarLayout) dependency, child)) &#123; break; &#125; &#125; // 调用CoordinatorLayout的onLayoutChild对FAB进行layout parent.onLayoutChild(child, layoutDirection); // 在API &lt; 21时，需要手动offset来让出阴影的位置 offsetIfNeeded(parent, child); return true;&#125; 这里主要是处理了如果FAB设置了AppBarLayout为anchor时（此时会对AppBarLayout有依赖），则当AppBarLayout的高度不足以显示FAB时将其隐藏）。 之后它会手动调用CoordinatorLayout自身的onLayoutChild方法进行layout，即上述判断的第二步，那我们继续往下看。 2.2.2 使用Anchor进行layout 如果View设置了anchor，那么都会调用layoutWithAnchor进行layout，代码与解释如下： 12345678910111213private void layoutChildWithAnchor(View child, View anchor, int layoutDirection) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect anchorRect = mTempRect1; final Rect childRect = mTempRect2; /* 1. 找到被anchor的View的布局边界 */ getDescendantRect(anchor, anchorRect); /* 2. 获取到被anchor的View布局边界之后，配合layout_anchorGravity与自身的gravity获取到最终要layout到的边界 */ getDesiredAnchoredChildRect(child, layoutDirection, anchorRect, childRect); child.layout(childRect.left, childRect.top, childRect.right, childRect.bottom);&#125; 这里用到的两个关键函数就是getDescendantRect与getDesiredAnchoredChildRect，它们的目的在我添加的注释中进行了解释，为保证文章的可读性就不再把代码放上来了，有兴趣的同学可以再自己去挖掘相应代码~~ 2.2.3 直接layout如果之前的都不符合，就会走到这一步，我们看看它是怎么layout的： 12345678910111213141516private void layoutChild(View child, int layoutDirection) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect parent = mTempRect1; parent.set(getPaddingLeft() lp.leftMargin, getPaddingTop() lp.topMargin, getWidth() - getPaddingRight() - lp.rightMargin, getHeight() - getPaddingBottom() - lp.bottomMargin); //...(省略代码) 处理由于fitsSystemWindows带来的inset // 按照Gravity与measure尺寸在父控件里面找到自己的位置，并进行layout。 final Rect out = mTempRect2; GravityCompat.apply(resolveGravity(lp.gravity), child.getMeasuredWidth(), child.getMeasuredHeight(), parent, out, layoutDirection); child.layout(out.left, out.top, out.right, out.bottom); &#125; ##3 总结 CoordinatorLayout的特性总结下来就是两个方面： 可以设置anchor，被依赖的View变化自身也会变化； 可以设置behavior，当内部有支持嵌套滑动的控件时处理NestedScroll事件； 这两个特性导致的子View之间的依赖关系让界面的交互更有意思。有兴趣的同学可以再去看AppBarLayout、FloatingActionButton、SnackBar的源码~~ 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"CompoundButton源码分析","date":"2017-07-26T11:52:49.000Z","path":"2017/07/26/CompoundButton源码分析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 CompoundButton 是一个有两种状态（选中和未选中 / checkd unchecked）的Button。当你按下（pressed）或者点击（clicked），它的状态会自动改变。 特点 是一个抽象类（abstract），所以我们不能直接使用它，只有自定义实现或者系统已经提供的它的一直子类（ToggleButton，Checkbox，RadioButton 等等） 继承自Button，而Button 继承自TextView，所以Button，TextView 的特性CompoundButton 都是具备的 实现自Checkable 接口（interface），利用它可以设置状态（setChecked(boolean checked)），获取状态（isChecked()）和切换状态（toggle()） 最后的效果图就是这样的。 分析1234567891011121314151617// 选中和未选中的状态private boolean mChecked;private boolean mBroadcasting;private Drawable mButtonDrawable;private ColorStateList mButtonTintList = null;// 就是水波纹和背景颜色混合的方式private PorterDuff.Mode mButtonTintMode = null;private boolean mHasButtonTint = false;private boolean mHasButtonTintMode = false;// 状态监听private OnCheckedChangeListener mOnCheckedChangeListener;private OnCheckedChangeListener mOnCheckedChangeWidgetListener; 这是一些局部变量，在后面的分析会用到。 我们先来看看CompoundButton 自定义控件有哪些属性 \\data\\res\\values\\attrs.xml12345678910111213&lt;declare-styleable name=\"CompoundButton\"&gt; &lt;!-- 设置状态 true: 选中; false: 未选中 --&gt; &lt;attr name=\"checked\" format=\"boolean\" /&gt; &lt;!-- 绘制按钮图形，一般为Drawable 资源 (e.g. checkbox, radio button, etc). --&gt; &lt;attr name=\"button\" format=\"reference\" /&gt; &lt;!-- 对绘制的按钮图形着色 --&gt; &lt;attr name=\"buttonTint\" format=\"color\" /&gt; &lt;!-- 对着色设置模式 --&gt; &lt;attr name=\"buttonTintMode\"&gt; &lt;enum name=\"src_over\" value=\"3\" /&gt; ... &lt;/attr&gt; &lt;/declare-styleable&gt; 然后再来看看怎么绘制，先来看看构造方法1234567891011121314151617181920212223242526272829303132333435public CompoundButton(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); // 这里的获取自定义的CompoundButton 就是上面的定义的CompoundButton final TypedArray a = context.obtainStyledAttributes( attrs, com.android.internal.R.styleable.CompoundButton, defStyleAttr, defStyleRes); // 用于绘制按钮图形 final Drawable d = a.getDrawable(com.android.internal.R.styleable.CompoundButton_button); if (d != null) &#123; setButtonDrawable(d); &#125; // 对绘制的按钮图形着色设置模式 if (a.hasValue(R.styleable.CompoundButton_buttonTintMode)) &#123; mButtonTintMode = Drawable.parseTintMode(a.getInt( R.styleable.CompoundButton_buttonTintMode, -1), mButtonTintMode); mHasButtonTintMode = true; &#125; // 对绘制的按钮图形着色 if (a.hasValue(R.styleable.CompoundButton_buttonTint)) &#123; mButtonTintList = a.getColorStateList(R.styleable.CompoundButton_buttonTint); mHasButtonTint = true; &#125; // 设置状态 final boolean checked = a.getBoolean( com.android.internal.R.styleable.CompoundButton_checked, false); setChecked(checked); a.re cycle(); applyButtonTint();&#125; 在构造方法中，获取自定义属性的各个属性， button：用于绘制按钮图形，然后调用setButtonDrawable() 来绘制。 buttonTint：绘制的按钮着色。使用一个boolean 标识符来设置的，然后会在applyButtonTint() 中统一处理。它们两个分别用作给和 buttonTintMode：和设置着色模式。设置方式和buttonTint 几乎一样。不过它的一些属性，参考这篇文章来看看具体不同的着色模式效果是怎么样的。android5.x新特性之Tinting checked：是设置选中状态，在setChecked() 中设置。 绘制按钮图形123456789101112131415161718192021222324@Nullablepublic void setButtonDrawable(@Nullable Drawable drawable) &#123; if (mButtonDrawable != drawable) &#123; if (mButtonDrawable != null) &#123; // 取消对View 的引用 mButtonDrawable.setCallback(null); // 取消绘制对象相关联的调度,当我们重新绘制一个Drawable，可以调用此方法 unscheduleDrawable(mButtonDrawable); &#125; mButtonDrawable = drawable; if (drawable != null) &#123; drawable.setCallback(this); drawable.setLayoutDirection(getLayoutDirection()); if (drawable.isStateful()) &#123; drawable.setState(getDrawableState()); &#125; drawable.setVisible(getVisibility() == VISIBLE, false); setMinHeight(drawable.getIntrinsicHeight()); applyButtonTint(); &#125; &#125;&#125; 这个方法，就是用于绘制按钮图形，首先会判断我们设置的Drawable 和初始会的mButtonDrawable 是否相等，如果不等，将会对初始化的mButtonDrawable 对象，取消对View 的引用（setCallback(null)），并且取消mButtonDrawable 相关联调度（unscheduleDrawable()），然后将我们新设置的Drawable 赋值给mButtonDrawable 对象，然后再设置引用，设置布局的方向，然后判断如果状态改变时，重新设置状态。最后调用applyButtonTint()。 着色12345678910111213141516171819private void applyButtonTint() &#123; if (mButtonDrawable != null &amp;&amp; (mHasButtonTint || mHasButtonTintMode)) &#123; mButtonDrawable = mButtonDrawable.mutate(); if (mHasButtonTint) &#123; mButtonDrawable.setTintList(mButtonTintList); &#125; if (mHasButtonTintMode) &#123; mButtonDrawable.setTintMode(mButtonTintMode); &#125; // The drawable (or one of its children) may not have been // stateful before applying the tint, so let's try again. if (mButtonDrawable.isStateful()) &#123; mButtonDrawable.setState(getDrawableState()); &#125; &#125;&#125; 这个方法主要就是设置mButtonDrawable 的Tint（着色）和TintMode（着色模式），之前在构造方法，setButtonDrawable() 方法中都会调用此方法，因为这两个属性都是基于mButtonDrawable 来设置的，而这个两个属性是根据两个Boolean 属性mHasButtonTint 和mHasButtonTintMode 来识别的，然后为true，就表示设置。而他们两个属性也有setButtonTintList 和setButtonTintMode() 方法来设置两个属性，将两个boolean 属性设置为true，并且调用applyButtonTint() 来设置的。 绘制1234567891011121314151617181920212223242526272829303132333435363738394041424344protected void onDraw(Canvas canvas) &#123; final Drawable buttonDrawable = mButtonDrawable; if (buttonDrawable != null) &#123; final int verticalGravity = getGravity() &amp; Gravity.VERTICAL_GRAVITY_MASK; final int drawableHeight = buttonDrawable.getIntrinsicHeight(); final int drawableWidth = buttonDrawable.getIntrinsicWidth(); final int top; switch (verticalGravity) &#123; case Gravity.BOTTOM: top = getHeight() - drawableHeight; break; case Gravity.CENTER_VERTICAL: top = (getHeight() - drawableHeight) / 2; break; default: top = 0; &#125; final int bottom = top + drawableHeight; final int left = isLayoutRtl() ? getWidth() - drawableWidth : 0; final int right = isLayoutRtl() ? getWidth() : drawableWidth; buttonDrawable.setBounds(left, top, right, bottom); final Drawable background = getBackground(); if (background != null) &#123; background.setHotspotBounds(left, top, right, bottom); &#125; &#125; super.onDraw(canvas); if (buttonDrawable != null) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; if (scrollX == 0 &amp;&amp; scrollY == 0) &#123; buttonDrawable.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); buttonDrawable.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125; &#125;&#125; 这些属性都初始化好了，那就可以来绘制了，我们都知道自定义重写onDraw() 方法来绘制视图，CompoundButton 也重写了此方法，将我们设置了各种属性的mButtonDrawable 复制给局部变量buttonDrawable，然后根据对其方式（Gravity） 属性来来具体绘制buttonDrawable。然后调用父类的onDraw()，最后在根据时候是滑动通过Canvas 来绘制，如果水平和垂直滑动为0，则直接绘制即可，如果不为零则需要调用translate 对canvas 的重新绘制。 设置选中(checked)状态123456789101112131415161718192021222324252627282930313233public void setChecked(boolean checked) &#123; if (mChecked != checked) &#123; mChecked = checked; refreshDrawableState(); notifyViewAccessibilityStateChangedIfNeeded( AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED); // 避免多次调用setChecked() 来多次调用回调监听 if (mBroadcasting) &#123; return; &#125; mBroadcasting = true; if (mOnCheckedChangeListener != null) &#123; mOnCheckedChangeListener.onCheckedChanged(this, mChecked); &#125; if (mOnCheckedChangeWidgetListener != null) &#123; mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked); &#125; mBroadcasting = false; &#125;&#125;// 设置监状态听public void setOnCheckedChangeListener(OnCheckedChangeListener listener) &#123; mOnCheckedChangeListener = listener;&#125;void setOnCheckedChangeWidgetListener(OnCheckedChangeListener listener) &#123; mOnCheckedChangeWidgetListener = listener;&#125; 设置状态，就是传入一个Boolean 值来设置状态，如果和初始化的mChecked 相反，才会调用，然后调用refreshDrawableState() 来刷新绘制的状态，然后下面就是设置状态改变的监听，通过mBroadcasting 属性来避免多次设置回调，每次调用mBroadcasting，如果为true，则返回。发现有两个监听，我们仔细看下面setXxxListener() 的方法，而下面那个setOnCheckedChangeWidgetListener() 方法不是Public，所以说不是对外开放的，我们是不能调用的，文档中说明是仅供内部使用。因此我们想要监听选中状态，可以使用setOnCheckedChangeListener()。重写onCheckedChanged(CompoundButton buttonView, boolean isChecked) 即可。对了，除了setChecked() 可以设置状态，toggle() 每次也会setChecked() 方法，每次都会讲状态设置为相反的。还有isChecked() 方法，判断当前的选中状态。 状态保存123456789101112131415161718192021222324252627282930313233343536373839404142434445static class SavedState extends BaseSavedState &#123; boolean checked; SavedState(Parcelable superState) &#123; super(superState); &#125; private SavedState(Parcel in) &#123; super(in); checked = (Boolean)in.readValue(null); &#125; @Override public void writeToParcel(Parcel out, int flags) &#123; super.writeToParcel(out, flags); out.writeValue(checked); &#125; public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = new Parcelable.Creator&lt;SavedState&gt;() &#123; public SavedState createFromParcel(Parcel in) &#123; return new SavedState(in); &#125; public SavedState[] newArray(int size) &#123; return new SavedState[size]; &#125; &#125;;&#125;@Overridepublic Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); SavedState ss = new SavedState(superState); ss.checked = isChecked(); return ss;&#125;@Overridepublic void onRestoreInstanceState(Parcelable state) &#123; SavedState ss = (SavedState) state; super.onRestoreInstanceState(ss.getSuperState()); setChecked(ss.checked); requestLayout();&#125; 保存状态是自定义一个SavedState，继承自BaseSavedState，然后Parcelable 将Boobean 类型checked 属性序列化，判断是否选中，在onSaveInstanceState() 中，保存，然后在onRestoreInstanceState() 获取序列化的属性，重新调用setChecked() 设置属性。 Checkbox/ToggleButtonCheckbox 和ToggleButton 的实现那都是继承自CompoundButton，可以看下面这两篇文章。 ToggleButton/Checkbox 的源码分析 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"bindService源码分析","date":"2017-07-26T11:46:44.000Z","path":"2017/07/26/bindService源码分析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 bindService 源码分析 【进行中】简介客户端通过 ContextWrapper.bindService() 方法来绑定服务，本地对 bindService 的过程进行源码分析。 整体时序图 源码分析1. 客户端调用 bindService() 绑定服务 1234567891011// MainActivity.java@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent().setComponent(new ComponentName( \"org.xdty.remoteservice\", \"org.xdty.remoteservice.RemoteService\")); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#125; Activity.bindService() 最终调用的是 ContextImpl.bindService() 方法 2. ContextImpl.bindService() 1234567891011121314151617181920212223242526272829// ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, Process.myUserHandle());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; IServiceConnection sd; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags); ... try &#123; IBinder token = getActivityToken(); ... int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); ... return res != 0; &#125; catch (RemoteException e) &#123; ... &#125;&#125; 可见接着调用了 ActivityManagerNative.getDefault().bindService() 方法 这里的 mPackageInfo 是一个 LoadedApk 实例。mMainThread 则是一个 ActivityThread。 3. ActivityManagerNative.getDefault().bindService() 注意 ActivityManagerNative.java 文件中有两个类 ActivityManagerNative ActivityManagerProxy, 他们都实现了 IActivityManager接口，而 ActivityManagerNative 则继承了 Binder 对象，相当于 AIDL 中的 Stub，`ActivityManagerProxy 则相当于 Proxy。 首先看 ActivityManagerNative.getDefault() 123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; 再找 gDefault 1234567private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); IActivityManager am = asInterface(b); return am; &#125;&#125;; 再来看 asInterface() 方法 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; 很容易发现其返回了一个 ActivityManagerProxy 对象，所以调用的 bindService() 方法实现在 ActivityManagerProxy 类中。注意这里不要和抽象类 ActivityManagerNative.class 继承的 bindService() 方法混淆，它的实现在子类 ActivityManagerService 中。接下来我们继续看 Proxy 中的实现： 123456789101112131415161718192021222324// ActivityManagerNative.java// ActivityManagerProxy.classpublic int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeStrongBinder(token); service.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(connection.asBinder()); data.writeInt(flags); data.writeString(callingPackage); data.writeInt(userId); mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); data.recycle(); reply.recycle(); return res;&#125; 可见这里将要绑定的服务信息打包，通过一个 binder 对象，发送了 BIND_SERVICE_TRANSACTION 命令给 ActivityManager 的服务端。而 ActivityManager 的服务端就是 ActivityManagerNative，所以接着命令会被 ActivityManagerNative.onTransact() 处理 4. ActivityManagerNative.onTransact() ActivityManagerNative 对 BIND_SERVICE_TRANSACTION 命令重新解包并通过子类实现的 ActivityManagerNative.bindService() 处理，注意这里的 bindService() 和上文的 ActivityManagerProxy.bindService() 不同。 1234567891011121314151617181920212223242526 public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; ... case BIND_SERVICE_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); IBinder token = data.readStrongBinder(); Intent service = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); b = data.readStrongBinder(); int fl = data.readInt(); String callingPackage = data.readString(); int userId = data.readInt(); IServiceConnection conn = IServiceConnection.Stub.asInterface(b); int res = bindService(app, token, service, resolvedType, conn, fl, callingPackage, userId); reply.writeNoException(); reply.writeInt(res); return true; &#125; ...&#125; 5. ActivityManagerService.bindService() 我们继续看 ActivityManagerNative 的子类 ActivityManagerService 对 bindService() 方法的实现： 123456789public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; ... synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId); &#125;&#125; 可见通过 mServices.bindServiceLocked() 方法又传递给了下一层，这里的 mServices 则是一个 ActiveServices 实例。我们继续追踪 ActiveServices.bindServiceLocked() 6. ActiveServices.bindServiceLocked() 接下来看 bindServiceLocked() 关键代码片断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; // 获取当前应用的进程记录 final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); // 获取当前 Activity 记录 ActivityRecord activity = null; if (token != null) &#123; activity = ActivityRecord.isInStackLocked(token); &#125; ... // 获取 ServiceLookupResult，其中 res.record 就是我们要启动的 service ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg); ServiceRecord s = res.record; mAm.startAssociationLocked(callerApp.uid, callerApp.processName, s.appInfo.uid, s.name, s.processName); AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp); // 封装客户端传入的 IServiceConnection，用于绑定后回调 ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent); // 保存 connection 记录到列表中 IBinder binder = connection.asBinder(); ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); s.connections.put(binder, clist); &#125; clist.add(c); b.connections.add(c); if (activity != null) &#123; if (activity.connections == null) &#123; activity.connections = new HashSet&lt;ConnectionRecord&gt;(); &#125; activity.connections.add(c); &#125; b.client.connections.add(c); if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123; b.client.hasAboveClient = true; &#125; if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c, true); &#125; clist = mServiceConnections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); mServiceConnections.put(binder, clist); &#125; clist.add(c); // 继续进入 bringUpServiceLocked() 处理 if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; s.lastActivity = SystemClock.uptimeMillis(); if (bringUpServiceLocked(s, service.getFlags(), callerFg, false) != null) &#123; return 0; &#125; &#125; ...&#125; 7. ActiveServices.bringUpServiceLocked() 继续查看 bringUpServiceLocked() 方法 1234567891011121314151617181920212223private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) throws TransactionTooLargeException &#123; ... final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0; final String procName = r.processName; ProcessRecord app; // 获取进程记录 app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); // 启动服务 realStartServiceLocked(r, app, execInFg); return null; &#125; catch (TransactionTooLargeException e) &#123; ... &#125; &#125; ...&#125; 8. ActiveServices.realStartServiceLocked() 继续追踪 ActiveServices.realStartServiceLocked() 123456789101112131415161718private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; ... try &#123; ... // 创建服务，服务端最终会响应 onCreate() 方法。 app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); ... &#125; catch (DeadObjectException e) &#123; ... &#125; // 绑定服务， 服务最终端会响应 onBind() 方法 requestServiceBindingsLocked(r, execInFg); ...&#125; 参考Android应用程序绑定服务（bindService）的过程源代码分析 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Binder源码分析","date":"2017-07-26T11:44:18.000Z","path":"2017/07/26/Binder源码分析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 本文是基于 Android 6.0.0 和 kernel 3.4 源码 及 Android SDK 23 展开的 1. 简介Binder 是一种 Android 进程间通信机制，提供远程过程调用(Remote Procedure Call)功能。我们最直接的使用是调用 Context.getSystemService() 来获取系统服务，或直接使用 AIDL 来实现多个程序(APP)间数据交互。 Binder 是非常重要的 Android 基础组件，几乎所有的进程间通信都是使用 Binder 机制实现的。本文将结合源码展开讲述 Binder ，同时对一些重要知识点提供扩展阅读的参考。 不管是 Android 系统服务(System services)还是用户的应用进程(User apps)，最终都会通过 binder 来实现进程间通信。上层应用首先通过 IBinder 的 transcate 方法发送命令给 libbinder， libbinder 再通过系统调用(ioctl) 发送命令到内核中的 binder 驱动，之后再由驱动完成进程间数据的交互。 我们经常使用的 Intent，Messager 数据传递也是对 Binder 更高层次的抽象和封装，最终还是会由内核中的 binder 驱动完成数据的传递。 2. Binder 与 AIDLAIDL (Android Interface definition language) 是接口描述语言，用于生成在两个进程间进行通信的代码。先看 AIDL 概念图 Stub.Proxy 和 Stub 代码由 Android Sdk 自动生成，客户端通过 Stub.Proxy 与远程服务交互。 Stub 包含对 IBinder 对象操作的封装，需要远程服务实现具体功能。 接下来再看具体实现， 完整源代码见 AidlExample。在这个工程中，我们新建了两个应用， app 是客户端代码， remoteservice 则是服务端代码。 2.1 AIDL 客户端在 Android Studio 项目上右键， New -&gt; AIDL -&gt; AIDL File 输入文件名后可以快速创建一个 AIDL 的代码结构。例如我们新建一个 IRemoteService.aidl 文件 12345678// IRemoteService.aidlpackage com.android.aidltest;interface IRemoteService &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 从生成的示例代码可以看出，AIDL 的语法类似 Java， basicTypes() 方法传递的参数只是基本类型。 如果要传递自定义类型如 User，则需要实现 Parcelable 接口。Parcelable 是一个与 Java Serializable 类似的序列化接口。 这样类 User 的实例就可以储存到 Parcel 中，而 Parcel 则是一个可以通过 IBinder 发送数据或对象引用的容器。 1234567891011121314151617181920212223242526272829303132// User.javapublic class User implements Parcelable &#123; private int uid; private String name; // 从 Parcel 中读取数据，顺序需要和写入保持一致 protected User(Parcel in) &#123; uid = in.readInt(); name = in.readString(); &#125; // 必须实现，用于从 Parcel 对象中生成类实例 public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; // 将数据写入到 Parcel 中， 顺序需要与读取保持一致 @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(uid); dest.writeString(name); &#125;&#125; 再向 IRemoteService.aidl 中添加一个 addUser() 方法，同时新建一个 User.aidl 文件。 1234567891011121314151617// IRemoteService.aidlpackage com.android.aidltest;import com.android.aidltest.User;interface IRemoteService &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); // in 表示传入数据， out 表示传出数据， inout 表示双向传递。注意含有 out 时 User 类需要实现 readFromParcel() 方法 void addUser(in User user);&#125;// User.aidlpackage com.android.aidltest;parcelable User; 运行编译后，会在 generated 文件夹中生成一个 IRemoteService.java 接口文件。这个接口中有两个内部类 Stub 和 Stub.Proxy。注意客户端生成的IRemoteService.java 文件和在后文服务端生成的文件内容是相同的。 客户端会从 Stub.asInterface() 得到 IRemoteService (Stub.Proxy) 的实例，这个实例就是一个通过 Binder 传递回来的 远程对象 的包装。而服务端则需要实现 IRemoteService.addUser() 方法。 1234567891011// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof org.xdty.remoteservice.IRemoteService))) &#123; return ((org.xdty.remoteservice.IRemoteService) iin); &#125; return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);&#125; 2.2 AIDL 服务端为了演示进程间通信，我们新建一个模块（应用） RemoteService 来实现功能，并在客户端绑定服务。 按客户端的结构新建 IRemoteService.aidl User.aidl User.java 文件，并拷贝内容，注意如果需要请修改包名。 新建服务 RemoteService ，覆盖(Override) onBind() 方法并返回 IRemoteService.Stub 实例 mBinder： 123456789101112131415161718192021// RemoteService.javapublic class RemoteService extends Service &#123; private static final String TAG = RemoteService.class.getSimpleName(); private IBinder mBinder = new IRemoteService.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; Log.d(TAG, \"basicTypes: \"); &#125; @Override public void addUser(User user) throws RemoteException &#123; Log.d(TAG, \"addUser: \" + user.name); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 这样服务端就实现了 addUser() 方法，当客户端通过远程对象调用 IRemoteService.Stub.Proxy.addUser() 时，远程对象 mRemote 就会通过 transact() 发送命令给服务端，服务端收到命令后在 Stub.onTransact() 中读取数据并执行 addUser() 方法。更多细节我们将在 3. Binder 框架及 Native 层 小节讲述。 123456789101112131415161718192021// IRemoteService.java@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; ... case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 2.3 远程服务的获取与使用客户端要使用远程服务，需要绑定服务 (bindService) 并建立服务连接 (ServiceConnection)。 123456789101112131415161718192021222324// MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; IRemoteService remoteService = IRemoteService.Stub.asInterface(service); try &#123; remoteService.addUser(new User(1, \"neo\")); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; ... &#125;; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; ... Intent intent = new Intent().setComponent(new ComponentName( \"org.xdty.remoteservice\", \"org.xdty.remoteservice.RemoteService\")); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125;&#125; 我们可以看出，客户端通过 binderService() 方法，获取远程服务并在服务连接 ServiceConnection 中 onServiceConnected() 回调中得到了 IBinder service 实例， 最后通过上文提到的 IRemoteService.Stub.asInterface(service) 方法得到远程服务 IRemoteService 的实例。通过 IRemoteService.addUser() 方法我们可以像调用本地方法一样调用远程方法。在来看 IRemoteService.addUser() 的实现： 123456789101112131415161718192021222324252627282930313233343536373839// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) &#123; ... return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);&#125;private static class Proxy implements org.xdty.remoteservice.IRemoteService &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; ... @Override public void addUser(org.xdty.remoteservice.User user) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((user != null)) &#123; _data.writeInt(1); user.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125;&#125; 可以看到客户端调用 remoteService.addUser(new User(1, “neo”)) 方法实际上是通过 IBinder service 实例的 transact() 方法，发送了与服务端约定好的命令 Stub.TRANSACTION_addUser，并将参数按格式打包进 Parcel 对象。 服务端则在 onTransact() 方法中收到命令后会对命令和参数重新解析： 1234567891011121314151617181920// IRemoteService.javapublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; ... case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 可以看到在 onTransact() 中，最终 this.addUser(_arg0) 调用了上文提到的服务端的实现 IRemoteService.Stub.addUser() 。 远程 Binder 对象 mRemote 是由客户端绑定服务时 onServiceConnected() 返回的。继续追踪 bindService() 1234567// ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, Process.myUserHandle());&#125; 可以看到最后是通过 ActivityManagerNative.getDefault().bindService() 来绑定服务 12345678910111213141516// bindServiceCommon()int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier());// ActivityManagerNative.getDefault().bindService()public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws RemoteException &#123; ... data.writeStrongBinder(connection.asBinder()); ... mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0); ...&#125; 追踪到 ActivityManagerNative.getDefault().bindService() ，可以发现 ActivityManager 和 IServiceConnection也是一个 AIDL 实现。通过它的 ActivityManagerProxy.bindService() 将绑定请求发送给本地层。 再从 onServiceConnected() 回调追踪， onServiceConnected() 是由 LoadedApk.ServiceDispatcher.doConnected() 回调的。 关于更多的 bindService() 远程服务创建及 ServiceConnection 回调， 请参考 Android应用程序绑定服务（bindService）的过程源代码分析 利用进程间通信，我们可以实现简单的应用插件功能。关于 AIDL 在实际项目中的应用，可以参考 CallerInfo Plugin 的实现 从上面分析可以看出， AIDL 的本质是对 Binder 的又一次抽象和封装，实际的进程间通信仍是由 Binder 完成的。 3. Binder 框架及 Native 层Binder机制使本地对象可以像操作当前对象一样调用远程对象，可以使不同的进程间互相通信。Binder 使用 Client/Server 架构，客户端通过服务端代理，经过 Binder 驱动与服务端交互。 Binder 机制实现进程间通信的奥秘在于 kernel 中的 Binder 驱动，将在 4. Binder 驱动 小节详细讲述。 JNI 的代码位于 frameworks/base/core/jni 目录下，主要是 android_util_Binder.cpp 文件和头文件 android_util_Binder.h Binder JNI 代码是 Binder Java 层操作到 Binder Native 层的接口封装，最后会被编译进 libandroid_runtime.so 系统库。 Binder 本地层的代码在 frameworks/native/libs/binder 目录下， 此目录在 Android 系统编译后会生成 libbinder.so 文件，供 JNI 调用。libbinder 封装了所有对 binder 驱动的操作，是上层应用与驱动交互的桥梁。头文件则在 frameworks/native/include/binder 目录下。 3.1 Binder Native 的入口IInterface.cpp 是 Binder 本地层入口，与 java 层的 android.os.IInterface 对应，提供 asBinder() 的实现，返回 IBinder 对象。 在头文件中有两个类 BnInterface (Binder Native Interface) 和 BpInterface (Binder Proxy Interface), 对应于 java 层的 Stub 和 Proxy 12345sp&lt;IBinder&gt; IInterface::asBinder(const IInterface* iface)&#123; if (iface == NULL) return NULL; return const_cast&lt;IInterface*&gt;(iface)-&gt;onAsBinder();&#125; 12345678910111213141516171819202122template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const;protected: virtual IBinder* onAsBinder();&#125;;// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; 其中 BnInterface 是实现Stub功能的模板，扩展BBinder的onTransact()方法实现Binder命令的解析和执行。BpInterface 是实现Proxy功能的模板，BpRefBase里有个mRemote对象指向一个BpBinder对象。 3.2 Binder 本地层的整个函数/方法调用过程 1. Java 层 IRemoteService.Stub.Proxy 调用 android.os.IBinder (实现在 android.os.Binder.BinderProxy) 的 transact() 发送 Stub.TRANSACTION_addUser 命令。 2. 由 BinderProxy.transact() 进入 native 层。 3. 由 jni 转到 android_os_BinderProxy_transact() 函数。 4. 调用 IBinder-&gt;transact 函数。 1234567static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject); status_t err = target-&gt;transact(code, *data, reply, flags);&#125; 而 gBinderProxyOffsets.mObject 则是在 java 层调用 IBinder.getContextObject() 时在 javaObjectForIBinder 函数中设置的 123456789101112131415static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125;jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... LOGDEATH(\"objectForBinder %p: created new proxy %p !\\n\", val.get(), object); // The proxy holds a reference to the native object. env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get()); val-&gt;incStrong((void*)javaObjectForIBinder); ...&#125; 经过 ProcessState::getContextObject() 和 ProcessState::getStrongProxyForHandle() 1234567891011121314sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0);&#125;sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; ... b = new BpBinder(handle); result = b; ... return result;&#125; 可见 android_os_BinderProxy_transact() 函数实际上调用的是 BpBinder::transact() 函数。 5. BpBinder::transact() 则又调用了 IPCThreadState::self()-&gt;transact() 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; if (err == NO_ERROR) &#123; LOG_ONEWAY(\"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s\", getpid(), getuid(), (flags &amp; TF_ONE_WAY) == 0 ? \"READ REPLY\" : \"ONE WAY\"); err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125;status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; ... mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 由函数内容可以看出， 数据再一次通过 writeTransactionData() 传递给 mOut 进行写入操作。 mOut 是一个 Parcel 对象， 声明在 IPCThreadState.h 文件中。之后则调用 waitForResponse() 函数。 6. IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... cmd = (uint32_t)mIn.readInt32(); switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: ... case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, \"Not enough command data for brREPLY\"); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); &#125; &#125; else &#123; freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); continue; &#125; &#125; goto finish; &#125; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125; ...&#125; 7. IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现。ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) 就是使用系统调用函数 ioctl 向 binder 设备文件 /dev/binder 发送 BINDER_WRITE_READ 命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; return -EBADF; &#125; binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // We don't want to write anything if we are still reading // from data left in the input buffer and the caller // has requested to read the next data. const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we'll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; // Return immediately if there is nothing to do. if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err;#if defined(HAVE_ANDROID_OS) // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno;#else err = INVALID_OPERATION;#endif do &#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; err = -EBADF; &#125; &#125; while (err == -EINTR); if (err &gt;= NO_ERROR) &#123; if (bwr.write_consumed &gt; 0) &#123; if (bwr.write_consumed &lt; mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); &#125; if (bwr.read_consumed &gt; 0) &#123; mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; return NO_ERROR; &#125; return err;&#125; 经过 IPCThreadState::talkWithDriver() ,就将数据发送给了 Binder 驱动。 继续追踪 IPCThreadState::waitForResponse() ，可以从 第6步 发现 IPCThreadState 不断的循环读取 Binder 驱动返回，获取到返回命令后执行了 executeCommand(cmd) 函数。 8. IPCThreadState::executeCommand() 处理 Binder 驱动返回命令 123456789101112131415161718192021222324252627282930313233343536status_t IPCThreadState::executeCommand(int32_t cmd)&#123; BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch ((uint32_t)cmd) &#123; ... case BR_TRANSACTION: &#123; binder_transaction_data tr; result = mIn.read(&amp;tr, sizeof(tr)); ... Parcel buffer; buffer.ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); ... Parcel reply; status_t error; if (tr.target.ptr) &#123; sp&lt;BBinder&gt; b((BBinder*)tr.cookie); error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; else &#123; error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; ... &#125; break; ...&#125; 9. 可以看出其调用了 BBinder::transact() 函数，将数据返回给上层。 123456789101112131415161718192021status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; data.setDataPosition(0); status_t err = NO_ERROR; switch (code) &#123; case PING_TRANSACTION: reply-&gt;writeInt32(pingBinder()); break; default: err = onTransact(code, data, reply, flags); break; &#125; if (reply != NULL) &#123; reply-&gt;setDataPosition(0); &#125; return err;&#125; 10. 而这里的 b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags) 中的 b (BBinder) 是 JavaBBinder 的实例，所以会调用 JavaBBinder::onTransact() 函数 12345678910111213141516// frameworks/base/core/jni/android_util_Binder.cppvirtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) &#123; JNIEnv* env = javavm_to_jnienv(mVM); ... jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); &#125;static int int_register_android_os_Binder(JNIEnv* env)&#123; ... gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, \"execTransact\", \"(IJJI)Z\"); ...&#125; 11. 可见 JNI 通过 gBinderOffsets.mExecTransact 最后执行了 android.os.Binder 的 execTransact() 方法。 execTransact() 方法是 jni 回调的入口。 1234567891011// Entry point from android_util_Binder.cpp's onTransact private boolean execTransact(int code, long dataObj, long replyObj, int flags) &#123; Parcel data = Parcel.obtain(dataObj); Parcel reply = Parcel.obtain(replyObj); ... try &#123; res = onTransact(code, data, reply, flags); &#125; ... &#125; 12. 而我们则在服务端 IRemoteService.Stub 重载了 onTransact() 方法，所以数据最后会回到我们的服务端并执行服务端实现的 addUser() 方法。 12345678910111213141516171819202122232425262728293031public static abstract class Stub extends android.os.Binder implements org.xdty.remoteservice.IRemoteService &#123; ... @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_basicTypes: &#123; ... return true; &#125; case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125;&#125; 上述过程就是所有的 Native 层客户端到服务端的调用过程，总结下来就是 客户端进程发送 BC_TRANSACTION 到 Binder 驱动，服务端进程监听返回的 BR_TRANSACTION 命令并处理。如果是服务端向客户端返回数据，类似的是服务端发送 BC_REPLY 命令， 客户端监听 BR_REPLY 命令。 3.3 Binder 设备文件的打开和读写1. 设备的打开 在上一小节中我们看到 JNI 过程中调用了 ProcessState::getContextObject() 函数， 在 ProcessState 初始化时会打开 binder 设备 1234567// ProcessState.cppProcessState::ProcessState() : mDriverFD(open_driver()) ...&#123; ...&#125; open_driver() 函数内容如下 1234567891011121314151617181920212223242526272829303132// ProcessState.cppstatic int open_driver()&#123; // 打开设备文件 int fd = open(\"/dev/binder\", O_RDWR); if (fd &gt;= 0) &#123; fcntl(fd, F_SETFD, FD_CLOEXEC); int vers = 0; // 获取驱动版本 status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result == -1) &#123; ALOGE(\"Binder ioctl to obtain version failed: %s\", strerror(errno)); close(fd); fd = -1; &#125; // 检查驱动版本是否一致 if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123; ALOGE(\"Binder driver protocol does not match user space protocol!\"); close(fd); fd = -1; &#125; // 设置最多 15 个 binder 线程 size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); if (result == -1) &#123; ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(errno)); &#125; &#125; else &#123; ALOGW(\"Opening '/dev/binder' failed: %s\\n\", strerror(errno)); &#125; return fd;&#125; 2. 设备的读写 打开设备文件后，文件描述符被保存在 mDriverFD， 通过系统调用 ioctl 函数操作 mDriverFD 就可以实现和 binder 驱动的交互。 对 Binder 设备文件的所有读写及关闭操作则都在 IPCThreadState 中，如上一小节提及到的 IPCThreadState::talkWithDriver 函数 talkWithDriver() 函数封装了 BINDER_WRITE_READ 命令，会从 binder 驱动读取或写入封装在 binder_write_read 结构体中的本地或远程对象。 12345678910111213141516171819202122232425// IPCThreadState.cppstatus_t IPCThreadState::talkWithDriver(bool doReceive)&#123; binder_write_read bwr; const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; // 写入数据 bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // 读取数据 if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; ... // 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; ...&#125; 可以看出，本地层是对应用与 binder 驱动交互的直接封装与实现，最终的数据传输仍是由驱动来完成的。本地层对底层驱动进行了完整的封装，上层应用只关心 transact() 和 onTransact() 回调，察觉不到 binder 驱动的存在，减轻了上层应用进程间通信开发的复杂度。 4. Binder 驱动关于 binder 驱动建议参考另一篇文章 深入分析Android Binder 驱动 原文，本小节仍需要完善。 Binder 驱动是 Binder 的最终实现， ServiceManager 和 Client/Service 进程间通信最终都是由 Binder 驱动投递的。 Binder 驱动的代码位于 kernel 代码的 drivers/staging/android 目录下。主文件是 binder.h 和 binder.c 进程间传输的数据被称为 Binder 对象，它是一个 flat_binder_object，结构如下 1234567891011121314struct flat_binder_object &#123; /* 8 bytes for large_flat_header. */ unsigned long type; unsigned long flags; /* 8 bytes of data. */ union &#123; void *binder; /* local object */ signed long handle; /* remote object */ &#125;; /* extra data associated with local object */ void *cookie;&#125;; 其中 类型 type 描述了 Binder 对象的类型，包含 BINDER(本地对象)、HANDLE(远程对象)、 FD 三大类(五种) 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; flags 则表述了传输方式，如异步、无返回等 123456enum transaction_flags &#123; TF_ONE_WAY = 0x01, /* this is a one-way call: async, no return */ TF_ROOT_OBJECT = 0x04, /* contents are the component's root object */ TF_STATUS_CODE = 0x08, /* contents are a 32-bit status code */ TF_ACCEPT_FDS = 0x10, /* allow replies with file descriptors */&#125;; 而 flat_binder_object 中的 union 联合体 就是要传输的数据，当类型为 BINDER 时， 数据就是一个本地对象 *binder，而类型为 HANDLE 时，数据则是一个远程对象 handle。 当 flat_binder_object 在进程间传递时， Binder 驱动会修改它的类型和数据，交换的代码参考 binder_transaction 的实现。 该如何理解本地 BINDER 对象和远程 HANDLE 对象呢？其实它们都代表同一个对象，不过是从不同的角度来看。举例来说，假如进程 RemoteService 有个对象 mBinder，对于 RemoteService 来说，mBinder 就是一个本地的 BINDER 对象；如果进程 app 通过 Binder 驱动访问 RemoteService 的 mBinder 对象，对于 app 来说， mBinder 就是一个 HANDLE。因此，从根本上来说 handle 和 binder 都指向 RemoteService 的 mBinder。本地对象还可以带有额外的数据，保存在 cookie 中。 Binder 驱动直接操作的最外层数据结构是 binder_transaction_data， Binder 对象 flat_binder_object 被封装在 binder_transaction_data 结构体中。 binder_transaction_data 数据结构才是真正传输的数据，其定义如下 1234567891011121314151617181920212223242526272829303132struct binder_transaction_data &#123; /* The first two are only used for bcTRANSACTION and brTRANSACTION, * identifying the target and contents of the transaction. */ union &#123; size_t handle; /* target descriptor of command transaction */ void *ptr; /* target descriptor of return transaction */ &#125; target; void *cookie; /* target object cookie */ unsigned int code; /* transaction command */ /* General information about the transaction. */ unsigned int flags; pid_t sender_pid; uid_t sender_euid; size_t data_size; /* number of bytes of data */ size_t offsets_size; /* number of bytes of offsets */ /* If this transaction is inline, the data immediately * follows here; otherwise, it ends with a pointer to * the data buffer. */ union &#123; struct &#123; /* transaction data */ const void *buffer; /* offsets from buffer to flat_binder_object structs */ const void *offsets; &#125; ptr; uint8_t buf[8]; &#125; data;&#125;; flat_binder_object 就被封装在 *buffer中，其中的 unsigned int code; 则是传输命令，描述了 Binder 对象执行的操作。 4.1 binder 设备的创建device_initcall() 函数是内核加载驱动的入口函数，我们先来看这个函数的调用过程。 12345678910111213141516171819202122232425262728static struct miscdevice binder_miscdev = &#123; .minor = MISC_DYNAMIC_MINOR, // 设备文件 /dev/binder .name = \"binder\", // 设备文件操作 .fops = &amp;binder_fops&#125;;static int __init binder_init(void)&#123; int ret; ... // 注册字符设备 ret = misc_register(&amp;binder_miscdev); ... // 调试文件， 在 /sys/kernel/debug/binder 目录下 if (binder_debugfs_dir_entry_root) &#123; debugfs_create_file(\"state\", S_IRUGO, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); ... &#125; return ret;&#125;device_initcall(binder_init); 可以看出 binder_init() 使用 misc_register() 函数创建了 binder 设备。从 misc_register(&amp;binder_miscdev); 及 .name = “binder” 可以看出， binder 向 kernel 注册了一个 /dev/binder 的字符设备，而文件操作都在 binder_fops 结构体中定义。 123456789static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 从上面 binder_fops 结构体可以看出，主要的操作是 binder_ioctl() binder_mmap() binder_open() 等函数实现的。 4.2 binder 协议和数据结构binder.h 文件中定义了 binder 协议和重要的数据结构。 首先在 enum 中定义了 binder 处理的类型，引用或是句柄 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; 下面这段宏定义则是在 ioctl 函数调用时可用的具体命令。 1234567#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)#define BINDER_SET_IDLE_TIMEOUT _IOW('b', 3, int64_t)#define BINDER_SET_MAX_THREADS _IOW('b', 5, size_t)#define BINDER_SET_IDLE_PRIORITY _IOW('b', 6, int)#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, int)#define BINDER_THREAD_EXIT _IOW('b', 8, int)#define BINDER_VERSION _IOWR('b', 9, struct binder_version) 在 BinderDriverReturnProtocol 和 BinderDriverCommandProtocol 中 则分别定义了 客户端调用 和 服务端 返回的命令。 4.3 binder 驱动文件操作上文已经提到，所有的操作定义在 binder_fops 结构体中，下面讲述这些操作。 设备的打开 - binder_open() 函数 用户空间在打开 /dev/binder 设备时，驱动会出发 binder_open() 函数的响应。 123456789101112131415161718192021222324252627282930313233static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; // 分配 binder_proc 数据结构内存 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; // 增加当前线程/进程的引用计数并赋值给tsk get_task_struct(current); proc-&gt;tsk = current; // 初始化队列 INIT_LIST_HEAD(&amp;proc-&gt;todo); init_waitqueue_head(&amp;proc-&gt;wait); proc-&gt;default_priority = task_nice(current); binder_lock(__func__); // 增加BINDER_STAT_PROC的对象计数 binder_stats_created(BINDER_STAT_PROC); // 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); // 保存进程 id proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); // 驱动文件 private_data 指向 proc filp-&gt;private_data = proc; binder_unlock(__func__); return 0;&#125; 驱动文件释放 - binder_release() 函数 在用户空间关闭驱动设备文件时，会调用 binder_release() 函数，清理 binder_proc 对象，释放占用的内存。 123456789101112131415161718192021static int binder_release(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc = filp-&gt;private_data; binder_defer_work(proc, BINDER_DEFERRED_RELEASE); return 0;&#125;static voidbinder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer)&#123; mutex_lock(&amp;binder_deferred_lock); proc-&gt;deferred_work |= defer; if (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) &#123; // 添加到释放队列中 hlist_add_head(&amp;proc-&gt;deferred_work_node, &amp;binder_deferred_list); queue_work(binder_deferred_workqueue, &amp;binder_deferred_work); &#125; mutex_unlock(&amp;binder_deferred_lock);&#125; 内存映射 - binder_mmap() 函数 binder_mmap() 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct vm_struct *area; // 获得 binder_proc 对象 struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; struct binder_buffer *buffer; // 最多只分配 4M 的内存 if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; // 检查 flags if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123; ret = -EPERM; failure_string = \"bad vm_flags\"; goto err_bad_arg; &#125; vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE; mutex_lock(&amp;binder_mmap_lock); // 检查是否已经映射 if (proc-&gt;buffer) &#123; ret = -EBUSY; failure_string = \"already mapped\"; goto err_already_mapped; &#125; // 申请内核虚拟内存空间 area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); if (area == NULL) &#123; ret = -ENOMEM; failure_string = \"get_vm_area\"; goto err_get_vm_area_failed; &#125; // 将申请到的内存地址保存到 binder_proc 对象中 proc-&gt;buffer = area-&gt;addr; proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer; mutex_unlock(&amp;binder_mmap_lock); // 根据请求到的内存空间大小，分配给 binder_proc 对象的 pages， 用于保存指向物理页的指针 proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); if (proc-&gt;pages == NULL) &#123; ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; &#125; proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; vma-&gt;vm_ops = &amp;binder_vm_ops; vma-&gt;vm_private_data = proc; // 分配一个页的物理内存 if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123; ret = -ENOMEM; failure_string = \"alloc small buf\"; goto err_alloc_small_buf_failed; &#125; // 内存提供给 binder_buffer buffer = proc-&gt;buffer; // 初始化 proc-&gt;buffers 链表 INIT_LIST_HEAD(&amp;proc-&gt;buffers); // 将 binder_buffer 对象放入到 proc-&gt;buffers 链表中 list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); buffer-&gt;free = 1; binder_insert_free_buffer(proc, buffer); proc-&gt;free_async_space = proc-&gt;buffer_size / 2; barrier(); proc-&gt;files = get_files_struct(proc-&gt;tsk); proc-&gt;vma = vma; proc-&gt;vma_vm_mm = vma-&gt;vm_mm; return 0;&#125; 驱动命令接口 - binder_ioctl() 函数 用户态程序调用 ioctl 系统函数向 /dev/binder 设备发送数据时，会触发 binder_ioctl() 函数响应。 上文数据结构中已经提到了 binder_ioctl 可以处理的 命令 12345678910// 核心命令，数据的读写#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)// 设置最大线程数#define BINDER_SET_MAX_THREADS _IOW('b', 5, size_t)// 设置 context manager#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, int)// 线程退出命令#define BINDER_THREAD_EXIT _IOW('b', 8, int)// binder 驱动的版本#define BINDER_VERSION _IOWR('b', 9, struct binder_version) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 检查是否有错误 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret) goto err_unlocked; binder_lock(__func__); // 获取 binder_thread 对象 thread = binder_get_thread(proc); if (thread == NULL) &#123; ret = -ENOMEM; goto err; &#125; switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; if (size != sizeof(struct binder_write_read)) &#123; ret = -EINVAL; goto err; &#125; // 从用户空间拷贝 binder_write_read 到 binder 驱动，储存在 bwr if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; if (bwr.write_size &gt; 0) &#123; // 执行写入操作 ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); if (ret &lt; 0) &#123; bwr.read_consumed = 0; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto err; &#125; &#125; if (bwr.read_size &gt; 0) &#123; // 执行读取操作 ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); if (!list_empty(&amp;proc-&gt;todo)) wake_up_interruptible(&amp;proc-&gt;wait); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto err; &#125; &#125; // 操作完成后将数据返回给用户空间 if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; break; &#125; case BINDER_SET_MAX_THREADS: // 设置最大线程，从用户空间拷贝数据到 proc-&gt;max_threads if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) &#123; ret = -EINVAL; goto err; &#125; break; case BINDER_SET_CONTEXT_MGR: // 检查是否已经设置 if (binder_context_mgr_node != NULL) &#123; ret = -EBUSY; goto err; &#125; // 设置 context manager ret = security_binder_set_context_mgr(proc-&gt;tsk); if (ret &lt; 0) goto err; if (binder_context_mgr_uid != -1) &#123; if (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123; ret = -EPERM; goto err; &#125; &#125; else binder_context_mgr_uid = current-&gt;cred-&gt;euid; // 创建 binder_context_mgr_node 节点 binder_context_mgr_node = binder_new_node(proc, NULL, NULL); if (binder_context_mgr_node == NULL) &#123; ret = -ENOMEM; goto err; &#125; // 初始化节点数据 binder_context_mgr_node-&gt;local_weak_refs++; binder_context_mgr_node-&gt;local_strong_refs++; binder_context_mgr_node-&gt;has_strong_ref = 1; binder_context_mgr_node-&gt;has_weak_ref = 1; break; case BINDER_THREAD_EXIT: // 线程退出，释放资源 binder_free_thread(proc, thread); thread = NULL; break; case BINDER_VERSION: // 将 binder 驱动版本号写入到用户空间 ubuf-&gt;protocol_version 中 if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) &#123; ret = -EINVAL; goto err; &#125; break; default: ret = -EINVAL; goto err; &#125; ret = 0;...&#125; 123456789101112131415161718192021222324252627282930313233343536373839static struct binder_node *binder_new_node(struct binder_proc *proc, void __user *ptr, void __user *cookie)&#123; struct rb_node **p = &amp;proc-&gt;nodes.rb_node; struct rb_node *parent = NULL; struct binder_node *node; // 查找要插入节点的父节点 while (*p) &#123; parent = *p; node = rb_entry(parent, struct binder_node, rb_node); if (ptr &lt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_left; else if (ptr &gt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_right; else return NULL; &#125; // 为要插入节点分配内存空间 node = kzalloc(sizeof(*node), GFP_KERNEL); if (node == NULL) return NULL; binder_stats_created(BINDER_STAT_NODE); // 插入节点 rb_link_node(&amp;node-&gt;rb_node, parent, p); rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes); // 初始化 node-&gt;debug_id = ++binder_last_id; node-&gt;proc = proc; node-&gt;ptr = ptr; node-&gt;cookie = cookie; node-&gt;work.type = BINDER_WORK_NODE; INIT_LIST_HEAD(&amp;node-&gt;work.entry); INIT_LIST_HEAD(&amp;node-&gt;async_todo); return node;&#125; BINDER_WRITE_READ 处理过程 在 binder 本地层中，我们看到在 IPCThreadState::talkWithDriver() 函数中， binder 本地层通过 ioctl()(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) 命令的形式，与 binder 驱动交互。 可以看出 ioctl() 的第三个参数是一个 binder_write_read 结构体 binder.h 头文件中定义了两个数据类型, 一个是 binder_write_read 12345678struct binder_write_read &#123; signed long write_size; /* bytes to write */ signed long write_consumed; /* bytes consumed by driver */ unsigned long write_buffer; signed long read_size; /* bytes to read */ signed long read_consumed; /* bytes consumed by driver */ unsigned long read_buffer;&#125;; 其中 write_size 和 read_size 表示需要被读写的字节数， write_consumed 和 read_consumed 表示已经被 binder 驱动读写的字节数， write_buffer 和 read_buffer 则是指向被读写数据的指针。 具体的读写操作被 binder_thread_write 和 binder_thread_read 实现。 数据写入 - binder_thread_write() 函数 将用户空间数据写入到 binder 驱动，从驱动角度来看是读取的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; // 用户空间数据，起始地址和结束地址 void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 循环读取 while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // 从用户空间获取操作命令 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123; // 增加命令计数器 binder_stats.bc[_IOC_NR(cmd)]++; proc-&gt;stats.bc[_IOC_NR(cmd)]++; thread-&gt;stats.bc[_IOC_NR(cmd)]++; &#125; switch (cmd) &#123; // 这四个命令用来增加或减少对象的引用计数， 操作目标 binder_ref case BC_INCREFS: case BC_ACQUIRE: case BC_RELEASE: case BC_DECREFS: &#123; uint32_t target; struct binder_ref *ref; const char *debug_string; // 获取目标进程节点描述 desc if (get_user(target, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 索描述为 0 表示 context manager 进程 if (target == 0 &amp;&amp; binder_context_mgr_node &amp;&amp; (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) &#123; // 在 proc-&gt;refs_by_node.rb_node 红黑树中查找引用 ref = binder_get_ref_for_node(proc, binder_context_mgr_node); &#125; else // 在 proc-&gt;refs_by_desc.rb_node 红黑树中查找引用 ref = binder_get_ref(proc, target); switch (cmd) &#123; case BC_INCREFS: debug_string = \"IncRefs\"; // 增加弱引用计数 binder_inc_ref(ref, 0, NULL); break; case BC_ACQUIRE: debug_string = \"Acquire\"; // 增加强引用计数 binder_inc_ref(ref, 1, NULL); break; case BC_RELEASE: debug_string = \"Release\"; // 减少强引用计数 binder_dec_ref(ref, 1); break; case BC_DECREFS: default: debug_string = \"DecRefs\"; // 减少弱引用计数 binder_dec_ref(ref, 0); break; &#125; break; &#125; case BC_INCREFS_DONE: case BC_ACQUIRE_DONE: &#123; void __user *node_ptr; void *cookie; struct binder_node *node; // 从用户空间读取 node_ptr if (get_user(node_ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 从用户空间读取 cookie if (get_user(cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 获得节点 node = binder_get_node(proc, node_ptr); // 没有找到则返回 if (node == NULL) &#123; binder_user_error(\"binder: %d:%d \" \"%s u%p no match\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_INCREFS_DONE ? \"BC_INCREFS_DONE\" : \"BC_ACQUIRE_DONE\", node_ptr); break; &#125; // cookie 不匹配则返回 if (cookie != node-&gt;cookie) &#123; binder_user_error(\"binder: %d:%d %s u%p node %d\" \" cookie mismatch %p != %p\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_INCREFS_DONE ? \"BC_INCREFS_DONE\" : \"BC_ACQUIRE_DONE\", node_ptr, node-&gt;debug_id, cookie, node-&gt;cookie); break; &#125; if (cmd == BC_ACQUIRE_DONE) &#123; node-&gt;pending_strong_ref = 0; &#125; else &#123; node-&gt;pending_weak_ref = 0; &#125; // 减少节点使用计数 binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0); break; &#125; // 释放 binder_bffer case BC_FREE_BUFFER: &#123; void __user *data_ptr; struct binder_buffer *buffer; // 从用户空间获取 data_ptr if (get_user(data_ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 查找 binder_buffer buffer = binder_buffer_lookup(proc, data_ptr); // 没有找到则返回 if (buffer == NULL) &#123; binder_user_error(\"binder: %d:%d \" \"BC_FREE_BUFFER u%p no match\\n\", proc-&gt;pid, thread-&gt;pid, data_ptr); break; &#125; // 不允许用户释放则返回 if (!buffer-&gt;allow_user_free) &#123; binder_user_error(\"binder: %d:%d \" \"BC_FREE_BUFFER u%p matched \" \"unreturned buffer\\n\", proc-&gt;pid, thread-&gt;pid, data_ptr); break; &#125; // 将 buffer-&gt;transaction 置空 if (buffer-&gt;transaction) &#123; buffer-&gt;transaction-&gt;buffer = NULL; buffer-&gt;transaction = NULL; &#125; if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123; if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo)) buffer-&gt;target_node-&gt;has_async_transaction = 0; else list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo); &#125; // 释放 binder_buffer 对象 trace_binder_transaction_buffer_release(buffer); binder_transaction_buffer_release(proc, buffer, NULL); binder_free_buf(proc, buffer); break; &#125; // binder 数据传递处理 case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; // 从用户空间拷贝 binder_transaction_data 对象 if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); // 实际的传输函数，在下文讲解 binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; // 设置 looper 为 BINDER_LOOPER_STATE_REGISTERED 状态 case BC_REGISTER_LOOPER: if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_REGISTER_LOOPER called \" \"after BC_ENTER_LOOPER\\n\", proc-&gt;pid, thread-&gt;pid); &#125; else if (proc-&gt;requested_threads == 0) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_REGISTER_LOOPER called \" \"without request\\n\", proc-&gt;pid, thread-&gt;pid); &#125; else &#123; proc-&gt;requested_threads--; proc-&gt;requested_threads_started++; &#125; thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED; break; // 设置 looper 为 BINDER_LOOPER_STATE_ENTERED 状态 case BC_ENTER_LOOPER: if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_ENTER_LOOPER called after \" \"BC_REGISTER_LOOPER\\n\", proc-&gt;pid, thread-&gt;pid); &#125; thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; break; // 设置 looper 为 BINDER_LOOPER_STATE_EXITED 状态 case BC_EXIT_LOOPER: thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED; break; // 发送 REQUEST_DEATH 或 CLEAR_DEATH 通知 case BC_REQUEST_DEATH_NOTIFICATION: case BC_CLEAR_DEATH_NOTIFICATION: &#123; uint32_t target; void __user *cookie; struct binder_ref *ref; struct binder_ref_death *death; // 从用户空间获取 binder_ref 描述 desc if (get_user(target, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 从用户空间获取 cookie if (get_user(cookie, (void __user * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 获取 binder_ref 引用 ref = binder_get_ref(proc, target); if (ref == NULL) &#123; binder_user_error(\"binder: %d:%d %s \" \"invalid ref %d\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_REQUEST_DEATH_NOTIFICATION ? \"BC_REQUEST_DEATH_NOTIFICATION\" : \"BC_CLEAR_DEATH_NOTIFICATION\", target); break; &#125; if (cmd == BC_REQUEST_DEATH_NOTIFICATION) &#123; if (ref-&gt;death) &#123; binder_user_error(\"binder: %d:%\" \"d BC_REQUEST_DEATH_NOTI\" \"FICATION death notific\" \"ation already set\\n\", proc-&gt;pid, thread-&gt;pid); break; &#125; // 为 binder_ref_death 对象分配内存空间 death = kzalloc(sizeof(*death), GFP_KERNEL); if (death == NULL) &#123; thread-&gt;return_error = BR_ERROR; break; &#125; // 初始化 binder_ref_death 对象 binder_stats_created(BINDER_STAT_DEATH); INIT_LIST_HEAD(&amp;death-&gt;work.entry); death-&gt;cookie = cookie; ref-&gt;death = death; if (ref-&gt;node-&gt;proc == NULL) &#123; ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; &#125; else &#123; if (ref-&gt;death == NULL) &#123; binder_user_error(\"binder: %d:%\" \"d BC_CLEAR_DEATH_NOTIFI\" \"CATION death notificat\" \"ion not active\\n\", proc-&gt;pid, thread-&gt;pid); break; &#125; death = ref-&gt;death; if (death-&gt;cookie != cookie) &#123; binder_user_error(\"binder: %d:%\" \"d BC_CLEAR_DEATH_NOTIFI\" \"CATION death notificat\" \"ion cookie mismatch \" \"%p != %p\\n\", proc-&gt;pid, thread-&gt;pid, death-&gt;cookie, cookie); break; &#125; // 将 ref-&gt;death 置空 ref-&gt;death = NULL; if (list_empty(&amp;death-&gt;work.entry)) &#123; death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; else &#123; BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER); death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR; &#125; &#125; &#125; break; case BC_DEAD_BINDER_DONE: &#123; struct binder_work *w; void __user *cookie; struct binder_ref_death *death = NULL; // 从用户空间获取 cookie if (get_user(cookie, (void __user * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) &#123; struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work); if (tmp_death-&gt;cookie == cookie) &#123; death = tmp_death; break; &#125; &#125; if (death == NULL) &#123; binder_user_error(\"binder: %d:%d BC_DEAD\" \"_BINDER_DONE %p not found\\n\", proc-&gt;pid, thread-&gt;pid, cookie); break; &#125; list_del_init(&amp;death-&gt;work.entry); // 如果 death-&gt;work.t 为 BINDER_WORK_DEAD_BINDER_AND_CLEAR 则修改为 BINDER_WORK_CLEAR_DEATH_NOTIFICATION if (death-&gt;work.t == BINDER_WORK_DEAD_BINDER_AND_CLEAR ) &#123; death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; &#125; break; default: return -EINVAL; &#125; *consumed = ptr - buffer; &#125; return 0;&#125; binder_transaction() 函数 在上文处理 BC_TRANSACTION 和 BC_REPLY 时，调用了 binder_transaction() 函数。我们继续追踪 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; if (reply) &#123; // BC_REPLY 处理流程 // 得到 binder_transaction 对象 in_reply_to = thread-&gt;transaction_stack; if (in_reply_to == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_empty_call_stack; &#125; binder_set_nice(in_reply_to-&gt;saved_priority); thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; // 获取目标线程 target_thread = in_reply_to-&gt;from; target_proc = target_thread-&gt;proc; &#125; else &#123; // BC_TRANSACTION 处理流程 // 查找目标节点 if (tr-&gt;target.handle) &#123; struct binder_ref *ref; // 获取 binder_ref 对象 ref = binder_get_ref(proc, tr-&gt;target.handle); target_node = ref-&gt;node; &#125; else &#123; // 索引为 0 则返回 context manager target_node = binder_context_mgr_node; &#125; // 得到目标进程 target_proc = target_node-&gt;proc; if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123; struct binder_transaction *tmp; tmp = thread-&gt;transaction_stack; while (tmp) &#123; if (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc) // 获得目标线程 target_thread = tmp-&gt;from; tmp = tmp-&gt;from_parent; &#125; &#125; &#125; // 设置要处理的目标进程或目标线程任务 if (target_thread) &#123; target_list = &amp;target_thread-&gt;todo; target_wait = &amp;target_thread-&gt;wait; &#125; else &#123; target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; // 为 binder_transaction 对象分配内存空间 t = kzalloc(sizeof(*t), GFP_KERNEL); binder_stats_created(BINDER_STAT_TRANSACTION); tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE); // 如果是同步传输(双向)，则将当前的 binder_thread 对象保存在 binder_transaction 对象的 from 中。 if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 设置 binder_transaction 对象 t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; t-&gt;to_proc = target_proc; t-&gt;to_thread = target_thread; t-&gt;code = tr-&gt;code; t-&gt;flags = tr-&gt;flags; t-&gt;priority = task_nice(current); // 为 binder_buffer 分配内存空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); // 设置 binder_buffer t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; t-&gt;buffer-&gt;transaction = t; t-&gt;buffer-&gt;target_node = target_node; if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 从用户空间拷贝数据到 binder_buffer if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; return_error = BR_FAILED_REPLY; goto err_copy_data_failed; &#125; if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; return_error = BR_FAILED_REPLY; goto err_copy_data_failed; &#125; off_end = (void *)offp + tr-&gt;offsets_size; for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; // 为 flat_binder_object 赋值 fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); // 转换 binder 类型，如果是 BINDER 则转换为 HANDLE， 如果是 HANDLE 则转为 BANDLE switch (fp-&gt;type) &#123; case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct binder_ref *ref; // 获取 binder_node 节点 struct binder_node *node = binder_get_node(proc, fp-&gt;binder); if (node == NULL) &#123; node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); if (node == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_binder_new_node_failed; &#125; node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK; node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS); &#125; if (fp-&gt;cookie != node-&gt;cookie) &#123; goto err_binder_get_ref_for_node_failed; &#125; // 获取 binder_ref 对象 ref = binder_get_ref_for_node(target_proc, node); // 转换类型 if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; fp-&gt;handle = ref-&gt;desc; binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); &#125; break; case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: &#123; // 获取 binder_ref 对象 struct binder_ref*ref = binder_get_ref(proc, fp-&gt;handle); // 转换类型 if (ref-&gt;node-&gt;proc == target_proc) &#123; if (fp-&gt;type == BINDER_TYPE_HANDLE) fp-&gt;type = BINDER_TYPE_BINDER; else fp-&gt;type = BINDER_TYPE_WEAK_BINDER; fp-&gt;binder = ref-&gt;node-&gt;ptr; fp-&gt;cookie = ref-&gt;node-&gt;cookie; binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, 0, NULL); &#125; else &#123; struct binder_ref *new_ref; new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node); fp-&gt;handle = new_ref-&gt;desc; binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL); &#125; &#125; break; // 文件类型 case BINDER_TYPE_FD: &#123; int target_fd; struct file *file; // 获得文件对象 file = fget(fp-&gt;handle); // 分配一个新的文件描述符 target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC); task_fd_install(target_proc, target_fd, file); fp-&gt;handle = target_fd; &#125; break; default: return_error = BR_FAILED_REPLY; goto err_bad_object_type; &#125; &#125; if (reply) &#123; // BC_REPLY 处理流程, binder_transaction 中释放 binder_transaction 对象 binder_pop_transaction(target_thread, in_reply_to); &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; // 同步状态(双向)需要设置回复 t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; thread-&gt;transaction_stack = t; &#125; else &#123; // 异步传输不需要设置回复 if (target_node-&gt;has_async_transaction) &#123; target_list = &amp;target_node-&gt;async_todo; target_wait = NULL; &#125; else target_node-&gt;has_async_transaction = 1; &#125; t-&gt;work.type = BINDER_WORK_TRANSACTION; list_add_tail(&amp;t-&gt;work.entry, target_list); tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); if (target_wait) // 唤醒目标线程 wake_up_interruptible(target_wait); return;&#125; 数据读取 - binder_thread_read() 函数 用户空间从 binder 驱动读取数据，从驱动角度来看是写出的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; if (*consumed == 0) &#123; // 第一次操作时向用户空间返回 BR_NOOP 命令 if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125;retry: // 获取将要处理的任务 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); if (wait_for_proc_work) &#123; if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED))) &#123; binder_user_error(\"binder: %d:%d ERROR: Thread waiting \" \"for process work before calling BC_REGISTER_\" \"LOOPER or BC_ENTER_LOOPER (state %x)\\n\", proc-&gt;pid, thread-&gt;pid, thread-&gt;looper); wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); &#125; binder_set_nice(proc-&gt;default_priority); if (non_block) &#123; // 非阻塞且没有数据则返回 EAGAIN if (!binder_has_proc_work(proc, thread)) ret = -EAGAIN; &#125; else // 阻塞则进入睡眠状态，等待可操作的任务 ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); &#125; else &#123; if (non_block) &#123; if (!binder_has_thread_work(thread)) ret = -EAGAIN; &#125; else ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread)); &#125; binder_lock(__func__); if (wait_for_proc_work) proc-&gt;ready_threads--; thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING; if (ret) return ret; while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 获取 binder_work 对象 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry); else &#123; if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */ goto retry; break; &#125; if (end - ptr &lt; sizeof(tr) + 4) break; switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: &#123; // 获取 binder_transaction 对象 t = container_of(w, struct binder_transaction, work); &#125; break; case BINDER_WORK_TRANSACTION_COMPLETE: &#123; cmd = BR_TRANSACTION_COMPLETE; // 返回 BR_TRANSACTION_COMPLETE 命令 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); binder_stat_br(proc, thread, cmd); // 从 work 链表中删除并释放内存 list_del(&amp;w-&gt;entry); kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); &#125; break; case BINDER_WORK_NODE: &#123; // 获得 binder_node 节点 struct binder_node *node = container_of(w, struct binder_node, work); uint32_t cmd = BR_NOOP; const char *cmd_name; // 根据节点类型，增加/获取、减少/释放节点索引 int strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs; int weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong; // 构造 BR_* 命令 if (weak &amp;&amp; !node-&gt;has_weak_ref) &#123; cmd = BR_INCREFS; cmd_name = \"BR_INCREFS\"; node-&gt;has_weak_ref = 1; node-&gt;pending_weak_ref = 1; node-&gt;local_weak_refs++; &#125; else if (strong &amp;&amp; !node-&gt;has_strong_ref) &#123; cmd = BR_ACQUIRE; cmd_name = \"BR_ACQUIRE\"; node-&gt;has_strong_ref = 1; node-&gt;pending_strong_ref = 1; node-&gt;local_strong_refs++; &#125; else if (!strong &amp;&amp; node-&gt;has_strong_ref) &#123; cmd = BR_RELEASE; cmd_name = \"BR_RELEASE\"; node-&gt;has_strong_ref = 0; &#125; else if (!weak &amp;&amp; node-&gt;has_weak_ref) &#123; cmd = BR_DECREFS; cmd_name = \"BR_DECREFS\"; node-&gt;has_weak_ref = 0; &#125; // 向用户空间返回命令 if (cmd != BR_NOOP) &#123; if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); if (put_user(node-&gt;ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); if (put_user(node-&gt;cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); binder_stat_br(proc, thread, cmd); &#125; else &#123; list_del_init(&amp;w-&gt;entry); if (!weak &amp;&amp; !strong) &#123; rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes); kfree(node); binder_stats_deleted(BINDER_STAT_NODE); &#125; &#125; &#125; break; case BINDER_WORK_DEAD_BINDER: case BINDER_WORK_DEAD_BINDER_AND_CLEAR: case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123; struct binder_ref_death *death; uint32_t cmd; // 获取 binder_ref_death 对象 death = container_of(w, struct binder_ref_death, work); // 构造返回命令 if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE; else cmd = BR_DEAD_BINDER; // 向用户空间返回命令 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 将 cookie 返回给用户空间 if (put_user(death-&gt;cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); binder_stat_br(proc, thread, cmd); if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) &#123; list_del(&amp;w-&gt;entry); kfree(death); binder_stats_deleted(BINDER_STAT_DEATH); &#125; else list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death); if (cmd == BR_DEAD_BINDER) goto done; /* DEAD_BINDER notifications can cause transactions */ &#125; break; &#125; if (!t) continue; if (t-&gt;buffer-&gt;target_node) &#123; // 获得 binder_node 节点 struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // 将数据封装到 binder_transaction_data 对象 tr.target.ptr = target_node-&gt;ptr; tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); // 设置返回的命令类型 cmd = BR_TRANSACTION; &#125; else &#123; tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; &#125; tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) &#123; struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); &#125; else &#123; tr.sender_pid = 0; &#125; tr.data_size = t-&gt;buffer-&gt;data_size; tr.offsets_size = t-&gt;buffer-&gt;offsets_size; tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 拷贝 binder_transaction_data 对象到用户空间 if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_stat_br(proc, thread, cmd); // 移除 binder_transaction 并释放空间 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // 如果是同步操作，则将 thread 对象保存在 binder_transaction 中，返回给发送方进程, 否则释放 binder_transaction 对象 if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; t-&gt;to_parent = thread-&gt;transaction_stack; t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; &#125; else &#123; t-&gt;buffer-&gt;transaction = NULL; kfree(t); binder_stats_deleted(BINDER_STAT_TRANSACTION); &#125; break; &#125;&#125; 从上述代码可以看出 binder 驱动的具体实现，以及是如何发送和接收数据的。 5. Binder 与系统服务5.1 Context.getSystemService()Android 系统在启动后会在后台运行很多系统服务提供给应用使用，这些 服务) 主要有 WindowManager, LayoutInflater, ActivityManager, PowerManager, AlarmManager, NotificationManager, KeyguardManager, LocationManager, SearchManager, Vibrator, ConnectivityManager, WifiManager, AudioManager, MediaRouter, TelephonyManager, SubscriptionManager, InputMethodManager, UiModeManager, DownloadManager, BatteryManager, JobScheduler, NetworkStatsManager 我们可以通过 Context.getSystemService(String name) 来获取 服务)。 例如 可以通过如下方法从 xml 中插入新的视图 LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE); inflater.inflate(R.layout.view, root, true); 5.2 Context.getSystemService() 源码分析追踪 ContextImpl getSystemService() 源代码 1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; 继续追踪 SystemServiceRegistry 源代码 1234567/** * Gets a system service from a given context. */public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 追踪 SYSTEM_SERVICE_FETCHERS 可以发现在 SystemServiceRegistry 静态区中注册了几乎所有的系统服务 1234567891011121314registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;);registerService(Context.LOCATION_SERVICE, LocationManager.class, new CachedServiceFetcher&lt;LocationManager&gt;() &#123; @Override public LocationManager createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE); return new LocationManager(ctx, ILocationManager.Stub.asInterface(b)); &#125;&#125;); 上面代码片断中，PhoneLayoutInflater 最终回到了 LayoutInflater。而 LocationManager 则是对 ILocationManager 的封装。可以发现，在 frameworks/base/location/java/android/location 包下含有大量的 AIDL 文件。 继续追踪 ServiceManager.getService(Context.LOCATION_SERVICE) 1234567891011121314151617181920212223242526272829private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125;/** * Returns a reference to a service with the given name. * * @param name the name of the service to get * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist */public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in getService\", e); &#125; return null;&#125; 从上面代码片断可以看出，ServiceManager 会从 sCache 缓存或 IServiceManager 中查找服务并返回一个 IBinder 对象。这个 IBinder 就是一个远程对象，可以通过它与其他进程交互。 继续深入 getIServiceManager().getService(name) , 进入 ServiceManagerNative 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Cast a Binder object into a service manager interface, generating * a proxy if needed. */static public IServiceManager asInterface(IBinder obj)&#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj);&#125;class ServiceManagerProxy implements IServiceManager &#123; public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public IBinder getService(String name) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder; &#125; private IBinder mRemote;&#125; 从上边代码片断可以看到，ServiceManager.getIServiceManager() 返回的是一个 ServiceManagerProxy, 而 ServiceManager.getService() 则是在 ServiceManagerProxy 中通过 ServiceManager 的远程 Binder 对象 mRemote，操作 Parcel 数据，调用 IBinder.transact(int code, Parcel data, Parcel reply, int flags) 方法来发送请求，并通过 reply.readStrongBinder() 返回了要查找的服务的远程对象。 可以看到，系统服务的获取方式也是通过 AIDL 的方式实现的。 6. 结论1. Binder 的实现涉及到 kernel 驱动，本地层，JNI 和应用层，贯穿了整个 Ａndroid 系统。系统服务获取、Activity/Service 启动、Intent的传递等都离不开 binder,要掌握 binder 的原理需要深入到系统的每一层代码。 2. 上层的 android.os.Binder 只是对 binder 的又一次抽象封装，我们在应用中一般也不会直接使用。 3. AIDL 本质上是一个用于封装 Binder 操作的工具，最终的进程间通信由 Binder 的 transact 和 onTransact 完成。我们在应用中实现 AIDL 接口，可以快速实现进程间通信。 7. 参考Android Binder机制 Android进程间通信（IPC）机制Binder Android Binder Android Architecture Binder AIDL与Binder框架浅谈 Binder框架解析 Deep Dive into Android IPC/Binder Framework at Android Builders Summit 2013 Android Builders Summit 2013 - Deep Dive into Android IPC/Binder Framework (video) Binder源码分析之驱动层（原） 深入分析Android Binder 驱动 构造IOCTL命令的学习心得—–_IO, _IOR, _IOW, _IOWR 幻数的理解 Service与Android系统设计（7）— Binder驱动 Android Binder Binder机制，从Java到C （7. Native Service） 待补充的内容 1. 客户端 bindService() 流程及源码分析 2. Binder Native 层其他源码文件分析 3. 系统服务（SystemService）详细列表及在本地层的源码分析 4. SystemManager 源码分析 5. 完善 binder 驱动内容，补充关系图 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"AsyncTask源码分析","date":"2017-07-26T11:36:58.000Z","path":"2017/07/26/AsyncTask源码分析.html","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 1. 简介AsyncTask是android提供的一种异步消息处理的解决方案，能简化我们在子线程中更新UI控件，使用AsyncTask你将看不到任何关于操作线程的代码 2. 版本差别2.1 线程池配置 android3.0以前线程池配置，代码如下所示 12345678private static final int CORE_POOL_SIZE = 5;//核心线程数量private static final int MAXIMUM_POOL_SIZE = 128;//线程池中允许的最大线程数目//当线程数目大于核心线程数目时，如果超过这个keepAliveTime时间，那么空闲的线程会被终止private static final it KEEP_ALIVE = 10;…… private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory); android3.0以后更加灵活，根据cpu核数配置CORE_POOL_SIZE和MAXIMUM_POOL_SIZE 123456//根据cpu的大小来配置核心的线程private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;//核心线程数量//线程池中允许的最大线程数目private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;//空闲线程的超时时间 2.2 串行和并行，引用来自这篇文章 android 1.5以前的时候execute是串行执行的 android 1.6直到android 2.3.2被修改为并行执行，执行任务的线程池就是THREAD_POOL_EXECUTOR android 3.0以后，默认任务是串行执行的，如果想要并行执行任务可调用executeOnExecutor(Executor exec, Params.. params) 具体用法可参照Android AsyncTask的骗术 3. 基本用法3.1 继承AsyncTask，设置子类三个泛型的参数 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; Params 异步任务处理的参数 Progress 异步任务执行过程中返回给主线程的进度值，通过publishProgress()方法发送出去 Result 异步任务执行结束返回的结果的结果类型，可以为boolean，或者bitmap等类型 3.2 子类必须实现的抽象方法 onPreExecute 执行后台耗时操作前被调用，通常用于完成一些初始化操作，比如2.3例子中初始化dialog的操作，或者一些集合容器 doInBackGround 必须实现，异步执行后台线程将要完成的任务(该方法在子线程运行，下面源码会分析到) onProgressUpdate 在doInBackGround方法中调用publishProgress方法，AsyncTask就会主动调用onProgressUpdate实现更新 任务的执行进度 onPostExecute 当doInBackGround完成后，系统会自动调用，销毁一些dialog的操作，并将doInBackGround方法返回的值传给该方法 执行的大致流程是： onPreExecute-&gt; doInBackGround-&gt;onProgressUpdate(调用publishProgress的时候)-&gt;onPostExecute 3.3 用法案例1、实例化子类1234//串行实例化new DownAsyncTask().extcute();//并行实例化new DownAsyncTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,\"\"); 2、点击查看，代码案例 3.4 取消异步任务1AsyncTask.cancel(mayInterruptIfRunning); mayInterruptIfRunning是boolean类型的(注意这里true和false的区别)，其调用流程：AsyncTask.cancel() -&gt; FutureTask.cancel()。FutureTask.cancel()的源码如下：123456789101112131415161718192021222324public boolean cancel(boolean mayInterruptIfRunning) &#123; //检测当前状态是否是NEW,如果不是，说明任务已经完成或取消或中断，所以直接返回。 if (!(state == NEW &amp;&amp; U.compareAndSwapInt(this, STATE, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // in case call to interrupt throws exception //如果mayInterruptIfRunning为true的时候，线程就会调用interrupt()方法，抛出异常。 if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) //调用interrupt方法，状态设置为INTERRUPTING，然后试着中断线程，完成后设置状态为INTERRUPTED t.interrupt(); &#125; finally &#123; // final state U.putOrderedInt(this, STATE, INTERRUPTED); &#125; &#125; &#125; finally &#123; //通知等待线程的结果（因为FutureTask.get()法获得计算结果的唯一方法，如果计算没有完成，此方法会堵塞直到计算完成） finishCompletion(); &#125; return true; &#125; 以下是我代码例子中doInBackground()中注释的，这里主要是为了强调true和false的区别 123456try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; 如果线程处于休眠状态，为true则正在执行的线程将会中断，抛出异常，但执行的任务线程会继续执行完毕调用onCanceled()。为false则正在执行的线程不会中断，任务线程执行完毕调用onCanceled() 如果线程不处于休眠状态，为true和false都没有区别，任务线程执行完毕后调用onCanceled()正确地取消要在doInBackground(Void... params)使用isCancelled()来判断，退出循环操作。如下面的 1234567891011121314@Overrideprotected Boolean doInBackground(Void... params) &#123; while (progress &lt; 10000) &#123; progress = progress + 2; Log.i(\"当前的进度\", \"progress==\" + progress); publishProgress(progress); //判断是不是调用了AsyncTask.cancel(mayInterruptIfRunning)，如果已经调用了， if(isCancelled()) &#123; break;//跳出循环，马上调用onCancelled()方法，不需要等doInBackground执行完任务 &#125; &#125; return true;&#125; 4. AsyncTask源码分析(基于android3.0以后分析)4.1 AsyncTask构造函数12345678910111213141516171819202122232425262728293031323334/**AsyncTask的构造函数源码片段**/public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; //异步任务执行的时候回调call方法 public Result call() throws Exception &#123; mTaskInvoked.set(true); //设置线程的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); //将结果发送出去 return postResult(result); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; //任务执行完毕后会调用done方法 @Override protected void done() &#123; try &#123; //get()表示获取mWorker的call的返回值，即Result.然后看postResultIfNotInvoked方法 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; AsyncTask的实例化是在UI线程中。12345//@MainThread表示这个动作是在UI线程中完成@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; 构造函数初始化了两个成员变量mWorker和mFuture。mWorker为WorkerRunnable类型的匿名内部类实例对象（实现了Callable接口），mFuture为FutureTask类型的匿名内部类实例对象，将mWorker作为mFuture的形参（重写了FutureTask类的done方法）。 WorkerRunnable是一个实现了Callable的抽象类，扩展了Callable多了一个Params参数 1234private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt;&#123; Params[] mParams;&#125; 下面讲述下Callable和Runnable的区别 Callable的接口方法是call，Runnable是run Callable可以带返回值，Runnable不行，结果通过Future.get()获取 Callable可以捕获异常，Runnable不行 123456789101112131415161718192021public class CallableAndFuture &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; public Integer call() throws Exception &#123; return new Random().nextInt(100); &#125; &#125;; //那WorkerRunnable的回调方法call肯定是在FutureTask中调用的 FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable) ); new Thread(future).start(); try &#123; Thread.sleep(5000);// 可能做一些事情 System.out.println(future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; FutureTask的构造函数如下，1234567public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); //将AsyncTask里面初始化的callable赋值给FutureTask里面的callable，证实了WorkerRunnable的回调方法call肯定是在FutureTask中调用的 this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 查看FutureTask类，它实现了接口Runnable1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; // 实现了RunnableFuture接口 作为Runnable被线程执行，同时将Callable作为构造函数的参数传入，这样组合的好处是，假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到。FutureTask的run方法要开始回调WorkerRunable的call方法了，call里面调用doInBackground(mParams)，终于回到我们后台任务了，调用我们AsyncTask子类的doInBackground()，由此可以看出doInBackground()是在子线程中执行的，如下图所示 4.2 核心方法1、execute()方法12345678private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); /** AsyncTask类的execute方法**/ public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; //调用executeOnExecutor方法 return executeOnExecutor(sDefaultExecutor, params);&#125; 当执行execute方法时，实际上是调用了executeOnExecutor方法。这里传递了两个参数，一个是sDefaultExecutor，一个是params。从上面的源码可以看出，sDefaultExecutor其实是一个SerialExecutor对象，实现了串行线程队列。params其实最终会赋给doInBackground方法去处理。 2、executeOnExecutor()方法1234567891011121314151617181920212223242526//exec执行AsyncTask.execute()方法时传递进来的参数sDefaultExecutor，这个sDefaultExecutor其实就是SerialExecutor对象。默认是串行执行的//若想变成并发执行exec可以传入AsyncTask.THREAD_POOL_EXECUTOR。public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; //如果一个任务已经进入执行的状态，再执行就会抛异常。这就决定了一个AsyncTask只能执行一次 if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; //一旦executeOnExecutor调用了就标记为运行状态 mStatus = Status.RUNNING; //实际是调用子类里面的onPreExecute onPreExecute(); //将处理的参数类型赋值给mWorker mWorker.mParams = params; //execute是调用SERIAL_EXECUTOR的execute，mFuture就是之前AsyncTask构造初始化赋值的FutureTask。 exec.execute(mFuture); return this; &#125; 这里要说明一下，AsyncTask的异步任务有三种状态 PENDING 待执行状态。当AsyncTask被创建时，就进入了PENDING状态。 RUNNING 运行状态。当调用executeOnExecutor，就进入了RUNNING状态。 FINISHED 结束状态。当AsyncTask完成(用户cancel()或任务执行完毕)时，就进入了FINISHED状态。 3、SerialExecutor的execute方法1234567891011121314151617181920212223242526272829303132333435private static class SerialExecutor implements Executor &#123; //循环数组实现的双向Queue。大小是2的倍数，默认是16。有队头队尾两个下标 final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); //当前正在运行的runnable Runnable mActive; public synchronized void execute(final Runnable r) &#123; //添加到双端队列里面去 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; //执行的是mFuture就是之前AsyncTask构造初始化赋值的FutureTask的run()方法 r.run(); &#125; finally &#123; //无论执行结果如何都会取出下一个任务执行 scheduleNext(); &#125; &#125; &#125;); //如果没有活动的runnable，从双端队列里面取出一个runnable放到线程池中运行 //第一个请求任务过来的时候mActive是空的 if (mActive == null) &#123; //取出下一个任务来执行 scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; //从双端队列中取出一个任务 if ((mActive = mTasks.poll()) != null) &#123; //线程池执行取出来的任务，真正执行任务的 THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125;//java exec.execute(mFuture)执行时，SerialExecutor将FutureTask作为参数执行execute方法。在execute方法中，假设FutureTask插入进了两个以上的任务队列到mTasks中，第一次过来mActive==null，通过mTasks.poll()取出一个任务丢给线程池运行，线程池执行r.run，其实就是执行FutureTask的run方法，因为传递进来的r参数就是mFuture。等到上一个线程执完r.run()完之后，这里是通过一个try-finally代码块，并在finally中调用了scheduleNext()方法，保证无论发生什么情况，scheduleNext()都会取出下一个任务执行。接着因为mActive不为空了，不会再执行`scheduleNext()，由于存在一个循环队列，每个 Runnable 被执行的时候，都进入去队列，然后在执行完后出队，才会进入下一个 Runnable 的执行流程。由此可知道这是一个串行的执行过程，同一时刻只会有一个线程正在执行，其余的均处于等待状态。 1234567891011mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams);//调用子类的doInBackground Binder.flushPendingCommands(); return postResult(result);//执行完后通过postResult结果传递出去 &#125; &#125;; 上文中提到调用call()的流程：SerialExecutor.execute() -&gt; FutureTask.run() -&gt; WorkerRunnable.call() 如果回调了call()方法，就会调用了doInBackground(mParams)方法，这都是在子线程中执行的。执行完后，将结果通过postResult(result)发送出去。 4、AsyncTask的postResult方法123456789private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") //获取一个handler，等到一个消息，将结果封装在Message Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result));//new AsyncTaskResult&lt;Result&gt;(this, result)将得到的结果再做了一层封装 //将消息发送到主线程，会回调handleMessage()方法 message.sendToTarget(); return result;&#125; 因为postResult(Result result)还是在子线程中调用的，如果要发送给主线程，必须通过Handler。源码中使用sHandler并带着MESSAGE_POST_RESULT和封装了任务执行结果的对象AsyncTaskResult，然后message.sendToTarget()开始发消息。123456789private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; //初始化一个InternalHandler，用与将结果发送给主线程 sHandler = new InternalHandler(); &#125; return sHandler; &#125; &#125; 并在InternalHandler的handleMessage中开始处理消息，InternalHandler的源码如下所示：123456789101112131415161718192021 private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; // 这个handler是关联到主线程的 super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 这里根据消息的类型进行了判断，如果是MESSAGE_POST_RESULT消息，就会去执行finish()方法，finish()源码如下文所示：12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED; &#125; 如果任务已经取消了，调用onCancelled方法，如果没被取消，则调用onPostExecute()方法。 如果doInBackground(Void... params)调用publishProgress()方法，实际就是发送一条MESSAGE_POST_PROGRESS消息，就会去执行onProgressUpdate()方法。publishProgress()的源码如下文所示： 1234567@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 如果你还不够清晰，请看下面的这个流程图 5. AsyncTask需要注意的坑 AsyncTask的对象必须在主线程中实例化，execute方法也要在主线程调用(查看3.1节-AsyncTask构造函数) 同一个AsyncTask任务只能被执行一次，即只能调用一次execute方法，多次调用时将会抛异常（查看3.2里面的第二小节） cancel()方法无法直接中断子线程，只是更改了中断的标志位。控制异步任务执行结束后不会回调onPostExecute()。正确的取消异步任务要cancel()方法+doInbacground()做判断跳出循环 AsyncTask在Activity通常作为匿名的内部类来使用，如果 AsyncTask 中的异步任务在 Activity 退出时还没执行完或者阻塞了，那么这个保持的外部的 Activity 实例得不到释放（内部类保持隐式外部类的实例的引用），最后导致会引起OOM，解决办法是：在 AsyncTask 使用弱引用外部实例，或者保证在 Activity 退出时，所有的 AsyncTask 已执行完成或被取消 会产生阻塞问题，尤其是单任务顺序执行的情况下，一个任务执行时间过长会阻塞其他任务的执行 不建议使用AsyncTask进行网络操作 AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs。 Android文档中有写到AsyncTask应该处理几秒钟的操作（通常为轻量的本地IO操作），由于网络操作存在不确定性，可能达到几秒以上，所以不建议使用。 6. 版本兼容AsyncTaskCompat有兴趣的可以看这篇文章 7. 总结尽管AsyncTask现在已经很少使用了，但是它的一些设计思路可以借鉴到我们的框架中。比如我们的代码中尽量设计灵活一些，就像AysnTask里面存在串行、并行的操作一样，提供用户同的api，让用户在不同的场景下选择不同的业务逻辑处理。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"AndroidStudio插件大全","date":"2017-07-25T13:30:45.000Z","path":"2017/07/25/AndroidStudio插件大全.html","text":"#1.GsonFormat快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应Java Bean的过程。 使用方法：快捷键Alt+S也可以使用Alt+Insert选择GsonFormat 2.Android ButterKnife Zelezny配合ButterKnife实现注解，从此不用写findViewById，想着就爽啊。在Activity，Fragment，Adapter中选中布局xml的资源id自动生成butterknife注解。 使用方法：Ctrl+Shift+B选择图上所示选项 3.Android Code Generator根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。 4.Android Parcelable code generatorJavaBean序列化，快速实现Parcelable接口。 5.Android Methods Count显示依赖库中得方法数 6.Lifecycle Sorter可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K 7.CodeGlance在右边可以预览代码，实现快速定位 8.findBugs-IDEA查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…） 9.ADB WIFI使用wifi无线调试你的app，无需root权限也可参考以下文章：Android wifi无线调试App新玩法ADB WIFI 10.AndroidPixelDimenGeneratorAndroid Studio自动生成dimen.xml文件插件 11.JsonOnlineViewer在Android Studio中请求、调试接口 12.Android Styler根据xml自动生成style代码的插件 Usage:a. copy lines with future style from your layout.xml fileb. paste it to styles.xml file with Ctrl+Shift+D (or context menu)c. enter name of new style in the modal windowd. your style is prepared! 13.Android Drawable Importer这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片） 14.SelectorChapek for Android通过资源文件命名自动生成Selector文件。 15.GenerateSerialVersionUID实现Serializable序列化bean Adds a new action ‘SerialVersionUID’ in the generate menu (alt + ins). The action adds an serialVersionUID field in the current class or updates it if it already exists, and assigns it the same value the standard ‘serialver’ JDK tool would return. The action is only visible when IDEA is not rebuilding its indexes, the class is serializable and either no serialVersionUID field exists or its value is different from the one the ‘serialver’ tool would return. 16.genymotion速度较快的android模拟器 17.LeakCanary帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便。可以参考以下文章：LeakCanary 中文使用说明 18.Android Postfix Completion可根据后缀快速完成代码，这个属于拓展吧，系统已经有这些功能，如sout、notnull等，这个插件在原有的基础上增添了一些新的功能，我更想做的是通过原作者的代码自己定制功能，那就更爽了 19.Android Holo Colors Generator通过自定义Holo主题颜色生成对应的Drawable和布局文件 20.dagger-intellij-plugindagger可视化辅助工具 21.GradleDependenciesHelperPluginmaven gradle 依赖支持自动补全 22.RemoveButterKnifeButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。 具体介绍 23.AndroidProguardPlugin一键生成项目混淆代码插件，值得你安装~(不过目前可能有些第三方项目的混淆还未添加完全) 24.otto-intellij-pluginotto事件导航工具。 25.eventbus-intellij-plugineventbus导航插件(对于最新版的 EventBus 3.0.0 好像无效,请替换为eventbus3-intellij-plugin此插件地址在本文第51个) 26.idea-markdownmarkdown插件 27.Sexy Editor设置AS代码编辑区的背景图 首先点击界面的设置按钮 进入设置界面，选中Plugins,右边选择 Browser … ，输入Sexy … 下面自动弹出候选插件，右边点击Install 安装安装成功 后需要重启AS重启完成之后 进入设置界面 选择other Setting 下的Sexy Editor ， 右侧 insert 一张或多张图片即可，上面的其他设置可以设置方位 间隔时间 透明度等等，设置完成后，要关闭打开的文件，重新打开项目文件即可在代码编辑区显示插入的图片，作为代码编辑区的背景图。 28.folding-plugin布局文件分组的插件 29.Android-DPI-CalculatorDPI计算插件 使用：或者 30.gradle-retrolambda在java 6 7中使用 lambda表达式插件 修改编译的jdk为java8: 31.Android Studio Prettify可以将代码中的字符串写在string.xml文件中 选中字符串鼠标右键选择图中所示 这个插件还可以自动书写findViewById 32.Material Theme UI添加Material主题到你的AS 33..ignore我们都知道在Git 中想要过滤掉一些不想提交的文件，可以把相应的文件添加到.gitignore 中，而.gitignore 这个Android Studio 插件根据不同的语言来选择模板，就不用自己在费事添加一些文件了，而且还有自动补全功能，过滤文件再也不要复制文件名了。我们做项目的时候，并不是所有文件都是要提交的，比如构建的build 文件夹，本地配置文件，每个Module 生成的iml 文件，但是我们每次add，commit 都会不小心把它们添加上去，而gitignore 就是解决这种痛点的，如果你不想提交的文件，就可以在创建项目的时候将这个文件中添加即可，将一些通用的东西屏蔽掉。 34.CheckStyle-IDEACheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。 35.Markdown Navigatorgithub:Markdown NavigatorMarkdown插件 36.ECTranslationAndroid Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文。 37.PermissionsDispatcher plugingithub:PermissionsDispatcher plugin自动生成6.0权限的代码 38.WakaTimegithub:WakaTime记录你在IDE上的工作时间 39.AndroidWiFiADB无线调试应用 40.AndroidLocalizationer可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件 41.TranslationPlugin又一翻译插件,可中英互译。 42.SingletonTest快速生成单例模式的预设 43.BorePluginAndroid Studio 自动生成布局代码插件 代码生成规则a.自动遍历目标布局中所有带id的文件, 无id的不会识别处理b.控件生成的变量名默认为id名称, 可以在弹出确认框右侧的名称输入栏中自行修改c.所有的Button或者带clickable=true的控件, 都会自动在代码中生成setOnClickListener相关代码d.所有EditText控件, 都会在代码中生成非空判断代码, 如果为空会提示EditText的hint内容, 如果hint为空则提示xxx字符串不能为空字样, 最后会把所有输入框的验证合并到一个submit方法中e.会自动识别布局中的include标签, 并读取对应布局中的控件 44.jimu Mirror能够实时预览Android布局，它会监听布局文件的改动，如果有代码变化，就会立即刷新UI。 45.jRebel For Android不仅能够做到UI布局的实时预览，它甚至做到了让你更改java代码后就能实时替换apk中的类文件，达到应用实时刷新，官网的介绍是：Skip build, install and run，因此它可以节约我们很多很多的时间，它的效果也十分不错。 46.sdk-manager-pluginSDK管理插件，自动检测更新并下载。(图片与插件无关哈) 47.Codota搜索最好的Android代码。(Studio里面直接可以搜到此插件) 48.LayoutFormatterdrakeet 开发一个一键格式化你的 XML 文件的 Android Studio 插件，至于为什么不用 Android Studio 自带的格式化功能而用这个插件，可以看下作者的一篇 Blog -&gt; 当我们谈 XML 布局文件代码的优雅性 49.android-strings-search-plugin一个可以通过输入文字找到strings.xml资源的插件 50.ideaVimvim 本身就是一款很优秀的文本编辑器，而Android Studio 更是一款编写APP应用的神器。如果两个款优秀的软件结合在一起感觉会怎样呢？详细请看文章:Android Studio ＋Vim 51.eventbus3-intellij-plugin引导 EventBus 的 post 和 event(对于最新版的 EventBus 3.0.0 有效)主要Bug修复工作：修改包名和方法名以适应 EventBus 3.X替换一个在新版的 intellij plugin SDK 已经不存在的类增加若干 try-catch ，防止插件崩溃 52.ExynapExynap 一个帮助开发者自动生成样板代码的 AndroidStudio 插件 53.gradle-cleaner-intellij-pluginForce clear delaying &amp; no longer needed Gradle tasks. 54.MVPHelper一款Intellj IDEA 和Android Studio的插件，可以为MVP生成接口以及实现类，解放双手。具体请查看Android Studio插件之MVPHelper，一键生成MVP代码一文 如果还有更好玩更好用的插件欢迎fork + pull request 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Android进阶资料大全","date":"2017-07-22T09:29:25.000Z","path":"2017/07/22/Android进阶资料大全.html","text":"目录 书籍 开发环境/工具 博客 社区 开源项目学习 Android 开发者杂志周刊 Awesome 系列 动画系列 Material Design 设计 素材 开源库收集 设计模式 实践篇 Git 教程 文档 其它资料收集 知乎上的讨论 贡献者 License ============================================================= 书籍 书籍名称 推荐理由 Thinking In Java 中文版 学习 Android 开发, 首先需要 Java 基础, 这里推荐 Thinking In Java, Thinking In Java 是 Java 的经典书籍, 是学习 Java 语言必备书籍 第一行代码 郭霖大神的杰作, 郭神在CSDN中的博客文章非常不错, 书我看了, 非常适合新手, 里面的内容非常棒, 建议结合郭神博客文章一起来学习 疯狂Android讲义第三版 作者是李刚, 这本书是基于 Android 5.0 来讲的, 我看过第二版, 这本书给我第一感觉就是很厚, 但里面内容写的还是很详细的, 代码很多, 可以跟着代码一步步敲 Android群英传 本书作者 @Tomcat 的猫, 曾就职于上海 TCL 通讯, 从事 Alcatel(阿尔卡特) Android 手机系统的定制工作, 活跃于 CSDN, 目前就职于上海沪江网 Android 开发部RD项目组, 负责沪江 App 的功能预研 Android开发艺术探索 由@任玉刚Coder所著, 是一本 Android 进阶类书籍, 采用理论, 源码和实践相结合的方式来阐述高水准的 Android 应用开发要点. 本书从三个方面来组织内容: 第一, 介绍 Android 开发者不容易掌握的一些知识点: 第二,结合Android源代码和应用层开发过程, 融会贯通, 介绍一些比较深入的知识点: 第三, 介绍一些核心技术和Android的性能优化思想. App 研发录 本书作者是包建强, 本书是作者多年 App 开发的经验总结, 从 App 架构的角度, 重点总结了 Android 应用开发中常见的实用技巧和疑难问题解决方法, 为打造高质量 App 提供有价值的实践指导, 迅速提升应用开发能力和解决疑难问题的能力. 这本书非常有利于 Android 开发者进阶. Android 设计模式源码分析 本书作者是开发技术前线创立者之一 Mr.Simple, 该书从 Android 源码的角度由浅入深地剖析设计模式的运用, 让工程师们把设计与模式重视起来, 提升自己的设计能力与代码质量 开发环境/工具(附上: 由 @脉脉不得语 收集维护超多开发工具下载地址 AndroidDevTools, 后五个工具资料在 stormzhang 博客中找到的,地址) 环境/工具 简述 Android Studio 这个开发工具上手需要一定的时间, 自从 Google 推出1.0正式版, 这个工具一直火爆, 目前 github 上面的绝大多数开源项目都是使用 Android Studio 工具, 这就是 Android 开发工具的未来, 所以极力推荐 Android 开发人员使用这个工具, 该工具已更新到 2.0 预览版, 性能逐渐稳定提高, 没有之前那么卡了 Genymotion 强大好用高性能的 Android 模拟器, 自带的那个模拟器简直不忍直视, 启动超慢的, 跟这个没法比, 无论你是用 Eclipse 还是 Android Studio 里面都有 Genymotion 插件 jadx 一个 Android 反编译神器, 不同于常见的 dex2jar, 这个反编译器生成代码的 try/catch 次数更少, View也不再是数字 id 了, 可读性更高 android-selector 可以根据指定颜色生成 Selector Drawable 的插件 GradleDependenciesHelperPlugin Gradle 依赖自动补全插件 Smali Viewer sv 是一款免费 APK 分析软件, 对你感兴趣的 APP 分析看看它们都用了些什么, 对你学习借鉴有一定帮助 folding-plugin layout 文件夹里的布局文件一般很长很长没有目录, 这个插件就可以把 layout 分好层级结构, 类似 src 下目录结构 CodeGlance 在编辑代码最右侧, 显示一块代码小地图 Statistic 统计整个项目行数的插件, 这可表示我们日日夜夜辛辛苦苦必备插件 idea-markdown 在 AS 中编写 Markdown 文件, 可以直接预览网页显示效果, 对于你经常编写 Markdown 文件的你值得拥有这个插件 Stetho Stetho 是 Facebook 出品的一个强大的 Android 调试工具,使用该工具你可以在 Chrome Developer Tools 查看 App 的布局, 网络请求(仅限使用 Volley, okhttp 的网络请求库), sqlite, preference, 一切都是可视化的操作,无须自己在去使用 adb, 也不需要 root 你的设备 ClassyShark ClassyShark 是 Google 发布的一款可以查看 Android 可执行文件的浏览工具, 支持.dex, .aar, .so, .apk, .jar, .class, .xml 等文件格式, 分析里面的内容包括 classes.dex 文件, 包方法数量, 类, 字符串, 使用的 NativeLibrary 等 AndroidWiFiADB 使用 WiFi 连接而不需要 USB 连接 Android 设备达到安装, 运行, 调试应用的目的 checkstyle-idea Checkstyle-idea 是一款检查自己写的代码是否符合规范的插件, 该插件是根据 checkstyle.xml 文件来检查的, checkstyle.xml 文件可以由自己自己定义, 也可以使用一些大公司定义的规范, 如果不懂得如何定义, 可以查看 官方文档, 该插件的详细介绍以及使用, 可以看一下咕咚大侠写的 文章 ECTranslation ECTranslation 是 Android Studio 开发工具的一个翻译插件, 可以将英文翻译为中文, 英语基础差的童鞋装上它就可以轻松阅读 Android 源码啦 Android Methods Count 统计 Android 依赖库中方法的总个数, 避免应用方法数超过 65K 问题 AndroidLocalizationer 可用于将项目中的 string 资源自动翻译为其他语言的插件, 其翻译支持使用 Microsoft Translator 或 Google Translation ButterKnife Zelezny ButterKnife 生成器, 使用起来非常简单方便, 为你简写了很多 findViewId 代码, 如果你不了解 ButterKnife 的可以到这里看看 SelectorChapek 设计师给我们提供好了各种资源, 每个按钮都要写一个selector是不是很麻烦? 这么这个插件就为解决这个问题而生, 你只需要做的是告诉设计师们按照规范命名就好了, 其他一键搞定 GsonFormat 现在大多数服务端 api 都以 json 数据格式返回, 而客户端需要根据 api 接口生成相应的实体类, 这个插件把这个过程自动化了, 赶紧使用起来吧 ParcelableGenerator Android中的序列化有两种方式, 分别是实现 Serializable 接口和 Parcelable 接口, 但在 Android 中是推荐使用 Parcelable, 只不过我们这种方式要比Serializable方式要繁琐, 那么有了这个插件一切就ok了 LeakCanary 良心企业 Square 最近刚开源的一个非常有用的工具, 强烈推荐, 帮助你在开发阶段方便的检测出内存泄露的问题, 使用起来更简单方便, 而且我们团队第一时间使用帮助我们发现了不少问题, 英文不好的这里有雷锋同志翻译的中文版 LeakCanary 中文使用说明 更多 该作者收集整理了 40 个插件, 可以说是史上最全的了 博客 博客地址 博主信息 Android Developers Blog Android官网博客, 在上面可以关注 Android 最新的进展与最权威的博客(需翻墙) stormzhang 博主是上海薄荷科技开发主管, 他的博客分享了他从编程白痴到自学 Android 一路走过的经验, 写了一篇 Android学习之路 帮助了无数人, 里面还有很多好的文章非常适合新手入门, 并且是微信公众号「AndroidDeveloper」的运营者, 可以算是 Android 界最有影响力的公众号之一了, 强烈推荐关注 胡凯 目前就职于腾讯上海从事 Android 开发的工作, 发起 Google Android 官方培训课程中文版翻译, 这课程是学习 Android 应用开发的绝佳资料 Trinea 目前在滴滴负责 Android 客户端技术, 他是开源库项目收集达人, 你想要的开源库上面都有, 并且发起 Android 开源项目源码解析, 在使用开源库的同时也可以知道其中原理, 大家可以去关注一下, 地址 郭霖 博主郭霖是大神, 人人都称”郭神”, 是第一行代码的作者, 博主在 CSDN 上所写的文章都非常值得学习 代码家 90后 Android 大神, 称作库达人, 博主收集了很多 Android 开源库, 博主自己也做了很多开源库, 非常值得学习 light_sky Android 开发工程师, 目前在北京工作. Google big fan, 热爱开源, 热爱分享, 活跃于 GitHub, G+, Twitter, 捕捉Android最新资讯和技术, ViewPagerIndicator 开源项目分析者 张鸿洋 张鴻洋是 CSDN 博客专家, 博主在 CSDN 所发布的每一篇文章都是干货, 都很值得大家去学习 张兴业 张兴业同样也是 CSDN 博客专家, 博主专注移动互联网开发, 关注移动支付业务 hi大头鬼hi hi大头鬼hi 是阿里巴巴集团的一名 Android 工程师, 擅长 Android, RxJava, RxAndroid, ReactNative, Node.js, 大前端, 可谓是全栈工程师, 如果你对 RxJava 技术感兴趣, 不妨到他的博客看看, 他写了一系列有关 RxJava 的介绍 更多 这里面收集了很多国内外开发者的信息, 大家可以去看看 社区 名称 简介 StackOverFlow IT 界的问答社区, 你开发当中所遇到的问题基本上都能在这里能寻找到你想要的答案 SegmentFault SegmentFault 是一个专注于解决编程问题, 提高开发技能的社区 CSDN CSDN 是全球最大中文IT技术社区 稀土掘金 高质量的技术分享社区 谷歌开发者社区(GDG) GDG 是 Google Developer Groups 的缩写, 中文名称是谷歌开发者社区 开源项目学习 项目名称 项目简介 Google I/O 2014 Google I/O Android App 使用了当时最新推出的 Material Design 设计 Google play music 一个跨多个平台音乐播放器 Google Santa Tracker for Android Google 开源的一个儿童教育和娱乐的 App github客户端 开源者 github 团队, 支持项目的 lssues 和 Gists 并集成了新闻 feed 以便及时获取来自组织好友和资料库的更新信息, 还提供了一个用于快速访问你创建,监控以及发布 issue 面板, 可查看并将问题加到收藏夹 Talon-for-Twitter 一个完整版 Twitter 第三方客户端, 属于顶级水平, 而且在源代码 100% 开源, 学习资源让你取之不尽 Anime Taste 开发者是代码家为 AnimeTaste 全球动画精选开发的 Android 客户端, 国内很少见的精彩而且开源的 APP, 获得豌豆荚110期设计奖 EverMemo 开发者是代码家, EverMemo 是一款让你快速记录与分享灵感的随身便签, 极简的界面与卡片式布局, 让你记录与查找便签更有效率 9GAG 开发者是 stormzhang 博主,这个开源项目教你使用 Studio, Gradle 以及一些流行的开源库快速开发一个不错的 Android 客户端 MIUI 便签 MiCode 便签是小米便签的社区开源版, 由 MIUI 团队（ww.miui.com）发起并贡献第一批代码, 遵循 NOTICE 文件所描述的开源协议 贝壳单词 开发者是许晓峰(Drakeet), 获得豌豆荚设计奖, 这个是初期版本, 新版没有开源, 但是在博主的博客当中将一些新版的内容都剥离出来写成了文章,可以去学习一下 Muzei Live Wallpaper 开发者是 Ian Lake , 就职于 Google, 这款是定时更换桌面精美壁纸 App 四次元-新浪微博客户端 一个仿新浪微博客户端 App, 基本都含有新浪微博的功能, 开源团队写了一份 wiki 文档, 可以去学习一下该 App 是如何实现的 知乎专栏 开发者是白瓦力, 项目结构清晰, 代码分包合理, 很棒. 很适合新手去学习如何搭建一个 App 结构, 熟悉开发一个完整 App 的流程 eoe 客户端 eoe 社区Android客户端 oschina 开源中国社区 Android 客户端, 此开源的是 v1 版本, v2 版本将在 2015 年年中开源 v2ex 开发者是杨辉, 这个是 v2ex Android 第三方客户端 Tweet Lanes 功能比较完整的 Twitter 客户端 Financius 一款简单易用个人理财 Android 程序 Coding Coding 类似于 github 一个代码托管平台, 这个是 Coding 的 Android 版客户端 ZXing 二维码扫描工具,市场上许多应用的二维码扫描工具都是从这个修改得到的 photup 编辑机批量上传照片到 facebook 上,代码分包合理,很棒,不过这个项目依赖的开源项目比较多, 比较难编译 todo.txt-android todo.txt 官方 Android 应用, 一个极简的将待办事件记录在 .txt 文件中 扫扫图书 一个让你懂得如何去选择一本书的 APP, 具有扫描搜索查询图书的信息功能 ChaseWhisplyProject 开启摄像头在你所在位置寻找鬼魂, 进行打鬼游戏 AntennaPod AntennaPod 是一个自由, 开源的播客客户端, 支持 Atom 和 RSS Feed 干柴 开发者是冯建, 一个专注收集 android 相关干货(文摘,名博,github等等)资源 App Hacker News 一个查看黑客新闻报道和评论的 App proxydroid ProxyDroid 是一个帮助你在你的 Android 设备上设置代理 (HTTP / SOCKS4 / SOCKS5) AliGesture Android平台手势识别应用, 简单的手势就可以进入预置的应用, 方便快捷 指读 指读顾名思义就是用手指去阅读浩瀚的书海 KJ 音乐 开发者是张涛, 快捷音乐使用到KJFrameForAndroid开发框架, 拥有界面绚丽, 操作简单, 播放手机本地音乐, 在线收听音乐等功能, 还支持: 新浪微博, 百度账号, QQ 账号的一键登录 哎嘛 OSCHINA 第三方客户端, 这个版本界面比官方版本界面好看多了, 使用的是 Material Design, 界面看上去非常清爽舒服 码厩 博客园第三方客户端, 使用到缓存技术, 当你打开一次之后的博客内容, 会自动保存到设备中, 下次打开阅读同一文章时不需要再利用网络加载, 大家如果想为自己 App 搞缓存的, 可以研究一下该 App 是如何实现的喔 cnBeta 第三方阅读器 该 App 是 cnBeta(中文业界资讯站) 第三方阅读客户端, 界面也是使用 Material Design, 还加上一些动画效果, 让人阅读文章起来不会感觉枯燥, 值得去研究学习一下 BlackLight BlackLight是由纸飞机开发团队开发的一款Android上的新浪微博第三方轻量级客户端 Actor Actor(优聆) 是一款即时通讯 App, 解决网络通讯差的情况, 支持离线消息和文件存储, 自动与手机联系人建立联系等等 Plaid 一个遵循 Material Design 的一个设计新闻客户端，里面的一些完全MD的一些特效很棒，同时整个客户端的框架设计也很有参考意义 SimplifyReader 一款基于 Google Material Design 设计开发的 Android 客户端, 包括新闻简读, 图片浏览, 视频爽看, 音乐轻听以及二维码扫描五个子模块, 项目采取的是MVP架构开发 PHPHub-Android PHPHub Android 客户端, 项目架构使用 nucleus 简化 MVP 架构, API 请求返回数据使用 RxJava 进行处理, 客户端使用了独特的二维码扫码登录, 有兴趣的可以去研究一下 Leisure 闲暇(Leisure)是一款集”知乎日报”, “果壳科学人”, “新华网新闻”以及”豆瓣图书”于一体的阅读类 Android 应用, 项目里面有多语言切换、夜间模式以及无图模式, 如果你还不知道这些技术怎么实现, 不妨参考一下这个项目 Meizhi 开发者是许晓峰(Drakeet), 该 app 是数据来自代码家干货网站 gank.io, 有很多开发者都纷纷为这网站做客户端 app, 因为代码家大神开放该网站的 Api, 更重要的是该网站每天除了有干货还有漂亮妹子看呢, 该 App 使用到的技术有 RxJava + Retrofit, 代码结构非常清晰, 值得一看的开源 App. Bingo 开发者是孙福生, Bingo 是一款 IT 阅读学习类的开源软件, 作者收集一些干货学习内容, 你也可以在 App 上分享你的认为干货文章, 该项目使用动态代理 AOP 编程框架, 使开发起来更简洁, 更高效. 里面有一个功能就是多种主题切换, 感兴趣的可以看看怎么实现 Android 开发者杂志周刊( 前五个资料来自 Drakeet 收集整理的, 资料原链接 地址 ) 周刊名 周刊简介 Android Weekly Android Weekly 是由Android 团队的成员和国外知名的 Android 开发者维护, 分享的内容不仅仅只有干货, 而且还有最新的技术分享, 也是Android 开发圈子最早, 最有名的周报 Android 开发技术周报 Android 开发技术周报是由@脉脉不嘚語 维护更新, 截止到现在, 已经发布了28 期, 分享的都是高质量的文章教程, 代码库, 工具, 新闻视频, 设计等 Android 科学院 由 @duguguiyu和豌豆荚一小撮工程师组成, 分享的都是最新的 Android 技术: 虽然更新频率不是很高, 但是质量确是很高的, 值得一看的 开发技术前线 开发技术前线是一个高质量技术文章的聚合网站, 主要分享 Android, iOS, 以及招聘等内容 App 开发日报 App 开发日报主要关注移动应用的开发, 它每天一刊, 分享的内容主要来自微博上知名的开发者推荐的内容, 因此质量基本上是有保证的 Android 开发周报 Android 开发周报是郭亮在连载更新在 Infoq 的周刊, 它不仅分享 Android 的相关新闻, 新工具, 而且还有更加深入的, 所以对于新生老人都很适合 干货集中营 由 代码家 维护更新, 周一到周五每天中午分享, 分享内容有漂亮妹子, Android 干货, iOS 干货, App, 技术以外推荐, 还有休息视频 Android Blog 周刊 AndroidBlog 是由 Jomeslu 收录的, 目前就职于搜狐, 该周刊分享内容主要有一周国内外热门技术博客, 优秀的类库, 以及一些有趣的新闻, 看了前几期分享的内容质量都是很高的, 因此值得推荐给大家 Awesome 系列 awesome android(1) awesome_android(2) awesome_android_UI awesome_android_libraries awesome_java awesome_materialdesign awesome 系列之终极版 android-dynamic-load-awesome 动画系列 animate awesome-animation Material-Animations AndroidViewAnimations Material Design 设计 Material Design 教程 Material Design 教程(中文版) Material Design Android Library (Material Design 开源库, 很多效果可以直接拿来用) 十大Material Design开源项目 素材 常用色彩搭配表 ColorHunt-色彩搭配 在线 Material Design 界面调色板 Material Design设计模板与素材 App Icon 图标 Icon Store Material icons Iconfont 开源库收集 Android Libraries and Resources Android Arsenal (一个专门收集 android 开源库的网站, 网站经常更新) Android 开源项目汇总 (Trinea 大神收集的) Android 开源项目源码分析 (在懂得使用这些开源项目同时, 也应该了解当中的原理) 泡在网上的日子 android-gems(国内外很多开发者都在这里上传他们最新的项目, 还带有 apk 下载) 设计模式 java-design-patterns Android源码设计模式分析项目 Java之美[从菜鸟到高手演变]之设计模式 实践篇 Android 开发最佳实践 Android 开发最佳实践 (来自胡凯总结) Android 最佳实践之 UI 篇 Android 屏幕适配全攻略 给半新人的app开发指南 Android 一些重要知识点解析整理 Android 开发人员应避免的 10 个误区 Java 反射最佳实践 Android 内存优化之 OOM Android 命名规范 Adapter 优化方案的探索 Android-Tips 最全 Android ADB Shell AndroidNote Android 常用工具类 创建安卓 app 的 30 个经验教训 Android 三大图片缓存原理、特性对比 Android 性能优化总结 Android 实用代码片段整合 36 个 Android 开发常用代码片段 收集了大家常用的一些 Android 的模板代码 Android 技术积累: 开发规范 App 架构设计经验谈 关于 Android 开发的 40 条优化建议 如何提高安卓代码的质量和语法 我的 Android 开发实战经验总结 Android Tips 系列 如何自学 Android 国内一线互联网公司内部面试题库 Git 教程新手看完这几份教程基本上知道怎么使用 Git 了 GitHub 团队美女写的一套 Git 使用教程 ProGit 中文版 廖雪峰的 Git 教程 Git 简易指南 文档 Android 官方 API 文档(网站需要翻墙，不翻墙可以下载离线文件) Android 官方培训课程中文版(由胡凯发起对 Google Android 官方培训课程翻译的中文版) 其它资料收集 10 个很棒的学习 Android 开发的网站 Android 开发, 你应该知道的学习资源 AndroidCat 安卓书签网 每个 Android 开发者都应该了解的资源列表 Android 开发者网址导航 Android 开发收藏夹 TimLiu-Android(TimLiu 总结的 Android 开源项目及库) AndroidTips 知乎上的讨论 有哪些 Android 大牛的 blog 值得推荐? GitHub 上都有哪些值得关注学习的 Android项目? GitHub 上有哪些适合新人围观的 Android 项目? 2015 年移动设备界面设计有哪些趋势? Android开发中, 有哪些让你觉得相见恨晚的方法,类或接口? Android Studio有哪些非常好用的插件? Android 开发有哪些新技术出现? 有哪些优秀的 Android 应用开源项目, 特效, 设计资料推荐? 有没有适合 Android 开发初学者的 App 源码推荐? Android有什么好的技术点适合进行技术分享? Android Studio有什么奇技淫巧? Android 开发: 开始一个项目前, 做好哪些准备可以事半功倍? 贡献者点击该链接查看该项目所有贡献者 License以上内容采用 CC BY-NC-SA 3.0 进行许可, 转载请注明出处, 版权归本人及所有贡献者所有 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"String、StringBuffer、StringBuilder的区别","date":"2017-07-06T15:45:01.000Z","path":"2017/07/06/String、StringBuffer、StringBuilder的区别.html","text":"一、区别String ：字符串常量StringBuffer ：字符串变量StringBuilder ：字符串变量 二、速度StringBuilder &gt; StringBuffer &gt; String 分析原因： String类是不可变类，任何对String的改变都 会引发新的String对象的生成； String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String。 而StringBuffer与StringBuilder就不一样了，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，这样就不会像String一样创建一些而外的对象进行操作了，当然速度就快了。 又因为StringBuilder是线程不安全的，StringBuffer是线程安全的，所以StringBuilder比StringBuffer要快。 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"}]},{"title":"Kotlin","date":"2017-06-23T12:13:26.000Z","path":"2017/06/23/Kotlin.html","text":"项目地址：https://github.com/JetBrains/kotlin 简介：Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。它主要是由俄罗斯圣彼得堡的JetBrains开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。[2]2012年1月，著名期刊《Dr. Dobb’s Journal（英语：Dr. Dobb’s Journal）》中Kotlin被认定为该月的最佳语言。[3]虽然与Java语法并不兼容，但Kotlin被设计成可以和Java代码相互运作，并可以重复使用如Java集合框架等的现有Java类库。 更多：The Kotlin Programming Language http://kotlinlang.org/ Kotlin Programming LanguageWelcome to Kotlin! Some handy links: Kotlin Site Getting Started Guide Try Kotlin Kotlin Standard Library Issue Tracker Forum Kotlin Blog Follow Kotlin on Twitter Public Slack channel TeamCity CI build Editing Kotlin Kotlin IntelliJ IDEA Plugin Kotlin Eclipse Plugin Kotlin TextMate Bundle Build environment requirementsIn order to build Kotlin distribution you need to have: Apache Ant 1.9.4 and higher JDK 1.6, 1.7 and 1.8 Setup environment variables as following: JAVA_HOME=&quot;path to JDK 1.8&quot; JDK_16=&quot;path to JDK 1.6&quot; JDK_17=&quot;path to JDK 1.7&quot; JDK_18=&quot;path to JDK 1.8&quot; BuildingTo build this project, first time you try to build you need to run this: ant -f update_dependencies.xml which will setup the dependencies on intellij-core is a part of command line compiler and contains only necessary APIs. idea-full is a full blown IntelliJ IDEA Community Edition to be used in the plugin module. Then, you need to run ant -f build.xml which will build the binaries of the compiler and put them into the dist directory. You may need to increase the heap size for Ant usingANT_OPTS. OPTIONAL: Maven artifact distribution is built separately, go into libraries directory after building the compiler and run: ./gradlew build install mvn install Note: on Windows type gradlew without the leading ./ Refer to libraries/ReadMe.md for details. Working with the project in IntelliJ IDEAThe root kotlin project already has an IntelliJ IDEA project, you can just open it in IntelliJ IDEA. You may need to set the Project SDK (File -&gt; Project Structure -&gt; Project).You may also need to add tools.jar to your SDK: File -&gt; Project Structure -&gt; SDKs -&gt; &lt;Your JDK&gt; -&gt; Classpath then choose the tools.jar in the JDK’s lib directory. If you are not dealing with Android, you may need to disable the Android Plugin in order to compile the project. Installing the latest Kotlin pluginSince Kotlin project contains code written in Kotlin itself, you will also need a Kotlin plugin to build the project in IntelliJ IDEA. You probably want to have locally the same version of plugin that build server is using for building.As this version is constantly moving, the best way to always be updated is to let IntelliJ IDEA notify you when it is time to renew your plugin. To keep the plugin version in sync with the rest of the team and our Continuous Integration serveryou should setup IDEA to update the plugin directly from the build server. Open: Preferences -&gt; Plugins -&gt; Browse Repositories -&gt; Manage Repositories... and add the following URL to your repositories: https://teamcity.jetbrains.com/guestAuth/repository/download/bt345/bootstrap.tcbuildtag/updatePlugins.xml Then update the list of plugins in “Browse Repositories”, you’ll see two versions of Kotlin there, install the one with the higher version number. If you want to keep an IntelliJ IDEA installation with that bleeding edge Kotlin plugin for working Kotlin project sources only separate to your default IntelliJ IDEA installation with the stable Kotlinplugin see this document, which describes how to have multiple IntelliJ IDEA installations using different configurations and plugin directories. Compiling and runningFrom this root project there are Run/Debug Configurations for running IDEA or the Compiler Tests for example; so if you want to try out the latest and greatest IDEA plugin VCS -&gt; Git -&gt; Pull Run IntelliJ IDEA a child IntelliJ IDEA with the Kotlin plugin will then startup you can now open the kotlin libraries project to then work with the various kotlin libraries etc. ContributingWe love contributions! There’s lots to do on Kotlin and on thestandard library) so why not chat with usabout what you’re interested in doing? Please join the #kontributors channel in our Slack chatand let us know about your plans. If you want to find some issues to start off with, try this query which should find all Kotlin issues that marked as “up-for-grabs”. Currently only committers can assign issues to themselves so just add a comment if you’re starting work on it. A nice gentle way to contribute would be to review the standard library docsand find classes or functions which are not documented very well and submit a patch. In particular it’d be great if all functions included a nice example of how to use it such as for thehashMapOf() function.This is implemented using the @samplemacro to include code from a test function. The benefits of this approach are twofold; First, the API’s documentation is improved via beneficial examples that help new users and second, the code coverage is increased. Also the JavaScript translation could really use your help. See the JavaScript contribution section for more details. If you want to work on the compilerThe Kotlin compiler is written in Java and Kotlin (we gradually migrate more and more of it to pure Kotlin). So the easiest way to work on the compiler or IntelliJ IDEA plugin is download a recent IntelliJ IDEA, Community edition is enough install the Kotlin plugin open the root kotlin project in IDEA (opening the kotlin directory) You can now run the various Run/Debug Configurations such as IDEA All Compiler Tests All IDEA Plugin Tests If you want to work on the Kotlin libraries download a recent IntelliJ IDEA, Community edition is enough install the Kotlin plugin open the kotlin libraries project Then build via cd libraries ./gradlew build install mvn install Note: on Windows type gradlew without the leading ./ Some of the code in the standard library is created by generating code from templates. See the README in the stdlib section for how run the code generator. The existing templates can be used as examples for creating new ones. Submitting patchesThe best way to submit a patch is to fork the project on github then send us apull request via github. If you create your own fork, it might help to enable rebase by defaultwhen you pull by executing1git config --global pull.rebase true This will avoid your local repo having too many merge commitswhich will help keep your pull request simple and easy to apply. Commit commentsIf you include in your comment this text (where KT-1234 is the Issue ID in the Issue Tracker, the issue will get automatically marked as fixed. #KT-1234 Fixed 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1.2 is out","date":"2017-04-25T13:19:00.000Z","path":"2017/04/25/Kotlin 1.1.2 is out.html","text":"我们很高兴宣布Kotlin 1.1.2正式发布了，这也是Kotlin 1.1的第二次 Bug 修复和工具更新。此次更新不仅提升了编译器和 IntelliJ IDEA 插件的性能，同时也在工具中增加了新的特性，当然还有各方面的问题修复。 此外，Kotlin 1.1.2也提升了与Android Gradle插件版本2.4.0-alpha的兼容性。本次发布版本的所有更新可在更新日志中查看。在这里要感谢所有外部的贡献者，他们提交的pull request也包含于该版本中：Yoshinori Isogai，Jonathan Leitschuh和Kirill Rakhman 。感谢所有尝试EAP构建并向我们发送反馈意见的人！ 迁移说明Kotlin编译器现在也需要基于JDK 8运行。但您应该不需要在意这一点改变，因为大多数其他Java开发工具（比如Gradle和Android工具）也需要JDK 8，因此您肯定已经安装了JDK 8。对于由编译器生成的代码，仍然默认兼容Java 1.6，而且我们也没有计划要放弃对生成的Java 1.6兼容性字节码的支持。 内部类当中不能再声明 object，因为这个 object 将能够访问外部类的实例，我们知道 object 始终是一个单例，因此这在理论上是行不通的。同样的，内部密封类也是不被允许的。然而这只是临时方案，在我们添加了在其外部类而非内部类中声明内部密封类的子类的可能性时，将会删除该限制。(KT-16232，KT-16233） 现在使用一个名称完全由下划线字符组成的声明时将必须使用反引号。(KT-16264） Maven增量编译从Kotlin 1.1.2开始，以前用于IntelliJ IDEA和Gradle构建的增量编译现在也支持Maven。启用该功能时，需要使用-D命令行参数或proterties标记设置kotlin.compiler.incremental属性为true： 123&lt;properties&gt; &lt;kotlin.compiler.incremental&gt;true&lt;/kotlin.compiler.incremental&gt;&lt;/properties&gt; Maven注解处理现在可以从Maven构建中调用Kotlin的注解处理工具kapt了，只需要在compile前，从kotlin-maven-plugin中添加kapt的执行目标： 1234567891011121314151617181920&lt;execution&gt; &lt;id&gt;kapt&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;kapt&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt; &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;annotationProcessorPaths&gt; &lt;!-- Specify your annotation processors here. --&gt; &lt;annotationProcessorPath&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;/annotationProcessorPath&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/execution&gt; 在这里查看具有Java-Kotlin代码支持和测试的POM文件完整示例。 请注意，IntelliJ IDEA自己的构建系统仍然不支持kapt。当您要重新运行注解处理时，需要从“Maven Projects”工具栏中启动构建。 内联方法重构我们终于在Kotlin代码中实现了Inline方法（Function）的支持。 其他IDE改进在1.1.x时间范围内，我们很大一部分的工作是致力于提高IntelliJ IDEA插件的性能。在此次发布的1.1.2版本中，我们对几项主要性能进行了改进，主要涉及输入响应，同时我们也已经为后续1.1.3版本进行了额外的重大改进。 除此之外，我们还在此版本中进行了大量新的检测，快速解决方案和小型IDE功能。特别值得一提的是，在编辑器中支持折叠Android String资源引用，以及新的用于处理Android API版本问题的问题解决方案。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们来吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 Event Report","date":"2017-04-06T15:21:00.000Z","path":"2017/04/06/Kotlin 1.1 Event Report.html","text":"Kotlin 1.1 版本发布在社区反响很好。为了演示 Kotlin 1.1 的新功能，JetBrains 提供了一个在线活动。所有感兴趣的人都可以观看 Andrey Breslav 的在线直播演示，并在 Q&amp;A 环节获得他们关心的问题的答案。这激发了许多当地社区组织见面会：超过 30 个用户组在 21 个国家举办了线下活动。你可以在这里找到完整的活动列表 Kotlin社区网页 。活动当天有 3000 多人参加了线上直播。演示和 Q&amp;A 视频可以在 YouTube 上查看： Kotlin 1.1 活动反馈如果你看了直播，我们想知道你的想法！请 填写此表格 分享您的反馈。它只需要大约7-10分钟。您的投入对于帮助我们改进未来的 Kotlin 活动非常重要。 Kotlin 未来特性调查 我们还向所有社区提供了对 Kotlin 未来的影响。活动组织者收到了调查表，活动参与者可以在线下对最期望的功能发表看法。调查得到很多关注，我们现在已经把它放在网上，以听取更广泛的社区建议。现在你可以在线给 Kotlin 的未来提供你的建议 ！请注意，你在 v1.2 中有很大可能看不到这些功能，但我们会在确定工作优先级时考虑您的意见。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 也适用于 Android 开发者","date":"2017-04-05T08:13:00.000Z","path":"2017/04/05/Kotlin 1.1 is also for Android Developers.html","text":"Kotlin 1.1的发布令人们感到非常兴奋。此版本包含的新功能对 Java 开发者非常有用，并将 引领 JVM 走向一个充满发展潜力的新世界。 但有些新功能，如 coroutine 和 type alias（下文有几个例子）对于 Android 开发者来说就像科幻小说。 我们仍然停留在几乎没有什么改进的古老 Java 6 中，迫使我们以其他平台已经被被遗忘的方式进行开发。 所以一个理所当然的问题是：Kotlin 团队能够保持与 Java 6 的兼容性，同时保留所有这些新功能吗？答案是：当然！ 所有新特性仍然兼容 Java 6 为 Android 开发者所用。 今天我想向您展示其中的一部分，看看它们是如何使你更容易的开发 Android 应用程式。 type alias 使你的 listener 更易读当然 type alias 有很多不同的应用场景，不过我首先想到的是使用 lambda 作为 listener 的类型时会使代码更易读。 如果没接触过 type alias 的话，可以简单的理解为给复杂的类型名起个别名，使其更为可读。 例如你有个接收 listener 的 RecyclerViewAdapter。RecyclerView 没有 ListView 那样 标准的方式来处理条目点击事件，必须由开发者自己实现。 假如我们希望有一个可以访问 view 的 listener，那 adapter 可能如下所示： 123class MyAdapter(val items: List&lt;Item&gt;, val listener: (View) -&gt; Unit) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123; ...&#125; 而你的 ViewHolder 可能需要接收该 listener，才能将其分配给 view： 12345class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; fun bind(item: Item, listener: (View) -&gt; Unit) &#123; itemView.setOnClickListener(listener) &#125;&#125; 这不是一个复杂的例子，但是正如你所看到的我们需要重复定义这个 lambda ，会导致这段代码不太好阅读。 但是现在我们可以创建一个代表点击 listener 的 type alias：typealias ClickListener = (View) -&gt; Unit然后在需要的每一个地方使用它：class MyAdapter(val items: List&lt;Item&gt;, val listener: ClickListener)或者fun bind(item: Item, listener: ClickListener) { ... } data class 更强大了data class 可以为我们避免大量的样板代码，但是它不能继承其它类所以某些情况下不可用。 Kotlin 1.1 取消了这个限制，例如 data class 可以定义为 sealed class 的子类了： 12345sealed class UiOp &#123; object Show : UiOp() object Hide : UiOp() data class Translate(val axis: Axis, val amount: Int): UiOp()&#125; 同时 sealed class 可以在父类之外定义，就像这样的： 1234sealed class UiOpobject Show : UiOp()object Hide : UiOp()data class Translate(val axis: Axis, val amount: Int) : UiOp() 在 lambda 中使用 destructuring从 Kotlin 最早的版本开始 data class 就能够使用 destructuring declarations 了，因为它会自动生成 componentX() 方法，借助这些方法可以将 data class 对象拆分成若干变量，如下所示： 123data class Item(val text: String, val url: String) val (text, url) = item 可是在 Kotlin 1.1 之前你并不能在 lambda 上这么做。不过等待结束了！现在可以这么写： 1234fun bind(item: Item) = item.let &#123; (text, url) -&gt; textView.text = text imageView.loadUrl(url)&#125; 这个改进十分适用于操作 Pair 和 Map 等类型的对象 适用与局部变量的 delegated propertydelegated property 已被证明是非常有用的，可以为类中的 property 提供附加的能力。 例如最有用的一个是 lazy property，它会推迟赋值操作，直到变量第一次使用。 但其实 lazy 对于局部变量来说也是十分有用的，而之前 Kotlin 缺乏这个功能。 现在通过 delegated property，我们可以做到： 12345678910fun testLocalDelegation() &#123; val database by lazy &#123; createDatabase() &#125; val cache by lazy &#123; createMemoryCache() &#125; if (mustUseDatabase()) &#123; database.use &#123; ... &#125; &#125; else &#123; cache.use &#123; ... &#125; &#125;&#125; 虽然这个例子可以在没有使用 lazy 的情况下解决，但它有助于理解这个概念。 有一些占用比较多的对象不一定会被使用，可以通过使用 lazy 延迟实例化，直到我们初次使用它。 这时大括号内的代码会被执行，并且将结果缓存下来以备稍后再次使用。 再也不用在 lambda 中定义未使用的变量了在 lambda 中定义了变量但最终没使用情况很常见。 这是因为在 Kotlin 1.0 中没有办法丢弃 lambda 中未使用的参数。 例如使用 delegated property 更新 RecyclerView adapter，我使用了以下代码： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; prop, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; prop 变量从未被使用过，这时我们就可以使用下划线来替换它： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; _, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; 还有种更糟的情况，如果 lambda 有多个参数，即使你一个也不用还是需要写上所有参数。现在我们可以忽略它们了： 1234var items: List&lt;Item&gt; by Delegates.observable(emptyList()) &#123; _, _, _ -&gt; notifyDataSetChanged()&#125; 不仅可以定义较少的变量，而且代码还变得更易读了，那些有用的变量一眼就能看到。 Coroutinecoroutine 是 Kotlin 1.1 中最令人兴奋的特性。尽管在此版本中带着“实验性”的标签，但 coroutine 功能齐全，你完全可以开始在项目中使用它们。 coroutine 能让你以同步的方式编写异步代码，允许你在某些时候暂停执行并等待结果，同时写下顺序相连代码。 您可能已经知道在 Kotlin 中 coroutine 并不是指一个库或者具体的实现，而是一种能力，通过它能够创建具有 coroutine 特性的库。 因此尽管某些代码看起来可能相似，但重要的是要知道创建这些辅助线程并返回主线程的“齿轮”是什么，这在 Android 中非常重要。 幸运的是 Kotlin 社区的动作很快，已经有几个库引入了 coroutine 方便我们在 Android 上使用。 首先来看看 Jetbrains 官方提供的： kotlinx-coroutines-android 提供了在 Android 上使用 coroutine 的实现。 Anko 在其最新的 beta 版中改写了部分框架引入 coroutine。 还有许多其他第三方库实现了自己的 coroutine 版本： AsyncAwait-Android by Niek Haarman Async / Await by Metalab 如果你在寻找 Retrofit 的 coroutine 版本，那么可以试试 kotlin-coroutines-retrofit by Andrey Mischenko 建议你们使用的时候看看它们是如何实现的，这就是开源的好处。 其它对 Android 开发者有用的东西这个版本还有更多的改进，但是我更想强调一些侧重于 Android 开发的内容。 首先，现在可以通过使用以下配置来启用 Jack 编译器的支持了：jackOptions {true}。虽然 Google 已经宣布放弃 Jack 工具链了，但是如果你对 Java 8 有需求那么会有一点用处，然后等到 Android Studio 2.4 的正式版发布就可以彻底弃用 Jack 了。（从 Android Studio 2.4 Preview 4 版本开始支持所有 Java 7 语言特性，部分 Java 8 语言特性） 另外介绍一个小技巧，就是用 @JvmOverloads 来实现自定义 View 的构造函数，在 Kotlin 中借助参数默认值一个构造函数就能满足自定义 View 的多种构造需求（嗯，很长的一个构造函数） 12345class CustomView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; ...&#125; 结论Kotlin 1.1 带来了大量的新功能，不禁让人产生为什么还要使用 Java 的想法。 Kotlin 为 Android 开发者带来的好处是毋庸置疑的，从现在开始使用 Kotlin 编写你的 Android 应用吧。 如果你想从头开始学习使用 Kotlin 开发 Android 应用，那么你应该会对 Kotlin for Android Developers 这本书感兴趣。","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/itgoyo/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 Event in Your City","date":"2017-03-21T13:51:00.000Z","path":"2017/03/21/Kotlin 1.1 Event in Your City.html","text":"我们将于2017年3月23日进行Kotlin 1.1活动 线上直播。您可以通过JetBrains TV观看Andrey Breslav的演讲，了解Kotlin 1.1的关键特性，包括协程(coroutines)，JavaScript后端等。您也可以使用#kotlinqa在twitter上提出问题，我们将在3月23日直播中的Q&amp;A环节进行解答。为适应不同的时区我们共准备了2个直播流，详情可在博客日志中参阅详细计划与指导 。从下图中了解您所在的城市是否有Kotlin 1.1活动，如果您所在的城市尚未出现在下图中，请单独加入直播。 请注意，美国的直播时间已经更改为PDT(太平洋夏季时间)时间。第一个直播流将于上午9点开始，第二个上午11点开始。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.0.7 is out","date":"2017-03-15T14:21:00.000Z","path":"2017/03/15/Kotlin 1.0.7 is out.html","text":"我们很高兴地宣布Kotlin 1.0.x系列的最后一个更新，Kotlin 1.0.7已经发布了。需要重点关注的是该补丁针对Gradle和annotation processing进行修复，此前无法升级到1.1版本的用户现在可以正常使用了。完整的修复列表可以在更新日志查看。要在Maven或Gradle版本中更新版本，只需在构建脚本中更改Kotlin版本号。命令行编译器会在Github发行页面中下载。在IntelliJ IDEA和Android Studio中，如果您使用Kotlin 1.0.7构建项目，我们建议使用1.1版本的插件，并将语言版本切换为1.0。如果您确实想要安装1.0.7版本的插件，可以在Kotlin插件页面下载相应版本，并通过IDE的“从磁盘安装插件…”按钮进行安装。一如既往，如果您在新版本中遇到任何问题，欢迎您在讨论组或者Slack（在这里获得邀请）里寻求帮助，或在这里提交issue。让我们来享受Kotlin吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1.1 is out","date":"2017-03-14T12:29:00.000Z","path":"2017/03/14/Kotlin 1.1.1 is out.html","text":"今天我们发布了针对 Kotlin 1.1 的第一个bug修复更新。此更新的重点是解决导致错误代码生成的回归；我们希望尽可能快地修复此问题。详细内容请查看更新日志 。重点更新如下： 默认情况下，已启用Gradle增量编译。如果需要，您仍然可以按照文档描述禁用此功能。 Kotlin插件现已可以通过Gradle插件依赖添加使用。详情可参阅相关文档。 禁用使用带有接收器的函数类型作为JavaScript外部声明的参数类型。在此之前，传递给这些参数的lambdas没有被正确的参数调用，并且在这个问题上没有简单的解决方法，所以现在我们决定禁用这个功能。 更新后的Kotlin Eclipse 和 NetBeans 插件将支持Kotlin 1.1.1，所以您可以尽情享受Kotlin新版本的优点而无需关注IDE。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们开始吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 Event","date":"2017-03-06T09:43:00.000Z","path":"2017/03/06/Kotlin 1.1 Event.html","text":"Kotlin 1.1除了为您的项目带来新特性之外，还是您与当地社区进行线下交流学习、了解Kotlin的未来与发展的绝好机会。您可以组织社区的小伙伴们，一起参与Jetbrains团队在3月23日举办的Kotlin直播活动。为了适应不同时区，我们准备了两个直播流，分别是欧洲中部时间[CET]下午5点/7点(太平洋夏季时间[PDT]上午9点/11点)。 告诉我们，我们将在博客上公布。 Kotlin 1.1活动时间： CET时间下午5点/7点(PDT时间上午9点/11点) - Andrey Breslav演讲(Youtube上直播30分钟)，链接将稍候放出。 CET时间下午5点30分/7点30分(PDT时间上午9点30分/11点30分) - 休息30分钟，期间可以自由讨论关于在Kotlin未来版本中您最希望加入的功能或特性，并在Twitter上分享和评论。 CET时间下午6点/8点(PDT时间上午10点/12点) - 与Kotlin团队的互动问答环节(45分钟，直播); 欢迎各位参与讨论与发言。 互动问答环节 从3月21日开始，至3月23日互动环节结束期间，您可以在Twitter上使用#kotlinQA标签向我们提出任何您想要问的问题； Kotlin团队将对问题进行分类; 团队将在Q＆A环节现场回答问题; 如果在会议期间有问题没有答复，我们仍将通过Twitter进行回复 优先回答提问频率最高的问题 Future Features kit本次调查的目的是收集社区用户对语言特征的偏好和需求。您可以提出在Kotlin后续版本中最希望看到的特征或功能；不过这些内容并不保证能在1.2版本中发布，但我们会在确定工作优先级时考虑您的意见。 Kotlin Future Feature Kit包含20张写有功能名称和描述的卡片以及用于投票的贴纸; 将功能卡片粘贴到白板（或墙壁）上; 每位参加者可获得3张（3张）贴纸，可以在功能中自由分配：最多为三种不同的功能进行投票，或者对某一功能投出两票甚至三票; 参加者可以通过阅读卡片的说明了解功能，然后按上所述规则进行投票; 将结果进行拍照; 使用#kotlinevent标签在Twitter上发布 在这里提交你的答案吧","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"Kotlin 1.1","date":"2017-03-04T00:46:34.000Z","path":"2017/03/04/Kotlin 1.1.html","text":"上周一的文章里面提到 Kotlin 1.1 rc了，还没正式发布，我在周三的时候把文章转到掘金以后，好多小伙伴告诉我，1.1 已经发布了~ tips: 本文有较多外链，公众号阅读时无法跳转，如有需要，请大家点击”阅读原文”。 1、更新要点1.1 Coroutine1.1 最大的更新一定必须毫无疑问的要数 Coroutine 了，尽管在正式发版之前，Kotlin Team 突然虚了，决定把这个特性定为 Experimental，不过这似乎并没有改变什么。不就是改个包名么！！ 早在春节放假那几天，我就在公众号连续两周发文介绍 Coroutine，本来还计划有第三篇的，不过开工以后个项目有点儿累，每天翻 Android 系统 C++ 层的代码翻到吐，也没精力去写第三篇文章，真是抱歉，如果大家有兴趣，可以参考前两篇： 深入理解 Kotlin Coroutine (一) 深入理解 Kotlin Coroutine (二） 其中，第一篇文章写于 experimental 之前，不过大家只要在包名当中加上 experimental 就没问题了。 Kotlin 的 Coroutine 实现主要分为两个层面，第一个层面就是标准库以及语言特性的支持，这里面主要包括最基本的 suspend 关键字以及诸如 startCoroutine 这样的方法扩展，上述第一篇文章对此做了详细的介绍。第二层面则主要是基于前面的基础封装的库，目前主要是 kotlinx.coroutine ，其中封装了 runBlock、launch 这样方便的操作 Coroutine 的 api，这在第二篇文章做了详细地介绍。所以大家在了解 Coroutine 的时候，可以从这两个角度来入手，以免没有头绪。 我们再来简单说说 Coroutine 的运行机制。Coroutine 是用来解决并发问题的，它甚至有个中文名叫“协程”，它看上去跟线程似乎是并发问题的两种独立的解决方案，其实不然。要并发的执行任务，从根本上说，就是要解决 Cpu 的调度问题，Cpu 究竟是如何调度，取决于操作系统，我们在应用程序编写的过程中用到的 Thread 也好，Coroutine 也好，本质上也是对操作系统并发 api 的封装。知道了这一点，我们再来想想 Thread 是如何做到两个线程并发执行的呢？Java 虚拟机的实现主要采用了对内核线程映射的方式，换句话说，我们通常用到的 Thread 的真正直接调度者可以理解为是操作系统本身。那我们在 Kotlin 当中支持 Coroutine 是不是也要把每一个 Coroutine 映射到内核呢？显然不能，不然那跟 Thread 还有啥区别呢？再者，Coroutine 的核心在 Co 上，即各个 Coroutine 是协作运行的，有一种“你唱罢来我登场”的感觉，就是说，Coroutine 的调度权是要掌握在程序自己手中的。于是，如果你去了解 kotlinx.coroutine 的实现，你就会发现 CommonPool 这么个东西，它不是别的，它的背后正是线程池。 线程是轻量级进程，而协程则是轻量级线程。 Coroutine 的出现让 Kotlin 如虎添翼，如果你之前在写 Go，Lua，python，或者 C#，这回 Java 虚拟机家族可不会让你失望了。自从有了协程，你也可以写出这样的代码： 12345678910111213141516val fibonacci = buildSequence &#123; yield(1) // first Fibonacci number var cur = 1 var next = 1 while (true) &#123; yield(next) // next Fibonacci number val tmp = cur + next cur = next next = tmp &#125; &#125; ... for (i in fibonacci)&#123; println(i) if(i &gt; 100) break //大于100就停止循环 &#125; 序列生成器，记得我刚学 python 那会儿看到这样的语法，简直惊呆了。 123val imageA = loadImage(urlA) val imageB = loadImage(urlB) onImageGet(imageA, imageB) 这样的代码也是没有压力的，看上去就如同步代码一般，殊不知人家做的可是异步的事情呐。 协程的出现，让我们可以用看似同步的代码做着异步的事情。 这篇文章我们主要说说 1.1 的发版，Coroutine 的更多内容，建议大家直接点击前面的链接去读我的另外两篇文章~ 1.2 JavaScript 支持真是媳妇儿终于熬成婆，Js 终于被正式支持了。看官方的意思，他们已经用这一特性做了不少尝试，从 Kotlin 从头到尾写一个站点，似乎毫无压力，尽管类似反射这一的特性还没有支持，不过面包会有的嘛。 从我个人的角度来说，也可能我对前端了解太少吧，我觉得应用在前端比起移动端、服务端来说，Kotlin 的前景相对不明朗。我用 JavaScript 用得好好的，为啥要切换 Kotlin 呢？动态特性玩起来挺爽的，虽然回调写多了容易蛋疼，但这也不是不可以规避的。关于 Kotlin 开发前端这个问题，我需要多了解一下前端开发者的看法，相比他们是否愿意接触 Kotlin，我更关心有几个做前端的人知道这门语言。不瞒各位说，前几天跟一个支付宝客户端的大哥聊了一会儿，他问我这个 k o t 什么的，是干啥的。。。我当时在想，看来阿里人对 Kotlin 还不是很熟悉啊。 Whatever，Kotlin 现在都可以支持 node.js 了，还有什么不可能的呢？作为吃瓜群众，且让我观望一阵子。 1.3 中文支持你放心，这一段内容你绝对在其他人那里看不到，因为没人会这么蛋疼。我前几天为了做一个案例用中文写了段代码，想着 Java 支持中文标识符，Kotlin 应该也问题不大。没曾想，写的时候一点儿问题的没，可编译的时候却直接狗带了。 123456789101112package 中国.北京.回龙观 class G6出口&#123; fun 下高速()&#123; println(\"前方堵死, 请开启飞行模式 :)\") &#125;&#125; fun main(args: Array&lt;String&gt;) &#123; val 回龙观出口 = G6出口() 回龙观出口.下高速()&#125; 注意，包名、代码文件名都是中文的，如果用 1.0.6 版编译，结果就是万里江山一片红哇。 1234567Error:Kotlin: [Internal Error] java.io.FileNotFoundException: /Users/benny/temp/testKotlin/out/production/testKotlin/??/??/???/G6??.class (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at kotlin.io.FilesKt__FileReadWriteKt.readBytes(FileReadWrite.kt:52) at org.jetbrains.kotlin.incremental.LocalFileKotlinClass ... 注意到，汉字都变成了 ??，瞧瞧编译器那小眼神，真是看得我都醉了。 如果我们用 1.1 的编译器来编译这段代码，结果就可以正常输出： 1前方堵死, 请开启飞行模式。 1.4 其他特性1.1 还新增了不少特性，我在之前的一篇文章就做过介绍：喜大普奔！Kotlin 1.1 Beta 降临~ tpyealias 绑定调用者的函数引用 data class 可以继承其他类 sealed class 子类定义的位置放宽 _ 作为占位，替代不需要的变量 provideDelegate 2、Kotlin 元年2016 年是 Kotlin “元年（First year of Kotlin）”，官网给出了这样一幅图来展示它一年来的成绩： Github 上面的代码量都破千万了，使用 Kotlin 的公司也逐渐增多，除了 JetBrains 自己以外，我觉得在 Java 界比较有分量的就是 Square 了，如果 Google 能够稍微提一句 Kotlin ，显然这个故事就会有另外一个令人兴奋的版本——好啦，不要 yy 啦。 据说，比较著名的主要有Amazon Web Services, Pinterest, Coursera, Netflix, Uber, Square, Trello, Basecamp 这些公司将 Kotlin 投入了生产实践当中。国内资料较少，估计接触的人也不是很多，像百度、腾讯、阿里巴巴、滴滴、新美大、小米、京东这样的公司可能还没有太多的动力去将 Kotlin 应用到开发中，就算开始尝试，也多是在 Android 开发上面试水；而敢于尝试 Kotlin 的，更多是没有什么历史包袱且富于创新和挑战精神的创业团队，对于他们而言 Kotlin 为开发带来的效率是非常诱人的。 说到这里，有两个令人兴奋的消息需要同步给大家： Gradle 开始尝试用 Kotlin 作为其脚本语言，目前已经发到了 0.4.0。这个真的可以有，groovy 虽然是一门很灵活的语言，不过写配置的时候如果没有 IDE 的提示，实在是太痛苦了。大家有兴趣也可以关注一下这个项目：gradle-script-kotlin Spring 5.0 加入 Kotlin 支持，Spring 的地位可想而知，Spring 为 Kotlin 站台，这分量还是很重的。 不知道 2017 年会发生什么，且让我们准备好爆米花饮料，拭目以待吧。 关于 Kotlin 的资料，英文版的图书已经出版了几本，主要有： Kotlin in Action：这部书已经有了纸质版，是官方自己人写的，算是一本比较权威的参考书了。 Kotlin for Android Developers：这本书也算是老资历了，稍微看几眼你就会为 Kotlin 有趣的特性所吸引。另外，它还有一个中文的翻译版本 Modern Web Development with Kotlin：这本书我没有读过，如果你需要用 Kotlin 开发 web 应用，它应该会给予你一些帮助。 Programming Kotlin：这本书涉及内容非常全面，内容也算是言简意赅，快速入门 Kotlin 可以选择它。 除了图书以外， Kotlin 的首席布道师 Hadi Hariri 已经在 O’Reilly 上面发布了两套视频教程： Introduction to Kotlin Programming Advanced Kotlin Programming 里面有免费的几段，且不说内容怎么样，反正考验大家英语听力的时候到了，嗯，老爷子讲得还是很清楚的。 国内的资料，很少。除了有个别小伙伴写的一些博客之外，较为系统的学习资料几乎没有。也难怪大家都不知道它呢。也正是为了弥补这一空白，我在 16 年 10 月的时候开始每周 10 分钟的节奏连续录了 15 期视频，如果你有 Java 基础，那么看这些视频基本上可以让你知道 Kotlin 是怎么一回事了。 Kotlin 中文视频教程 另外，如果你想要对 Kotlin 持续了解，建议你关注微信公众号 Kotlin，每周一推送的 Kotlin 的相关文章，基本上会覆盖了 Kotlin 的各种最新动态。也欢迎大家跟我交流开发中遇到的问题~ 3、Kotlin 时代1.1 的重要的更新其实就 Coroutine 以及 JavaScript 支持，毕竟 Kotlin 对 Java 的兼容支持已经做得非常不错了（别老提 apt 的事儿，1.0.4 之后的 kapt 不就基本上很好用了么）。别人问我，Kotlin 到底是写啥的，这个问题我通常说很官方的说，Kotlin 是一门运行在 Java虚拟机、Android、浏览器上的静态语言，可是，Kotlin Team 的节奏已经让这句话显得要过时了。他们用短短几年时间搞出这么个全栈的语言，各方面特性都还很棒，然而他们并不能感到满足，他们已经开始走 C++ 的路线，也许 Kotlin Native 要不了多久就会出现了。 第一次听到这消息的时候，我瞬间就凌乱了，那感觉就好像王者荣耀里面队友选了大乔一样，秒回泉水加满血，秒回战场收人头啊。 前不久，我很荣幸地跟一位创业公司 CEO 坐下来聊理想，他问我的第一句话就是：你觉得 Kotlin 是未来么？我当时就蒙了，不得不说，他对 Kotlin 的期待跟 Kotlin Team 如出一辙呀。我当时实在不知道该怎么回答他，回来仔细想了想，答案其实也是有的。 十几年前，东家缺钱，急需投资，投资人坐下来“拷问”小马哥：“这个东西（指当时的 OICQ）怎么赚钱？” 小马哥说自己只知道这个东西大家喜欢，但不知道向谁收钱。对于 Kotlin 来说，我只知道它好用，尽管大家都还看不太懂，不过它的时代正在悄悄的到来。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 发布啦！JavaScript，Coroutine 还有更多你想要的","date":"2017-03-01T09:12:00.000Z","path":"2017/03/01/Kotlin 1.1 Released with JavaScript Support, Coroutines and more.html","text":"Kotlin 1.1 今天正式发布了，这让 Kotlin 有能力适用于更多的应用场景，希望大家能够喜欢。 我们希望 Kotlin 能够在应用的任何组件中成为独立的、富有表现力且性能强大的强类型语言，Kotlin1.1 为了实现这一目标迈出了巨大的两步。 首先，JavaScript 支持的“试验性”标签已被移除，并且支持所有 Kotlin 语言特性、标准库的大部分内容以及 JavaScript 互操作性。这意味着开发者可以完全使用 Kotlin 来编写整个 WEB 应用，同时继续使用 JavaScript 的开发框架（比如 React）。 其次，我们引入了协程(coroutines)的概念。作为线程的轻量级替代方案，协程在应用程序后端可以具有更大可扩展性，从而支持单个 JVM 实例上的大量工作负载。除此之外，协程对于实现异步行为具有强大的表现力，这对于在任何平台上构建响应式用户交互界面而言极其重要。 下面我们将进一步介绍这两大功能。其他部分如type aliases，callable references，destructuring in lambdas等详情可在最新消息查看，试试完整的可运行示例代码！ 协程(Coroutines)在 Kotlin 中协程使非阻塞式异步代码与同步代码一样易于理解。 异步编程正当风靡，唯一让我们思虑的是，非阻塞式代码大量增加了系统的复杂性。 而 Kotlin 现在提供了简化这种复杂性的方法，通过单原子让协程在语言中成为一等公民：挂起函数。这种类型的函数（或 lambda）表示在计算运行中可以被挂起（不阻塞任何线程），而后也能继续恢复运行。 从技术上说，协程是多任务协作的轻量级解决方案（类似于fibers)）。换言之，他们只是更好的线程：可以任意的启动和保留，且挂起的消耗极其之低（挂起之于协程，如阻塞之于线程），非常易于组合与订制。 我们对于协程的设计以实现最大的灵活性为目标：在语言中固化的部分少，而且可以作为库来实现很多功能。kotlinx.coroutines项目在 Rx，CompletableFuture，NIO，JavaFx 和 Swing 上均有设计功能库，甚至可以为 Android 和 JavaScript 编写类似的库。即使在其​​他语言中许多内置构建现在也可以用 Kotlin 库来编写。包括 Python 的 generators/yield，来自 Go 的 channels/select 以及 C＃的 async/await: 12345678910111213141516// runs the code in the background thread poolfun asyncOverlay() = async(CommonPool) &#123; // start two async operations val original = asyncLoadImage(\"original\") val overlay = asyncLoadImage(\"overlay\") // and then apply overlay to both results applyOverlay(original.await(), overlay.await())&#125; // launches new coroutine in UI contextlaunch(UI) &#123; // wait for async overlay to complete val image = asyncOverlay().await() // and then show it in UI showImage(image)&#125; 查看完整内容。 重要提示：凭借上述的这些优势，Kotlin 协程近乎全新的设计，在我们能确定这是 100％正确和完整之前，仍然需要大量的实践和测试。因此我们才选择在“实验性”标志下发布。我们不希望语言规则发生变化，但 API 可能需要在 Kotlin 1.2 中进行调整。 JavaScript 支持如上所述，Kotlin 1.1 中的所有语言特性（包括协程）都适用于 JVM / Android 和 JavaScript（JavaScript 的反射目前不可用，但我们正在这方面努力）。这意味着 Web 应用程序可以完全使用 Kotlin 编写，而且我们已经在 JetBrains 内部有一些尝试，相信很快就会发布教程和其他资料。 Kotlin for JavaScript 具有与“源生”JavaScript 代码进行互相操作的动态类型，通过类型 API 可以使用ts2kt converter以及DefinitelyTyped等知名库。 我们支持 Node.js 和浏览器。 Kotlin 标准库可通过npm使用。文档链接 。 工具Kotlin 1.1 并不是 Kotlin 工具发布的主版本：我们更喜欢具有这些功能的工具就绪后，不会对语言本身产生影响，所以我们在 Kotlin 1.0.x 版本中的有许多这样的改进： 主流 IDE 的 Kotlin 插件：IntelliJ IDEA，Android Studio，Eclipse 和 NetBeans IntelliJ IDEA 和 Gradle 中的增量编译 Spring，JPA 和 Mockito 的编译器插件（all-open 与 no-arg） 注解处理器 kapt 对 Android 项目的支持 Lint 检查 大量的 IDE 代码预测，检查，快速修复，重构和自动完成提升 我们将继续在 1.1.x 版本中进行更新，努力为开发者们提供更好的工具。 Kotlin 元年：迁移与社区总而言之，Kotlin 正在逐渐壮大。去年，我们看到有超过 160,000 人使用，Github 上的 Kotlin 开源项目从 2.4M 增加到 10M（约 4 倍）。我们的 Slack 社区已经从 1,400 人增长到超过 5,700 人（超过 4 倍）。世界各地均有社区组织了众多的线下交流以及用户群组，我们也看到越来越多的 Kotlin 书籍和在线课程发布。 Kotlin 在服务器端和 Android 端（开发人员数量均等）表现异常强大。 Spring 框架 5.0和vert.x 3.4均引入了对 Kotlin 的支持。 Gradle和TeamCity正在使用 Kotlin 构建脚本。更多使用 Kotlin 的项目可以在kotlin.link查看。 许多知名公司也正在使用 Kotlin：Pinterest，Coursera，Netflix，Uber，Square，Trello，Basecamp；除此之外， 由知名银行（如高盛，富国银行，摩根大通，德意志银行，瑞银，汇丰银行，法国巴黎银行，SociétéGénérale）联盟开发的分销账户分类账户Corda，其代码库中有超过 90％的部分使用 Kotlin。我们感谢世界各地的所有用户，贡献者和倡导者。您的支持对我们非常重要！ 组织您自己的 Kotlin 1.1 活动Kotlin 1.1 的发布是与当地社区好友线下聚会的好话题。我们已经准备了一些资料来帮助开发者们举办此类活动。3 月 23 日，我们将以 Kotlin 团队成员的形式进行现场直播，发起人均可获得一个背包，里面有一份关于未来特性的调查问卷和一些小礼物，点击注册即可参与。 后续为了使 Kotlin 成为真正的全栈语言，我们将为多个平台编译相同的代码提供工具和语言支持。这将有助于在客户端和服务器之间进行模块共享。我们将继续致力于改进 JavaScript 工具和库的支持。除此之外，JavaScript 平台的增量编译正在进行中。请继续关注 1.1.x 更新。 Java 9 即将推出，我们将在发布之前为其新功能提供支持。 我们期望在未来几个月内能够收到许多关于协程反馈意见，改进这一领域（在性能和功能方面）对于我们优先级最高。除此之外，下一版本的主要工作将集中在维护，性能改进，基础架构和错误修复方面。P.S 跨平台运行是 Kotlin 的战略方向，伴随着 1.1 的发布，我们可以在服务器，台式机，Android 设备和浏览器上运行，但是未来我们将把 Kotlin 编译为本地代码，并使之能够在更多平台（例如 iOS 和嵌入式设备等）上运行。 目前在 JetBrains 内部，有一个非常棒的团队正在开展这个项目，我们期待很快就会出现有趣的东西，不过尚未计划为此专门发布任何版本。 安装说明与以往一样，开发者可以使用Kotlin 线上编辑器 try.kotlinlang.org。 Maven/Gradle：使用1.1.0作为编译器和标准库的版本号(查看文档)。 IntelliJ IDEA：2017.1 已包含 Kotlin 1.1；旧版本则需要安装 Kotlin 插件或更新到 1.1 版本。 Android Studio：通过Plugin Manager安装或更新插件。 Eclipse：使用Marketplace 安装插件。 命令行编译器可以从Github 发布页面下载。 兼容性：Kotlin 1.1 语言和标准库向后兼容(modulo bugs) ：如果使用 1.0 版本编译运行，1.1 版本仍然可以运行。为了帮助大型团队有规律的更新，我们在编译器中新增禁用新功能的开关。查看踩坑文档。 请尽情享受 Kotlin！ P.S: 在Reddit和Hacker News上加入讨论吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 候选版本来啦","date":"2017-02-17T05:37:00.000Z","path":"2017/02/17/Kotlin 1.1 Release Candidate is Here.html","text":"截至今天，Kotlin 1.1 终于到了候选版本（RC）阶段。这意味着大部分开发工作都已经完成，我们对此结果感到满意，很快就会发布 Kotlin 1.1 正式版。我们已经在内部对此版本进行了大量测试，但现实世界总是比任何测试环境更加多样化，因此我们需要您的帮助。请尝试这个版本，让我们知道您的体验！ 候选版本中唯一的新功能是 takeUnless 函数，它对应 1.1 之前添加的 takeIf，但判断条件相反。至于错误修复则有很多，完整清单请查看更新日志。除此之外，我们还修复了几个 IDE 中的性能问题，包括长期存在和最近回归才出现的。 迁移说明就像我们之前提到的，预发布版本生成的所有二进制文件不能在当前的编译器下使用：您现在需要重新编译由 1.1-M0x 和 Beta 编译的所有内容。当然，从 1.0.x 开始的所有代码都不需要重新编译。 在这之前，您可以从 Java 6 开始，以任何版本的 Java 运行 Kotlin 编译器，但这从第一个 1.1.x 更新开始有变化，编译器将仅在 Java 8 或 9 下运行。为您准备迁移，编译器现在会在 Java 6 或 7 下运行时发出警告。请注意，这仅影响构建环境；编译代码默认情况下仍然与 Java 6 兼容，我们没有计划删除对它的支持。 现在不推荐使用 .javaClass 扩展属性。作为替代，请使用 ::class.java。IDE 提供了一个 quickfix 来更新写法，单独的修改或者更新整个项目。 为了减小 JavaScript 标准库的大小，我们已经将 kotlin.dom 和 kotlin.dom.build 包中的大量辅助函数注解为不推荐使用了，然后在将来的更新中删除它们。 如何尝鲜在 Maven/Gradle 中： 将 http://dl.bintray.com/kotlin/kotlin-eap-1.1 添加为构建脚本和项目的仓库；使用 1.1.0-rc-91 作为编译器和标准库的版本号。 在 IntelliJ IDEA 中： 点击菜单 Tools → Kotlin → Configure Kotlin Plugin Updates，然后在 Update channel 的下拉列表中选择 “Early Access Preview 1.1”，接着点击 Check for updates。 在 Eclipse 中： 从以下更新站点安装插件https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.0 The command-line compiler 可以从 Github 发布页面下载。最后，让我们开启 Kotlin 之旅吧！try.kotlinlang.org。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"Kotlin 1.1 Beta 2 发布~","date":"2017-02-06T00:14:15.000Z","path":"2017/02/06/Kotlin 1.1 Beta 2 发布~.html","text":"1 协程改包名风波说真的，看到这个标题的时候我还挺兴奋，离 release 又近了一步。不过，看了这篇文章的时候，我就觉得也是醉醉的。发生了啥呢？ 原来，协程相关的依赖统统被标记为 experimental 了，以前叫： 1package kotlin.coroutines 现在呢？ 1package kotlin.coroutines.experimental 这意味着啥？意味着我们在这次更新之后，还得把原来的协程代码的包重新导入一遍，另外，如果你想使用协程，那么你还需要在配置当中呢启用它，例如 gradle 配置需要加入： 12345kotlin &#123; experimental &#123; coroutines 'enable' &#125;&#125; 你在升级所有的依赖的时候，确保它是兼容 1.1.0-beta-38 的，这一点很重要，不然等着报错吧！ 话说，为啥要这么搞呢？按照官方的说法就是，协程这个特性目前已经实现的非常不错了，内置 API 非常少，灵活扩展性也强，不过他们觉得这个东西还有很大的潜力，也不能就这样作为最终版本给大家放出来，而作为实验特性交给大家使用呢，更多地还是希望大家能提提意见啥的。嗯，说实在的，协程这个特性真不是个小特性。 2 兼容 1.0话说，1.1 的编译器终于声称兼容 1.0 的源码了，这表明我们再也不用搞两个 IntelliJ 分别装 1.0 稳定版的插件和 1.1 Beta 版的插件了。 是的，就算你不用 1.1 的特性，你装 1.1 的插件，用 1.1 的编译器，写 1.0 的代码毫无压力！！ 什么？你问我试了没？当然，我一直用最新的插件，折腾地挺苦的 T T，劝诸君还是装稳定版吧，吃螃蟹要做好心理准备~！ 3 小结浏览了一下 1.1Beta 2 的主要特性，其实就是改改包名，修几个小 Bug，大的改动基本没有了。如果大家想要尽早上手 1.1 的特性，那么就从现在开始吧~ 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"Kotlin 1.0.6","date":"2017-01-02T08:22:57.000Z","path":"2017/01/02/Kotlin 1.0.6.html","text":"我把所有文章和视频都放到了 Github 上 ，如果你喜欢，请给个 Star，谢谢~ 在上周二，Kotlin 1.0.6 发布啦！这次更新主要是工具更新和bug修复。本文的内容主要来自官方博客。 IDE 插件的更新 try-finally 转换为 use() 通常我们在进行 IO 操作的时候，我们并不希望异常影响我们程序的执行，所以我们需要对异常进行捕获，但捕获的话我们也没有必要处理，所以写下来的就是下面的形式： 12345try&#123; ... do something with \"reader\" ...&#125;finally&#123; reader.close()&#125; 但这样写起来是不是非常的不流畅？如果用 use() 的话，简直一气呵成： 123reader.use&#123; reader -&gt; ... do something with \"reader\" ...&#125; 所以，这次更新 Kotlin 的插件为我们带来了这样的自动转换功能： 补全具名参数 通常我们在编写代码的时候，函数入参都会按照顺序一个一个传入，不过随着代码量的增加，特别是对于参数较多的函数，一长串的代码看上去会让我们感到非常的头疼。所以，这次更新 Kotlin 还为我们带来了自动补全具名参数的功能。 删除空构造方法的声明 合并声明和赋值 inline 函数的问题修复和调试工具的优化 提示、KDoc 和 Quick Doc 相关的较多问题的修复 Android 相关更新 支持 Android Studio 2.3 beta 1 和 Android Gradle Plugin 2.3.0-alpha3及更新的版本 增加 “Create XML resource” 的提示 Android Extensions support 这个功能可以让我们很方便的引用 XML 布局的 View，不过这需要我们主动启用 ‘kotlin-android-extensions’ 才行。在过去，即使不启用这个插件，IDE 也会允许我们直接引用 XML 布局的 View，但这并不能正常编译，所以这次更新修复了这个问题：只有启用了这个插件，IDE 才会允许我们引用对应的 View。 Android Lint 相关的问题修复。 增加 Suppress Lint 提示。 Kapt 优化尽管还不能完全支持增量编译，相比 1.0.4，这次更新较大的提升了 Kapt 的性能。如果需要启用 Kapt，请在 gradle 当中启动它：plugin: 'kotlin-kapt'```123456789101112131415161718192021222324252627282930313233## All-open 插件我们知道 Kotlin 的所有类及其成员默认情况下都是 final 的，也就是说你想要继承一个类，就要不断得写各种 open。刚开始看到这一特性的时候，觉得很赞，它对培养良好的编码意识非常有帮助，不过它也在某些情况下给我们带来麻烦，比如在一些大量依赖继承和覆写的 Java 框架的使用中。这一次 Kotlin 提供了一个妥协的办法，主要某个类被某一个特定注解标注，那么这个类就默认所有成员通通 open，省得一个一个写了。有关 allopen 的讨论，大家可以参考这里 [KEEP](https://github.com/Kotlin/KEEP/pull/40)。那么 allopen 如何使用呢？```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125;apply plugin: &quot;kotlin-allopen&quot;allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125;buildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125;apply plugin: &quot;kotlin-allopen&quot;allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 那么所有被 com.your.Annotation 这个注解标注的类成员都会默认 open。除此之外，它还可以作为元注解使用： 12345@com.your.Annotationannotation class MyFrameworkAnnotation@MyFrameworkAnnotationclass MyClass // will be all-open Kotlin 还提供了 “kotlin-spring” 插件，其中包含了 spring 相关的所有注解，这样免得我们一个一个在 allopen 的配置中声明了。 No-arg 插件如果大家看过我的视频，一定对我之前提到的“毁三观”的实例化有印象吧，附上视频连接：12 Json数据引发的血案，其中我们提到对于没有无参构造方法的 Kotlin 类，Gson 反序列化它们的时候，不知道如何实例化它们，只好用到了 这个类。听说 Java 9 要移除这个略显黑科技的类，如果是这样，Gson 是不是会被削弱呢？Java 的心我们还是不操了，从 Kotlin 1.0.6 开始，这个问题将得到一个比较好的解决。1234567891011121314```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot; &#125;&#125;// Or &quot;kotlin-jpa&quot; for the Java Persistence API supportapply plugin: &quot;kotlin-noarg&quot;noArg &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 类似于 allopen 的使用方法，如果某个类需要无参默认构造方法，你只需要用上面声明好的注解 com.your.Annotation 标注即可。当然，这个生成的默认构造方法只能通过反射调用。 如何更新我一直觉得虽然我们出生就被选择了 Hard 模式，但我们没啥感觉啊。可是最近一直访问国外的网站，感觉真的好困难，宽带换成了电信 100M，下载 Kotlin 的插件仍然跟小水管一样，真也是没谁了。为了方便大家我把我下载的几个版本的插件放到百度网盘，供大家使用，请大家点击阅读原文获取下载地址。 小结目前 Kotlin 1.0.x 的版本更新更侧重于稳定性和易用性，因此语言上的特性基本不会更新，主要集中于 IDE 插件和编译器插件。如果大家期待语言特性的更新，那我们就去关注一下 1.1 吧！ 发现更多有趣好玩的，欢迎关注我的微信公众号","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.0 Beta 3 发布啦!","date":"2015-12-07T07:45:00.000Z","path":"2015/12/07/Kotlin 1.0 Beta 3 is Out!.html","text":"我们很高兴发布了 Kotlin 1.0 Beta 的另一个更新。我们正在努力完善标准库，抛弃了过时已久的设计结构，同时修复了 bugs，改进性能和为下一个版本作准备。完整的更新历史在 这里 。 最新的 issue 在 这里 。 Library 变更我们努力在 1.0 版本到来之前让标准库变得更加完美。这意味着进行一些尝试，所以会有新的部分被弃用，有新的函数被添加。我们计划在 1.0 版本（或 RC）中对标准库进行一次最后的清理：删除所有已过时和其他遗留的东西。这里我们只关心一个需要注意的变化：现在contains()和其他类似的扩展方法接受集合元素的父类型。 1234567// strs: Collection&lt;String&gt;// ns: String?// cs: CharSequence// i: Intstrs.contains(ns) // accepted nowstrs.contains(cs) // accepted nowstr.contains(i) // ERROR (in fact, a deprecation warning, but will be an error soon) 我们发现以前建议的containsRaw方法比较低效，使用contains()更加合适，同时保证了兼容性。请注意，集合接口本身是完整的，所有这些都是通过扩展功能完成的。请使用Code Cleanup来迁移代码。 语言变化一些需要注意的语言变化，完整列表在这里 。 许多我们以前不推荐的实现现在会报错。请使用Code Cleanup进行迁移。 When 表达式这种代码已被证明是有问题的，所以我们决定弃用它： 1234when &#123; foo.isValid(), foo.isReady() -&gt; process(foo) ...&#125; 许多人倾向于认为条件 foo.isValid(), foo.isReady() 表示 foo.isValid() == true and foo.isReady() == true，而实际上逗号是指 or。解决方法很简单：只需使用 ||: 1234when &#123; foo.isValid() || foo.isReady() -&gt; process(foo) ...&#125; Code Cleanup会自动迁移。 注释一个 bug 已被修复，现在我们可以在注解的参数中使用默认值： 12345annotation class Entry(val value: String) annotation class Example( val entries: Array&lt;Entry&gt; = arrayOf(Entry(\"a\"), Entry(\"b\")) // OK now) 枚举值()最近我们将传统的 Java 的Enum.values()更改为一个属性：Enum.values，但现在我们将回滚这个更改，因为有一个没有注意到的角落：枚举中的常量可能被命名为values，然后便没有办法访问其中的任何一个。我们考虑了不同的方案，最后决定将values改回函数是最干净的。所以，现在不推荐使用values属性，也不推荐使用values()函数。 可见性和作用域我们正在清理和修正小问题的可见性和作用域 companion objects 中允许 protected 成员 子类调用非 @JvmStatic 的 protected 对象将被标记为错误（不支持） 对于 open 属性，私有 setters 现在已被标记为过时 local sealed class 已弃用（从不可用） 重写的 setter 不能降低可见性 枚举类中不再允许存在内部类 lambdas / object literals / local 函数中禁止使用未初始化的变量 Android 扩展我们合并了 IntelliJ IDEA 的主要 Kotlin 插件和 Android 的Kotlin扩展插件。后者现在已经过时了，因为它的功能可以从 Kotlin 插件获取。此外，我们还添加了对 Android productFlavors的支持：现在，来自不同 flavors 的属性可以在不同的包中使用。例如，我们可以在build.gradle文件中存在两种 flavors： 12345678productFlavors &#123; free &#123; versionName \"1.0-free\" &#125; pro &#123; versionName \"1.0-pro\" &#125;&#125; 现在，我们不仅可以在main source set中的布局使用合成属性，还可以在 flavor 布局使用合成属性： 1234567891011121314// Import synthetic properties for the `activity_free.xml` layout in the `free` flavorimport kotlinx.android.synthetic.free.activity_free.versionMarker class FreeActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; ... setContentView(R.layout.activity_free) ... versionMarker.text = \"Free version\" &#125;&#125; 请注意，main source set的所有布局现在位于kotlinx.android.synthetic.main包之下，旧的包命名约定已被弃用。 IDE 中的新功能 Android Extensions 插件已被合并到 Kotlin 插件中，不再需要单独安装 创建新的 Gradle 工程时，添加了 Kotlin 的选项以供选择： 调试器：stacktrace 导航功能现在支持跟踪内联函数的堆栈帧。同时对内联函数的步进调试功能进行了一系列的改进。 添加了三个快速初始化新属性的Quick Fixes： Introduce Variable（Ctrl + Alt + V / Cmd + Alt + V）现在支持结构声明(multi-declarations)： 同时Introduce Variable还能使用于 lambda 或匿名函数中： Beta 3 开始支持在字符串模板中使用 Introduce Variable/Parameter/Property/Function 最后，添加了一个实验功能 —— 在 IDE 中对 Kotlin 脚本文件（.kts）做了基本的支持","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/itgoyo/tags/Kotlin/"}]}]